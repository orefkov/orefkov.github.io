<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.4.0</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('overview.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Overview</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md59"></a>
Strings in C++</h1>
<p>(, what's wrong with you?)</p>
<p><span class="obfuscator"><a href="overview_ru.md">On Russian | По-русски</a></span></p>
<p><cite> In a 1991 retrospective on the history of C++, its creator Bjarne Stroustrup called the lack of a standard string type (and some other standard types) in C++ 1.0 the worst mistake he made in its development: "Their absence led to everyone reinventing the wheel and to an unnecessary diversity in the most fundamental classes" </cite></p>
<h2><a class="anchor" id="autotoc_md60"></a>
What was and is</h2>
<p>In the introductory part, I want to briefly describe the current state of strings in C++, how we got to it, and why it is so. I will also describe the shortcomings of current implementations so that the solutions I use in my string library are clear.</p>
<p>Actually, initially there was no standard type for strings in C++. The approach from C was used to work with strings – a string is a pointer to an array of bytes ending in zero. The disadvantages of such strings are that it is impossible to use the byte <code>0</code> in the string, i.e. it is not suitable for binary data, the resource management/ownership strategy is unclear, and the main disadvantage is that the length of the string has to be calculated each time, iterating over all its characters.</p>
<p>The origin of this solution is quite clear – from the time of the dinosaurs: just as dinosaurs were large, with small brains and short arms, so computers were large, memory was small, and strings were short. Saving memory on storing the length of a string was more important than losing time on repeatedly calculating the length.</p>
<p>The first attempts to standardize strings as a class began only in C++98 - std::string appeared as part of STL, and like much of STL, it was extremely ambiguously perceived by programmers.</p>
<p>And the first thing that comes to mind when improving C-strings is that you need to store the length of the string: </p><div class="fragment"><div class="line">    <span class="keyword">struct </span>simple_string {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* data;</div>
<div class="line">        <span class="keywordtype">size_t</span> length;</div>
<div class="line">    };</div>
</div><!-- fragment --><p>With such a string, many algorithms are significantly optimized. For example, when comparing two strings for equality, we may not even start comparing their characters if the lengths of the strings are not equal. Moreover, this data is absolutely sufficient for all methods that do not modify the string. Also note that such an object on modern 64-bit architectures is perfectly passed to functions by value – both of its fields fit into registers (well, except for Windows), which makes it easier for the compiler optimizer to work.</p>
<p>Meanwhile, such a solution only made it into the standard in C++17, in the form of <code>std::string_view</code>. Apparently, only then could the committee be convinced that strings are different, and using only one universal object for strings – at the very least, can lead to a decrease in performance, and also violates the principle of "don't pay for what you
    don't use". Why are "strings different" and why is one type of string not enough for us, we will consider just below.</p>
<h3><a class="anchor" id="autotoc_md61"></a>
Resources</h3>
<p>And the next question that arises with strings is resource ownership. Almost every major framework solved this problem on its own, inventing its own bicycles. We have <code>std::string</code>, in QT we have <code>QString</code>, in MFC - <code>CString</code>, in ATL - <code>CAtlString</code>, there are own strings in Folly, in general, "thousands of them", any game engine starts with writing its own strings.</p>
<p>Many of these implementations in the aspect of resource management used the approach to improve performance <b>COW</b> – “Copy On Write”. In this case, the string object referred to a buffer shared between several objects with the characters of the string and a reference counter to this buffer, which allowed you to quickly create a copy of the string, and actually copy the characters only when it is modified.</p>
<p>But they all coincided in one thing – the string was always assumed to be mutable, that is, we can modify the characters in the string buffer.</p>
<h3><a class="anchor" id="autotoc_md62"></a>
Mutability / immutability</h3>
<p>Because of this, the <b>COW</b> approach died by C++11: for each operation that could modify the characters of the string, it was necessary to check whether we are referring to a shared buffer, and if so, copy the characters to another buffer. In a multithreaded environment, you also need to check whether you now need to free the old buffer, and of course, all this is smeared with locks or atomics, which is also not free. Therefore, starting with C++11, <code>std::string</code> does not use <b>COW</b>, and each copying of a string object also leads to copying all the characters of the string to another buffer.</p>
<p>Naturally, each new buffer requires memory allocation, which they are trying to slightly optimize through <b>SSO</b> – “Small String Optimization”, when the string object contains a small buffer inside itself and the characters of short strings are located directly in it. But this already depends on the implementation: in some libraries they place up to 15 bytes in the string object, in some up to 23. However, this optimization is also a double-edged sword, and in various implementations it can complicate the movement of a string - if it stores a pointer to its internal buffer, it will have to be adjusted.</p>
<p>And without COW, the mutability of strings leads to the fact that any initialization of a string object leads to copying bytes. Let's look at this code: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* text1 = <span class="stringliteral">&quot;Hello, World&quot;</span>;         <span class="comment">// costs nothing</span></div>
<div class="line">std::string_view text2 = <span class="stringliteral">&quot;Hello, World&quot;</span>;    <span class="comment">// Costs nothing, calculates the length of the string at compile time</span></div>
<div class="line">std::string text3 = <span class="stringliteral">&quot;Hello, World&quot;</span>;         <span class="comment">// Copies the characters of the string every time at runtime</span></div>
</div><!-- fragment --><p>(You can verify the truth of the comments at <a href="https://godbolt.org/z/51oKGWT5T">https://godbolt.org/z/51oKGWT5T</a> )</p>
<p>But if we don’t need to modify the string in any way further in the code, we are wasting money on allocation, copying characters, as well as on the string destructor. That is, I would like to have at least two versions of strings – mutable and immutable, to explicitly make it clear to the compiler that we are not going to modify the string. Or a banal example – we are parsing some incoming data buffer, we need to check whether a certain piece of the buffer is equal to the string "hello" in "pure C++", i.e. without any memcmp and strcmp. Before the advent of string_view, it had to be done something like this: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_part_buffer_equal_hello(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end) {</div>
<div class="line">    <span class="keywordflow">return</span> std::string(data + start, end - start) == <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here it turns out that first the characters from the data buffer are copied to the buffer of the temporary string, possibly with memory allocation, and only then the temporary string is compared with "hello", and then also the destructor and stack unwinding in case of an exception.</p>
<p>When using <code>std::string_view</code> instead of <code>std::string</code> – the code in C++ almost does not change: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_part_buffer_equal_hello_view(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end) {</div>
<div class="line">    <span class="keywordflow">return</span> std::string_view(data + start, end - start) == <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> However, the generated machine code is significantly transformed, reaching the level of manual C-code – there it is simply compared that end – start == 5 and then a piece of the initial buffer is compared via memcmp with the string "hello" (with -O2 with constants 1819043176 ('hell') and 111 ('o')). No creation of a temporary object, no copying of bytes, no destructor, no stack unwinding for exceptions. You can verify this at <a href="https://godbolt.org/z/9fo188e7c">https://godbolt.org/z/9fo188e7c</a></p>
<p>It would seem, well, <code>string_view</code> appeared in C++17, please, use it in the parameters of your functions instead of <code>const std::string&amp;</code>, and there will be happiness. But there is also a nuance here – everything works fine, as long as we don’t need to pass the string to a third-party C-API: string_view does not give guarantees of null-termination of the string, therefore its data() cannot be passed to a third-party C-API, and therefore you will still have to copy it to <code>std::string</code> first. And since <code>std::string</code> is needed, then it is more optimal to make <code>const std::string&amp;</code> the parameter of the function and further down the chain, all parameters will again become <code>const std::string&amp;</code>.</p>
<h3><a class="anchor" id="autotoc_md63"></a>
String concatenation</h3>
<p>Next, after initializing a string, the most frequent mutable operation with them is most likely string concatenation, either in the form of simply adding strings, or adding a string to a string. And it is she who can easily cause both suboptimal performance with illiterate use, and memory overhead, even with competent use.</p>
<p>Consider a simple code ( <a href="https://godbolt.org/z/odx7W1Pv7">https://godbolt.org/z/odx7W1Pv7</a> ) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> some_outer_function(<span class="keyword">const</span> std::string&amp;);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> func(<span class="keyword">const</span> std::string&amp; s1, <span class="keyword">const</span> std::string&amp; s2) {</div>
<div class="line">    std::string concat = s1 + s2 + <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line">    some_outer_function(concat);</div>
<div class="line">}</div>
</div><!-- fragment --><p> As we can see, both in clang and in GCC, several temporary objects are created, into which the characters of the strings are sequentially shifted, and as a result – we get several extra allocations for intermediate buffers, the characters from the strings are copied several extra times from intermediate buffers. Ideally, for better performance, this code needs to be rewritten like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> some_outer_function(<span class="keyword">const</span> std::string&amp;);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> func(<span class="keyword">const</span> std::string&amp; s1, <span class="keyword">const</span> std::string&amp; s2) {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> std::string_view hello = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line">    std::string concat;</div>
<div class="line">    concat.reserve(s1.size() + s2.size() + hello.size());</div>
<div class="line">    concat += s1;</div>
<div class="line">    concat += s2;</div>
<div class="line">    concat += hello;</div>
<div class="line">    some_outer_function(concat);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Unfortunately, so far no compiler optimizes the first simple code to the level of the second more optimal code, and writing such code every time by hand is quite inconvenient. That is, again you have to pay for what you don’t use. And in this case, memory overhead may well occur – string addition operations usually increase the size of the string buffer in all implementations by at least two times, assuming that something may soon be added to the string again. Therefore, if the string is no longer planned to be modified, but its lifetime has not yet come to an end (for example, this is a field of some class), you should not forget to do <code>shrink_to_fit</code> on it.</p>
<p>Meanwhile, often the main scenario for using strings is just some preparation of the string by several modifications and concatenations, and then it is stored somewhere, no longer changing. In this case, the programmer usually knows approximately what size of strings is expected in this place, and could allocate a buffer for these intermediate modifications directly on the stack, resorting to dynamic allocation only when exceeding the size of this buffer. However, with the current implementation of strings, this is quite problematic, or inconvenient.</p>
<p>Let's summarize what we have at the moment:</p>
<ul>
<li>"Out of the box" in C++ for working with strings there is now <code>std::string</code>.</li>
<li>Strings are assumed to be mutable, which leads to mandatory copying of all characters of the string during initialization and copying of string objects.</li>
<li>Accordingly, we do not have the ability to quickly copy strings, even if we do not plan to change the copy later.</li>
<li>Concatenating several strings is a task that can be performed suboptimally, lead to memory overhead, and it is difficult to write optimal code.</li>
<li>There is a crutch for immutable strings in the form of <code>std::string_view</code>, but it does not solve the issues of string ownership, so in fact it is only suitable as a type for passing parameters to functions that do not change strings, with the caveat that it cannot be used in functions calling C-API, since it does not guarantee null-termination.</li>
<li>Well, and there are questions to <code>std::string</code> that despite the fact that this is a class for strings, in fact, for working with strings it has an extremely meager functionality compared to what they are used to in other languages – for example, there is no replacement of substrings by a pattern (in other languages this is usually replace, but in C++ this function does something completely different), trim, split, join, upper, lower, etc. These functions have to be written by yourself every time, and it is not a fact that everyone will be able to do this optimally.</li>
</ul>
<p>I hope that after this small introduction you will better understand what problems I solved with my string library and how.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Simstr library</h2>
<p>Actually, you can't say that "I reinvented my implementation of the class for strings." As I showed earlier, it is difficult, or even impossible, to write one single string class that is well suited for all scenarios of use. That is why I don’t have a string class, but a string library, which contains several different string types, from simpler to more complex, each of which has its own strengths and weaknesses, and the user needs to competently approach the question of which of these classes should be used in which case.</p>
<p>I started developing the library itself little by little back in 2011-2012, when we already had move semantics, but not yet there was std::string_view. However, now the minimum standard version for the library to work is: <b>C++20</b> – concepts and &lt;format&gt; are used.</p>
<p>First, I will talk about the library classes for the strings themselves, and then about how the string concatenation problem is optimally solved in it.</p>
<p>Several general points:</p><ul>
<li>All classes for working with strings are templated by the type of characters, but it is assumed that the characters can be <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>.</li>
<li>All strings have an explicit length.</li>
<li>The string owner classes store them with a trailing zero at the end, which is not included in the length of the string.</li>
<li>The string itself can contain zero characters, all algorithms work only through the length of the string, without paying attention to them.</li>
<li>The library considers different string types to be "compatible" if they have the same character size. That is, <code>char</code> and <code>char8_t</code> are always identical, and also in Linux <code>wchar_t</code> and <code>char32_t</code> are identical, and in Windows <code>wchar_t</code> and <code>char16_t</code>.</li>
<li>The string owner classes can be initialized with strings of another character type, performing conversion between UTF-8, UTF-16, UTF-32. Moreover, if the strings are of different but compatible types, they are simply copied without conversion.</li>
<li>Built-in tables for the first plane of Unicode are used to change the case of characters and compare strings case-insensitively (up to 0xFFFF). Strings are considered to be represented in UTF-8, UTF-16, UTF-32 encoding, respectively. However, string normalization is not done and situations where changing the case of a character leads to a change in their number are not handled. That is, the case conversion of characters corresponds to <code>std::towupper</code>, <code>std::towlower</code> for the unicode locale, only faster and can work with any type of characters. If you need strict work with unicode, use other tools, such as ICU.</li>
</ul>
<h3><a class="anchor" id="autotoc_md65"></a>
String classes.</h3>
<h4><a class="anchor" id="autotoc_md66"></a>
The first simplest string class is called, of course, <code>simple_str</code> :)</h4>
<p>(<a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simstr::simple_str</a>)</p>
<p>The class simply represents a pointer to the beginning of a constant string and its length, in fact the same as <code>std::string_view</code>. It is intended for working with immutable strings, not owning them, that is, you must take care that the real string, represented through <code>simple_str</code> – is alive during its use.</p>
<p>Implements all string methods that do not modify the string.</p>
<p>Aliases:</p><ul>
<li><code>ssa</code> for simple_str&lt;char&gt;</li>
<li><code>ssb</code> for simple_str&lt;char8_t&gt;</li>
<li><code>ssu</code> for simple_str&lt;char16_t&gt;</li>
<li><code>ssw</code> for simple_str&lt;wchar_t&gt;</li>
<li><code>ssuu</code> for simple_str&lt;char32_t&gt;</li>
</ul>
<p>It is used mainly for passing strings as a parameter to functions that do not modify the passed string, instead of <code>const std::string&amp;</code>, as well as for local variables when working with parts of strings.</p>
<h4><a class="anchor" id="autotoc_md67"></a>
The second class is <code>simple_str_nt</code></h4>
<p>(<a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simstr::simple_str_nt</a>)</p>
<p>In terms of structure and purpose, it coincides with <code>simple_str</code>, but guarantees null-termination of the string. That is, if the function needs to pass the passed parameter further as a C-string to some API without changes, it should use the <code>simple_str_nt</code> type for the parameter. All classes of owning strings (<a class="el" href="classsimstr_1_1sstring.html" title="Immutable owning string class.">simstr::sstring</a>, <a class="el" href="classsimstr_1_1lstring.html" title="The mutable, owning string class. Contains an internal buffer for text of a given size.">simstr::lstring</a>) can be converted to <code>simple_str_nt</code>, since they store strings with a trailing zero. This allows you to write functions with a single parameter type that accepts any type of owning string objects as input.</p>
<p>Aliases:</p><ul>
<li><code>stra</code> for simple_str_nt&lt;char&gt;</li>
<li><code>strb</code> for simple_str_nt&lt;char8_t&gt;</li>
<li><code>stru</code> for simple_str_nt&lt;char16_t&gt;</li>
<li><code>strw</code> for simple_str_nt&lt;wchar_t&gt;</li>
<li><code>struu</code> for simple_str_nt&lt;char32_t&gt;</li>
</ul>
<p>Can be initialized with string literals: </p><div class="fragment"><div class="line">stra text = <span class="stringliteral">&quot;Text&quot;</span>;</div>
</div><!-- fragment --><p> In this case, the length is calculated immediately at compile time. Similarly, <code>simple_str_nt</code> is created using <code>operator""_ss</code>:</p>
<div class="fragment"><div class="line">stringa result = <span class="stringliteral">&quot;Count: &quot;</span>_ss + count;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md68"></a>
Sstring class (shared string).</h4>
<p>(<a class="el" href="classsimstr_1_1sstring.html" title="Immutable owning string class.">simstr::sstring</a>)</p>
<p>A class that can store an immutable string. That is, you can only assign a string to it entirely, you cannot modify the characters of the string.</p>
<p>Owns the string, manages the memory for the characters of the string. Stores a trailing zero with the strings, and can be a source for <code>simple_str_nt</code>, for passing to C-API. Like <code>simple_str</code>, it implements all methods that do not modify the string.</p>
<p>Aliases:</p><ul>
<li><code>stringa</code> for sstring&lt;char&gt;</li>
<li><code>stringb</code> for sstring&lt;char8_t&gt;</li>
<li><code>stringu</code> for sstring&lt;char16_t&gt;</li>
<li><code>stringw</code> for sstring&lt;wchar_t&gt;</li>
<li><code>stringuu</code> for sstring&lt;char32_t&gt;</li>
</ul>
<p>The fact that the stored string is immutable allows you to apply a number of optimizations:</p><ul>
<li>For strings that are not suitable for SSO, it uses a common shared buffer with an atomic reference counter. Allows you to quickly copy a string without the need to block access to the contents of the buffer.</li>
<li>There is no need to store the buffer size (capacity) – we are not adding anything to the buffer anyway.</li>
<li>Allows you to simply refer to program literals without copying their characters to any buffer: <div class="fragment"><div class="line">stringa str = <span class="stringliteral">&quot;Hello!&quot;</span>;       <span class="comment">// Costs nothing, does not copy the bytes of the string</span></div>
<div class="line">stringa ltr = stra{<span class="stringliteral">&quot;Hello!&quot;</span>}; <span class="comment">// But here it copies the bytes of the string to ltr</span></div>
</div><!-- fragment --></li>
</ul>
<p>The class also uses <b>SSO</b> – Small String Optimization. Short strings are placed inside the object itself in an internal buffer.</p>
<p>Sizes:</p>
<p>For 64 bits:</p><ul>
<li><code>stringa</code> – class 24 bytes, SSO up to 23 characters.</li>
<li><code>stringu</code> – class 32 bytes, SSO up to 15 characters.</li>
<li><code>stringuu</code> – class 32 bytes, SSO up to 7 characters.</li>
</ul>
<p>For 32 bits:</p><ul>
<li><code>stringa</code> – class 16 bytes, SSO up to 15 characters.</li>
<li><code>stringu</code> – class 24 bytes, SSO up to 11 characters.</li>
<li><code>stringuu</code> – class 24 bytes, SSO up to 5 characters.</li>
</ul>
<h4><a class="anchor" id="autotoc_md69"></a>
Class lstring&lt;K, N, forShared&gt; (local string)</h4>
<p>(<a class="el" href="classsimstr_1_1lstring.html" title="The mutable, owning string class. Contains an internal buffer for text of a given size.">simstr::lstring</a>)</p>
<p>A class that stores a string and allows it to be modified. Owns the string, manages the memory for the characters of the string. Stores a trailing zero with the strings, and can be a source for <code>simple_str_nt</code>, for passing to C-API. Like all other classes, it implements all methods that do not modify the string.</p>
<p>The size of the internal buffer for storing characters is specified as <code>N</code> in the template parameter. Strings up to N characters long are stored inside the object, and when this number is exceeded, a dynamic buffer is allocated, in which the characters are saved. When copying an object, all characters are also always copied.</p>
<p>If <code>forShare</code> == true and the characters do not fit into the local buffer, then a dynamic buffer is created with additional space, so that it matches the structure of the <code>sstring</code> buffer. Then, when moving <code>lstring</code> to <code>sstring</code> – only the pointer will move to the buffer, without unnecessary copying of characters.</p>
<p>This class is convenient for working with strings as a local variable on the stack. Usually we assume the approximate size of the strings we will be working with, and we can create a local string with a buffer on the stack, and work with it. At the same time, without fear of buffer overflow, since in this case the string will switch to a dynamic buffer.</p>
<p>Aliases:</p><ul>
<li><code>lstringa&lt;N=15&gt;</code> for lsrting&lt;char, N, false&gt;</li>
<li><code>lstringb&lt;N=15&gt;</code> for lsrting&lt;char8_t, N, false&gt;</li>
<li><code>lstringu&lt;N=15&gt;</code> for lsrting&lt;char16_t, N, false&gt;</li>
<li><code>lstringw&lt;N=15&gt;</code> for lsrting&lt;wchar_t, N, false&gt;</li>
<li><code>lstringuu&lt;N=15&gt;</code> for lsrting&lt;char32_t, N, false&gt;</li>
<li><code>lstringsa&lt;N=15&gt;</code> for lsrting&lt;char, N, true&gt;</li>
<li><code>lstringsb&lt;N=15&gt;</code> for lsrting&lt;char8_t, N, true&gt;</li>
<li><code>lstringsu&lt;N=15&gt;</code> for lsrting&lt;char16_t, N, true&gt;</li>
<li><code>lstringsw&lt;N=15&gt;</code> for lsrting&lt;wchar_t, N, true&gt;</li>
<li><code>lstringsuu&lt;N=15&gt;</code> for lsrting&lt;char32_t, N, true&gt;</li>
</ul>
<p>A small example of use with explanations: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> path_separator = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> MAX_PATH = 260;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> path_separator = <span class="charliteral">&#39;/&#39;</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> get_current_dir() {</div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line">    <span class="comment">/* fills the buffer of the wchar_t string lstringw&lt;MAX_PATH&gt; from GetCurrentDirectoryW with possible</span></div>
<div class="line"><span class="comment">    increasing the buffer and converting to ut8 char. The constructor uses what appeared</span></div>
<div class="line"><span class="comment">    only in C++23 as `resize_and_overwrite`, and we had it originally :) */</span></div>
<div class="line"> </div>
<div class="line">    lstringa&lt;MAX_PATH&gt; path{lstringw&lt;MAX_PATH&gt;{ [](<span class="keyword">auto</span> p, <span class="keyword">auto</span> s) { <span class="keywordflow">return</span> GetCurrentDirectoryW(DWORD(s + 1), p); }}};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* This one line does approximately the same thing as this code.</span></div>
<div class="line"><span class="comment">    typedef struct lstringa_MAX_PATH_t {</span></div>
<div class="line"><span class="comment">        char* data;</span></div>
<div class="line"><span class="comment">        size_t length;</span></div>
<div class="line"><span class="comment">        size_t capacity;</span></div>
<div class="line"><span class="comment">        char local_buffer[MAX_PATH + 1];</span></div>
<div class="line"><span class="comment">    } lstringa_MAX_PATH;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    lstringa_MAX_PATH* get_current_dir(lstringa_MAX_PATH* result) {</span></div>
<div class="line"><span class="comment">        wchar_t buffer[MAX_PATH + 1], *buf = buffer;</span></div>
<div class="line"><span class="comment">        DWORD size = sizeof(buffer) / sizeof(wchar_t), lengthOfpath;</span></div>
<div class="line"><span class="comment">        for (;;) {</span></div>
<div class="line"><span class="comment">            // Returns either the number of copied characters without taking into account the trailing zero,</span></div>
<div class="line"><span class="comment">            // or if the buffer is small, then the required buffer size along with the trailing zero</span></div>
<div class="line"><span class="comment">            DWORD ret = GetCurrentDirectoryW(size, buf);</span></div>
<div class="line"><span class="comment">            if (ret &lt; size) {</span></div>
<div class="line"><span class="comment">                // Fits into the buffer, although in Windows paths can be longer than MAX_PATH if they start with \\?\</span></div>
<div class="line"><span class="comment">                // https://learn.microsoft.com/ru-ru/windows/win32/fileio/maximum-file-path-limitation?tabs=registry</span></div>
<div class="line"><span class="comment">                lenOfpath = ret;</span></div>
<div class="line"><span class="comment">                break;</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">            size = ret;</span></div>
<div class="line"><span class="comment">            if (buf != buffer)</span></div>
<div class="line"><span class="comment">                free(buf);</span></div>
<div class="line"><span class="comment">            buf = malloc(size);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        utf16toUtf8(buf, lengthOfPath, result);</span></div>
<div class="line"><span class="comment">        if (buf != buffer)</span></div>
<div class="line"><span class="comment">            free(buf);</span></div>
<div class="line"><span class="comment">        return result;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    lstringa&lt;MAX_PATH&gt; path{ [](<span class="keywordtype">char</span>* p, <span class="keywordtype">size_t</span> s) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* res = getcwd(p, s + 1);</div>
<div class="line">        <span class="keywordflow">if</span> (res) {</div>
<div class="line">            <span class="keywordflow">return</span> stra{res}.<a class="code hl_function" href="structsimstr_1_1simple__str.html#a574c8578274b5cc7a3e9507e8669d343">length</a>(); <span class="comment">// Returns the length of the string</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (errno == ERANGE)  <span class="comment">// Did not fit into the buffer, let&#39;s try twice as much</span></div>
<div class="line">            <span class="keywordflow">return</span> s * 2;</div>
<div class="line">        <span class="keywordflow">return</span> 0ul;</div>
<div class="line">    }};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    <span class="comment">// Let&#39;s make sure that the string will end with a directory separator</span></div>
<div class="line">    <span class="keywordflow">if</span> (!path.length() || path.at(-1) != path_separator) {</div>
<div class="line">        path += <a class="code hl_function" href="group___str_exprs.html#gab54b64072b9629a32837d9197dfe51b5">e_c</a>(1, path_separator);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> path;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">stringa build_full_path(ssa fileName) {</div>
<div class="line">    <span class="keywordflow">return</span> get_current_dir() + fileName + <span class="stringliteral">&quot;.txt&quot;</span>;</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    Here, a temporary lstringa&lt;MAX_PATH&gt; object will first be created on the stack to call get_current_dir.</span></div>
<div class="line"><span class="comment">    The get_current_dir function will fill it with the name of the current directory.</span></div>
<div class="line"><span class="comment">    In 99.9% of cases, the local buffer on the stack will be enough for this.</span></div>
<div class="line"><span class="comment">    After that, the total length for the result is calculated: the length of current_dir + the length of fileName + 4.</span></div>
<div class="line"><span class="comment">    The buffer for the string of the final result is determined - if the length is less than 24 - the string will be placed directly in stringa,</span></div>
<div class="line"><span class="comment">    otherwise a buffer for the resulting string is allocated immediately of the required size.</span></div>
<div class="line"><span class="comment">    Then the characters from current_dir, file_name, &quot;.txt&quot; are sequentially copied to the buffer of the resulting string;</span></div>
<div class="line"><span class="comment">    Well, thanks to RVO - the place for the result itself (stringa) - is allocated in the calling function,</span></div>
<div class="line"><span class="comment">    that is, there will be no additional copying upon return.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    Thus, there will be a maximum of only two memory allocations (if current_dir does not fit into MAX_PATH),</span></div>
<div class="line"><span class="comment">    or one, if the resulting string is longer than 23 characters, while this allocation will be immediately of the required size.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup___str_exprs_html_gab54b64072b9629a32837d9197dfe51b5"><div class="ttname"><a href="group___str_exprs.html#gab54b64072b9629a32837d9197dfe51b5">simstr::e_c</a></div><div class="ttdeci">constexpr expr_pad&lt; K &gt; e_c(size_t l, K s)</div><div class="ttdoc">Generates a string of l characters s of type K.</div><div class="ttdef"><b>Definition</b> strexpr.h:923</div></div>
<div class="ttc" id="astructsimstr_1_1simple__str_html_a574c8578274b5cc7a3e9507e8669d343"><div class="ttname"><a href="structsimstr_1_1simple__str.html#a574c8578274b5cc7a3e9507e8669d343">simstr::simple_str::length</a></div><div class="ttdeci">constexpr size_t length() const noexcept</div><div class="ttdoc">Get the length of the string.</div><div class="ttdef"><b>Definition</b> sstring.h:406</div></div>
</div><!-- fragment --><p>In this example, you probably noticed how strings are concatenated and wondered – how was the length of the entire result calculated with two additions in order to allocate the necessary space at once, without intermediate buffers?</p>
<p>The answer to this question:</p>
<h3><a class="anchor" id="autotoc_md70"></a>
String Expressions</h3>
<p>The fact is that there is no addition of string objects as such in the library. Addition is performed for "string expressions".</p>
<p>A <em>string expression</em> is any object of arbitrary type that has <code>length</code> and <code>place</code> functions. The <code>length</code> function returns the length of the string, and the <code>place</code> function places the characters of the string into the buffer passed to it.</p>
<p>Any owning string (<a class="el" href="classsimstr_1_1sstring.html" title="Immutable owning string class.">simstr::sstring</a>, <a class="el" href="classsimstr_1_1lstring.html" title="The mutable, owning string class. Contains an internal buffer for text of a given size.">simstr::lstring</a>) can be initialized with a string expression — it requests its length, allocates space for storing characters, and passes this space to the string expression, calling its place function.</p>
<p>In addition, all string expressions included in <code>simstr</code> can be converted to standard strings (<code>std::basic_string</code>) compatible character types, which allows you to use fast concatenation where replacing <code>std::string</code> is not yet possible. Compatible character types are those that match in size. To get a standard string before C++23, using <code>resize</code>, and then fill it using <code>data()</code>, starting with C++23 the more optimal <code>resize_and_overwrite</code> is used.</p>
<p>A template addition function is defined for string expressions: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;StrExpr A, StrExprForType&lt;<span class="keyword">typename</span> A::symb_type&gt; B&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> operator + (<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b) {</div>
<div class="line">    <span class="keywordflow">return</span> strexprjoin&lt;A, B&gt;{a, b};</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>strexprjoin</code> is a template type that is itself a string expression. It stores references to the two string expressions passed to it. When the length is requested, it returns the sum of the lengths of the two string expressions, and when placing characters, it first places the first expression in the passed buffer, then the second. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;StrExpr A, StrExprForType&lt;<span class="keyword">typename</span> A::symb_type&gt; B&gt;</div>
<div class="line"><span class="keyword">struct </span>strexprjoin {</div>
<div class="line">    <span class="keyword">using </span>symb_type = <span class="keyword">typename</span> A::symb_type;</div>
<div class="line">    <span class="keyword">const</span> A&amp; a;</div>
<div class="line">    <span class="keyword">const</span> B&amp; b;</div>
<div class="line">    <span class="keyword">constexpr</span> strexprjoin(<span class="keyword">const</span> A&amp; a_, <span class="keyword">const</span> B&amp; b_) : a(a_), b(b_){}</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> length() const noexcept { <span class="keywordflow">return</span> a.length() + b.length(); }</div>
<div class="line">    <span class="keyword">constexpr</span> symb_type* place(symb_type* p) <span class="keyword">const</span> <span class="keyword">noexcept</span> { <span class="keywordflow">return</span> b.place(a.place(p)); }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Thus, the addition operation of string expressions creates an object that is also a string expression, to which the next addition operation can also be applied, and which recursively stores references to the component parts, each of which knows its size and knows how to place itself in the result buffer. And so on, to each resulting string expression, you can reapply <code>operator +</code>, forming a chain of several string expressions, and eventually "materialize" the last resulting object, which first calculates the size of the entire total memory for the final result, and then places the nested subexpressions into one buffer.</p>
<p>The addition operation of string expressions allows you to concatenate string expressions of different but compatible types. That is, in one expression you can mix <code>""</code> and <code>u8""</code>, in Linux <code>L""</code> and <code>U""</code>, in Windows <code>L""</code> and <code>u""</code> character types. There are examples in <code>tests\test_str.cpp TEST(SimStr, StrPrintfU8)</code>.</p>
<p>All string types in the library are themselves string expressions, that is, they can serve as terms in concatenations of string expressions.</p>
<p>Also, <code>operator+</code> is defined for string expressions and string literals, string expressions and numbers (numbers are converted to decimal representation), and you can add the desired types yourself.</p>
<p>Example: </p><div class="fragment"><div class="line">stringa text = header + <span class="stringliteral">&quot; count=&quot;</span> + count + <span class="stringliteral">&quot;, done&quot;</span>;</div>
</div><!-- fragment --><p>For standard strings (<code>std::basic_string</code> and <code>std::basic_string_view</code>) addition operators with strings have also been made expressions, so variables of these types also directly participate in concatenation operations. However, standard strings can only participate directly in string expressions when the other operand is also a string expression. If the other operand is not a string expression, use a unary <code>operator+</code> before standard strings to turn <code>std::basic_string</code> or <code>std::basic_string_view</code> to a string expression.</p>
<p>Example: </p><div class="fragment"><div class="line">std::string make_text(<span class="keyword">const</span> std::string&amp; text, std::string_view what, <span class="keywordtype">int</span> count) {</div>
<div class="line">    <span class="comment">//     + turns text into a string expression, and then they are added together</span></div>
<div class="line">    <span class="keywordflow">return</span> +text + <span class="stringliteral">&quot; &quot;</span> + count + <span class="stringliteral">&quot; &quot;</span> + what + e_if(count &gt; 1, <span class="stringliteral">&quot;s&quot;</span>);</div>
<div class="line">    <span class="comment">//                                 what participates directly as an operand with a string expression</span></div>
<div class="line">}</div>
<div class="line">std::string make_answer(<span class="keyword">const</span> std::string&amp; text, std::string_view what, <span class="keywordtype">int</span> count) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Answer is: &quot;</span> + +text + <span class="stringliteral">&quot; &quot;</span> + count + <span class="stringliteral">&quot; &quot;</span> + what + e_if(count &gt; 1, <span class="stringliteral">&quot;s&quot;</span>);</div>
<div class="line">    <span class="comment">//                     + turns text into a string expression, and it can be added to the previous string literal</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> That is, the unary <code>+</code> is only needed somewhere at the beginning of the expression if the other operand is not a string expression.</p>
<p>There are several types of string expressions "out of the box" for performing various operations on strings:</p>
<h4><a class="anchor" id="autotoc_md71"></a>
expr_spaces&lt;CharacterType, NumberOfCharacters, Symbol = ' '&gt;{}</h4>
<p>Returns a string of length NumberOfCharacters, filled with the specified character. The number of characters and the symbol are compile-time constants. For some cases, there is a shorthand notation: </p><pre class="fragment">e_spca(NumberOfCharacters) - string of char spaces
e_spcw(NumberOfCharacters) - string of w_char spaces
</pre><h4><a class="anchor" id="autotoc_md72"></a>
expr_pad&lt;CharacterType&gt;{NumberOfCharacters, Symbol = ' '}</h4>
<p>Returns a string of length NumberOfCharacters, filled with the specified character. The number of characters and the symbol can be specified at runtime. Shorthand notation: </p><pre class="fragment">e_c(NumberOfCharacters, Symbol)
</pre><h4><a class="anchor" id="autotoc_md73"></a>
e_repeat{Str, count}</h4>
<p>Generates a repetition of a string literal or expression <code>Str</code> <code>count</code> times. </p><pre class="fragment">e_repeat("aa", 10);
</pre><h4><a class="anchor" id="autotoc_md74"></a>
e_choice(bool Condition, StrExpr1, StrExpr2)</h4>
<p>If Condition == true, the result will be StrExpr1, otherwise StrExpr2.</p>
<h4><a class="anchor" id="autotoc_md75"></a>
e_if(bool Condition, StrExpr1)</h4>
<p>If Condition == true, the result will be StrExpr1, otherwise an empty string.</p>
<h4><a class="anchor" id="autotoc_md76"></a>
expr_num&lt;CharacterType&gt;(Integer)</h4>
<p>Converts a number to decimal representation. Rarely used, since the "+" operator is overloaded for string expressions and numbers, and the number can simply be written as <code>text + number</code>;</p>
<h4><a class="anchor" id="autotoc_md77"></a>
expr_real&lt;CharacterType&gt;(RealNumber)</h4>
<p>converts a number to decimal representation. Rarely used, since the "+" operator is overloaded for string expressions and numbers, and the number can simply be written as <code>text + number</code>;</p>
<h4><a class="anchor" id="autotoc_md78"></a>
e_join&lt;bool AfterLast = false, bool OnlyNotEmpty = false&gt;&gt;(container, "Separator")</h4>
<p>Concatenates all strings in the container, using a separator. If AfterLast == true, then the separator is added after the last element of the container as well, otherwise only between elements. If OnlyNotEmpty == true, then empty strings are skipped without adding a separator.</p>
<h4><a class="anchor" id="autotoc_md79"></a>
e_repl(OriginalString, "Search", "Replace")</h4>
<p>Replaces occurrences of "Search" in the original string with "Replace". Search and replace patterns are compile-time string literals.</p>
<h4><a class="anchor" id="autotoc_md80"></a>
expr_replaced&lt;CharacterType&gt;{OriginalString, Search, Replace}</h4>
<p>Replaces occurrences of Search in the original string with Replace. Search and replace patterns can be any string objects at runtime.</p>
<h4><a class="anchor" id="autotoc_md81"></a>
empty_expr&lt;CharacterType&gt;</h4>
<p>Returns an empty string. Abbreviated notation — eea, eeu, eew, eeuu. Used if the string formation starts with a number and a string literal: </p><div class="fragment"><div class="line">str = eea + count + <span class="stringliteral">&quot; times.&quot;</span>;</div>
</div><!-- fragment --><p> since the addition operator is only defined for adding a string expression and a number. I also note that there is <code>operator""_ss</code>, which turns a string literal into a <code>simple_str_nt</code> object, which is already a string expression: </p><div class="fragment"><div class="line">str = <span class="stringliteral">&quot;Count = &quot;</span>_ss + count;</div>
<div class="line">...</div>
<div class="line">str = count + <span class="stringliteral">&quot; times.&quot;</span>_ss;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md82"></a>
Your own string expressions</h4>
<p>You can create your own string expression types to optimally form strings for your specific purposes and algorithms. To do this, simply create a type with <code>length</code>, <code>place</code> and <code>typename symb_type</code> methods. Examples of creation and use from real projects:</p>
<div class="fragment"><div class="line"><span class="comment">/* Form a string in JSON format, in 16-bit characters */</span></div>
<div class="line"><span class="keyword">struct </span>expr_json_str {</div>
<div class="line">    <span class="keyword">using </span>symb_type = u16s;</div>
<div class="line">    ssu text;</div>
<div class="line">    <span class="keywordtype">size_t</span> l;</div>
<div class="line">    <span class="keywordtype">size_t</span> length() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> l;</div>
<div class="line">    }</div>
<div class="line">    u16s* place(u16s* ptr) <span class="keyword">const</span> <span class="keyword">noexcept</span>;</div>
<div class="line">    expr_json_str(ssu t);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> expr_json_str::expr_json_str(ssu t) : text(t) {</div>
<div class="line">    <span class="keyword">const</span> u16s* ptr = text.symbols();</div>
<div class="line">    <span class="keywordtype">size_t</span> add = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; text.length(); i++) {</div>
<div class="line">        <span class="keywordflow">switch</span> (*ptr++) {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\b&#39;</span>:</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\f&#39;</span>:</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\r&#39;</span>:</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\n&#39;</span>:</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\t&#39;</span>:</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\&quot;&#39;</span>:</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\\&#39;</span>:</div>
<div class="line">            add++;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    l = text.len + add;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> u16s* expr_json_str::place(u16s* ptr) <span class="keyword">const</span> <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keyword">const</span> u16s *r = text.symbols();</div>
<div class="line">    <span class="keywordtype">size_t</span> lenOfText = text.length(), lenOfTail = l;</div>
<div class="line">    <span class="keywordflow">while</span> (lenOfTail &gt; lenOfText) {</div>
<div class="line">        u16s s = *r++;</div>
<div class="line">        <span class="keywordflow">switch</span> (s) {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\b&#39;</span>:</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;b&#39;</span>;</div>
<div class="line">            lenOfTail--;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\f&#39;</span>:</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;f&#39;</span>;</div>
<div class="line">            lenOfTail--;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\r&#39;</span>:</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;r&#39;</span>;</div>
<div class="line">            lenOfTail--;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\n&#39;</span>:</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;n&#39;</span>;</div>
<div class="line">            lenOfTail--;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\t&#39;</span>:</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;t&#39;</span>;</div>
<div class="line">            lenOfTail--;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\&quot;&#39;</span>:</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\&quot;&#39;</span>;</div>
<div class="line">            lenOfTail--;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;\\&#39;</span>:</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;\\&#39;</span>;</div>
<div class="line">            lenOfTail--;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            *ptr++ = s;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        lenOfTail--;</div>
<div class="line">        lenOfText--;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (lenOfTail) {</div>
<div class="line">        std::char_traits&lt;u16s&gt;::copy(ptr, r, lenOfTail);</div>
<div class="line">        ptr += lenOfTail;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> ptr;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Usage:</p>
<div class="fragment"><div class="line">........</div>
<div class="line">chunked_string_builder&lt;u16s&gt; vtText;</div>
<div class="line">........</div>
<div class="line">vtText &lt;&lt; uR<span class="stringliteral">&quot;({&quot;#type&quot;:&quot;jxs:string&quot;,&quot;#value&quot;:&quot;)&quot; + expr_json_str(name) + u</span><span class="stringliteral">&quot;\&quot;}&quot;</span>;</div>
<div class="line">.......</div>
</div><!-- fragment --><p>Another example </p><div class="fragment"><div class="line"><span class="comment">/* Need to form binary data in BASE64 format, in 16-bit characters */</span></div>
<div class="line"><span class="keyword">struct </span>expr_str_base64 {</div>
<div class="line">    <span class="keyword">using </span>symb_type = u16s;</div>
<div class="line">    ssa text;</div>
<div class="line">    <span class="keywordtype">size_t</span> length() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> (text.len + 2) / 3 * 4;</div>
<div class="line">    }</div>
<div class="line">    u16s* place(u16s* ptr) <span class="keyword">const</span> <span class="keyword">noexcept</span>;</div>
<div class="line">    expr_str_base64(ssa t) : text(t) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> u16s* expr_str_base64::place(u16s* ptr) <span class="keyword">const</span> <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> u8s alphabet[] = <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* t = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)text.str;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> i = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (text.len &gt; 2) {</div>
<div class="line">        <span class="keywordflow">for</span> (; i &lt; text.len - 2; i += 3) {</div>
<div class="line">            *ptr++ = alphabet[(t[i] &gt;&gt; 2) &amp; 0x3F];</div>
<div class="line">            *ptr++ = alphabet[((t[i] &amp; 0x3) &lt;&lt; 4) | ((<span class="keywordtype">int</span>)(t[i + 1] &amp; 0xF0) &gt;&gt; 4)];</div>
<div class="line">            *ptr++ = alphabet[((t[i + 1] &amp; 0xF) &lt;&lt; 2) | ((<span class="keywordtype">int</span>)(t[i + 2] &amp; 0xC0) &gt;&gt; 6)];</div>
<div class="line">            *ptr++ = alphabet[t[i + 2] &amp; 0x3F];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (i &lt; text.len) {</div>
<div class="line">        *ptr++ = alphabet[(t[i] &gt;&gt; 2) &amp; 0x3F];</div>
<div class="line">        <span class="keywordflow">if</span> (i == (text.len - 1)) {</div>
<div class="line">            *ptr++ = alphabet[((t[i] &amp; 0x3) &lt;&lt; 4)];</div>
<div class="line">            *ptr++ = <span class="charliteral">&#39;=&#39;</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            *ptr++ = alphabet[((t[i] &amp; 0x3) &lt;&lt; 4) | ((<span class="keywordtype">int</span>)(t[i + 1] &amp; 0xF0) &gt;&gt; 4)];</div>
<div class="line">            *ptr++ = alphabet[((t[i + 1] &amp; 0xF) &lt;&lt; 2)];</div>
<div class="line">        }</div>
<div class="line">        *ptr++ = <span class="charliteral">&#39;=&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> ptr;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Usage: </p><div class="fragment"><div class="line">......</div>
<div class="line">chunked_string_builder&lt;u16s&gt; vtText;</div>
<div class="line">......</div>
<div class="line">vtText &lt;&lt; u<span class="stringliteral">&quot;{\&quot;#\&quot;,87126200-3e98-44e0-b931-ccb1d7edc497,{1,{#base64:&quot;</span> + expr_str_base64(v) + u<span class="stringliteral">&quot;}}},&quot;</span>;</div>
<div class="line">......</div>
</div><!-- fragment --><p>And more</p>
<div class="fragment"><div class="line"><span class="comment">/* Need to convert tm to a date/time string in 16-bit characters */</span></div>
<div class="line"><span class="keyword">struct </span>expr_str_tm {</div>
<div class="line">    <span class="keyword">using </span>symb_type = u16s;</div>
<div class="line">    <span class="keyword">const</span> tm&amp; t;</div>
<div class="line">    <span class="keywordtype">size_t</span> length() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> 19;</div>
<div class="line">    }</div>
<div class="line">    u16s* place(u16s* ptr) <span class="keyword">const</span> <span class="keyword">noexcept</span>;</div>
<div class="line">    expr_str_tm(<span class="keyword">const</span> tm&amp; _t) : t(_t) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> u16s* expr_str_tm::place(u16s* ptr) <span class="keyword">const</span> <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<span class="keyword">sizeof</span>(wchar_t) == 2) {</div>
<div class="line">        <span class="comment">// Under Windows, you can immediately format the string into the desired buffer</span></div>
<div class="line">        std::swprintf((<span class="keywordtype">wchar_t</span>*)ptr, 20, L<span class="stringliteral">&quot;%04i-%02i-%02i %02i:%02i:%02i&quot;</span>, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,</div>
<div class="line">            t.tm_hour, t.tm_min, t.tm_sec);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// First, format into an intermediate buffer, then copy to the result</span></div>
<div class="line">        <span class="keywordtype">char</span> buf[20];</div>
<div class="line">        std::snprintf(buf, 20, <span class="stringliteral">&quot;%04i-%02i-%02i %02i:%02i:%02i&quot;</span>, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour,</div>
<div class="line">            t.tm_min, t.tm_sec);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; 19; i++) {</div>
<div class="line">            ptr[i] = buf[i];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> ptr + 19;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Usage</p>
<div class="fragment"><div class="line">......</div>
<div class="line"><span class="keywordtype">bool</span> makeBind(SqliteQuery&amp; query, tVariant&amp; param, <span class="keywordtype">unsigned</span> paramNum) {</div>
<div class="line">    <span class="keywordflow">switch</span> (param.vt) {</div>
<div class="line">......</div>
<div class="line">    <span class="keywordflow">case</span> VTYPE_DATE:</div>
<div class="line">        query.bind(paramNum, lstringu&lt;30&gt;{expr_str_tm{winDateToTm(param.date)}}.to_str());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> VTYPE_TM:</div>
<div class="line">        query.bind(paramNum, lstringu&lt;30&gt;{expr_str_tm{param.tmVal}}.to_str());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">......</div>
</div><!-- fragment --><p>ATTENTION: usually the fields in string expression objects are references to the source data. And these references almost always lead to local or temporary objects. Therefore, it is extremely risky to return string expressions from functions — you need to check a hundred times that they do not contain references to local or temporary variables. Make it a rule — you can easily pass string expressions to functions, and it is dangerous to return them from functions. It is better to materialize a string expression into a string object containing the final string when returning. If desired, the type of the returned string can be specified by a template parameter.</p>
<h3><a class="anchor" id="autotoc_md83"></a>
Class chunked_string_builder</h3>
<p>Designed for concatenating multiple strings. When you need to sequentially form a long text from many small pieces (for example, you are forming an html response etc.) - sequentially adding everything to one string object is extremely suboptimal - there will be many reallocations and copying of already accumulated characters. In this case, it is convenient to use chunked_string_builder - all it can do is add a string to the accumulated characters. However, it does this not in a single sequential memory buffer, but in separate buffers, no less than the specified alignment. When filling the next buffer, it simply creates another buffer and continues to add data to it.</p>
<p>That is, suppose you set the alignment to 1024. Added several strings, filled the buffer with 100 characters. And you add a string of 3000 characters long. In this case, 924 characters will be copied to the first buffer, filling it to the end. For the remaining 2076, a buffer of 3072 characters will be created, and they will be copied into it, leaving space for 996 characters in it. Thus, each buffer is sequentially filled to the end and has a size that is a multiple of the specified alignment. This avoids reallocations and copying of processed characters.</p>
<p>After the final filling, you can work with the accumulated data - either merge all the buffers into one sequential string (the size for the buffer of which you now already know), or iterate over them separately, for example, sending these buffers to the network. Or sequentially copying data into a buffer of a given size.   </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

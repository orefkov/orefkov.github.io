<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: Пространство имен simstr::str</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.6.0</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacesimstr_1_1str.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Функции</a>  </div>
  <div class="headertitle"><div class="title">Пространство имен simstr::str</div></div>
</div><!--header-->
<div class="contents">

<p>Небольшое пространство для методов работы со стандартными строками.  
<a href="#details">Подробнее...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Функции</h2></td></tr>
<tr class="memitem:ad452138126b5952824665736845ffedf" id="r_ad452138126b5952824665736845ffedf"><td class="memTemplParams" colspan="2">template&lt;typename K, typename A, StrExprForType&lt; K &gt; E&gt; </td></tr>
<tr class="memitem:ad452138126b5952824665736845ffedf"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad452138126b5952824665736845ffedf">change</a> (std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;str, size_t from, size_t count, const E &amp;expr)</td></tr>
<tr class="memdesc:ad452138126b5952824665736845ffedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Изменить часть стандартной строки на заданное строковое выражение.  <br /></td></tr>
<tr class="separator:ad452138126b5952824665736845ffedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351d8d1db18b0dca19992b164fb6253f" id="r_a351d8d1db18b0dca19992b164fb6253f"><td class="memTemplParams" colspan="2">template&lt;typename K, typename A, StrExprForType&lt; K &gt; E&gt; </td></tr>
<tr class="memitem:a351d8d1db18b0dca19992b164fb6253f"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a351d8d1db18b0dca19992b164fb6253f">append</a> (std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;str, const E &amp;expr)</td></tr>
<tr class="memdesc:a351d8d1db18b0dca19992b164fb6253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить к стандартной строке строковое выражение.  <br /></td></tr>
<tr class="separator:a351d8d1db18b0dca19992b164fb6253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb93ccbf4f2bc1ca6db244ef11c3047" id="r_a5fb93ccbf4f2bc1ca6db244ef11c3047"><td class="memTemplParams" colspan="2">template&lt;typename K, typename A, StrExprForType&lt; K &gt; E&gt; </td></tr>
<tr class="memitem:a5fb93ccbf4f2bc1ca6db244ef11c3047"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5fb93ccbf4f2bc1ca6db244ef11c3047">prepend</a> (std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;str, const E &amp;expr)</td></tr>
<tr class="memdesc:a5fb93ccbf4f2bc1ca6db244ef11c3047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вставить строковое выражение в начало стандартной строки.  <br /></td></tr>
<tr class="separator:a5fb93ccbf4f2bc1ca6db244ef11c3047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9af1b76a9815d827e9b46affccb49f" id="r_afb9af1b76a9815d827e9b46affccb49f"><td class="memTemplParams" colspan="2">template&lt;typename K, typename A, StrExprForType&lt; K &gt; E&gt; </td></tr>
<tr class="memitem:afb9af1b76a9815d827e9b46affccb49f"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb9af1b76a9815d827e9b46affccb49f">insert</a> (std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;str, size_t from, const E &amp;expr)</td></tr>
<tr class="memdesc:afb9af1b76a9815d827e9b46affccb49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вставить строковое выражение в указанную позицию стандартной строки.  <br /></td></tr>
<tr class="separator:afb9af1b76a9815d827e9b46affccb49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f51f3eac15eafa21d00aa3b10c81f7" id="r_ad6f51f3eac15eafa21d00aa3b10c81f7"><td class="memTemplParams" colspan="2">template&lt;typename K, typename A, StrExprForType&lt; K &gt; E, typename T&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, T&gt;)</td></tr>
<tr class="memitem:ad6f51f3eac15eafa21d00aa3b10c81f7"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6f51f3eac15eafa21d00aa3b10c81f7">replace</a> (std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;str, T &amp;&amp;pattern, const E &amp;repl, size_t offset=0, size_t max_count=-1)</td></tr>
<tr class="memdesc:ad6f51f3eac15eafa21d00aa3b10c81f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Функция поиска подстрок в стандартной строке и замены найденных вхождений на значение строкового выражения.  <br /></td></tr>
<tr class="separator:ad6f51f3eac15eafa21d00aa3b10c81f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be21b9e8525cd67515fb5a2dc78c6ba" id="r_a0be21b9e8525cd67515fb5a2dc78c6ba"><td class="memTemplParams" colspan="2">template&lt;typename K, typename A&gt; </td></tr>
<tr class="memitem:a0be21b9e8525cd67515fb5a2dc78c6ba"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0be21b9e8525cd67515fb5a2dc78c6ba">replace</a> (std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;str, <a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt; K &gt; pattern, <a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt; K &gt; repl, size_t offset=0, size_t max_count=-1)</td></tr>
<tr class="memdesc:a0be21b9e8525cd67515fb5a2dc78c6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Функция поиска подстрок в стандартной строке и замены найденных вхождений на другую подстроку.  <br /></td></tr>
<tr class="separator:a0be21b9e8525cd67515fb5a2dc78c6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><p>Небольшое пространство для методов работы со стандартными строками. </p>
</div><h2 class="groupheader">Функции</h2>
<a id="a351d8d1db18b0dca19992b164fb6253f" name="a351d8d1db18b0dca19992b164fb6253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351d8d1db18b0dca19992b164fb6253f">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename A, StrExprForType&lt; K &gt; E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp; simstr::str::append </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Добавить к стандартной строке строковое выражение. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- тип символов. </td></tr>
    <tr><td class="paramname">A</td><td>- тип аллокатора. </td></tr>
    <tr><td class="paramname">E</td><td>- тип строкового выражения. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- строка. </td></tr>
    <tr><td class="paramname">expr</td><td>- строковое выражение для вставки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K, std::char_traits&lt;K&gt;, A&gt;&amp; - ссылку на переданную строку.</dd></dl>
<p>Метод получает у строкового выражения его длину, увеличивает размер строки, и материализует строковое выражение за концом строки, без использования промежуточных буферов. До C++23 используется resize, начиная с C++23 - resize_and_overwrite.</p>
<p>ВАЖНО!!! части строкового выражения не должны ссылаться на саму строку, иначе результат неопределён!!! </p>

</div>
</div>
<a id="ad452138126b5952824665736845ffedf" name="ad452138126b5952824665736845ffedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad452138126b5952824665736845ffedf">&#9670;&#160;</a></span>change()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename A, StrExprForType&lt; K &gt; E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp; simstr::str::change </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Изменить часть стандартной строки на заданное строковое выражение. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- тип символов. </td></tr>
    <tr><td class="paramname">A</td><td>- тип аллокатора. </td></tr>
    <tr><td class="paramname">E</td><td>- тип строкового выражения. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- строка. </td></tr>
    <tr><td class="paramname">from</td><td>- начальная позиция замены. </td></tr>
    <tr><td class="paramname">count</td><td>- количество символов, подлежащих замене. </td></tr>
    <tr><td class="paramname">expr</td><td>- строковое выражение для замены. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K, std::char_traits&lt;K&gt;, A&gt;&amp; - ссылку на переданную строку.</dd></dl>
<p>Метод получает у строкового выражения его длину, при необходимости увеличивает размер строки, и материализует строковое выражение на нужное место, без использования промежуточных буферов. При увеличении размера строки - до C++23 используется resize, начиная с C++23 - resize_and_overwrite.</p>
<p>ВАЖНО!!! части строкового выражения не должны ссылаться на саму строку, иначе результат неопределён!!! </p>

</div>
</div>
<a id="afb9af1b76a9815d827e9b46affccb49f" name="afb9af1b76a9815d827e9b46affccb49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9af1b76a9815d827e9b46affccb49f">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename A, StrExprForType&lt; K &gt; E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp; simstr::str::insert </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вставить строковое выражение в указанную позицию стандартной строки. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- тип символов. </td></tr>
    <tr><td class="paramname">A</td><td>- тип аллокатора. </td></tr>
    <tr><td class="paramname">E</td><td>- тип строкового выражения. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- строка. </td></tr>
    <tr><td class="paramname">from</td><td>- позиция вставки. </td></tr>
    <tr><td class="paramname">expr</td><td>- строковое выражение для вставки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K, std::char_traits&lt;K&gt;, A&gt;&amp; - ссылку на переданную строку.</dd></dl>
<p>Метод получает у строкового выражения его длину, увеличивает размер строки, сдвигает её содержимое и материализует строковое выражение на нужное место, без использования промежуточных буферов. До C++23 используется resize, начиная с C++23 - resize_and_overwrite.</p>
<p>ВАЖНО!!! части строкового выражения не должны ссылаться на саму строку, иначе результат неопределён!!! </p>

</div>
</div>
<a id="a5fb93ccbf4f2bc1ca6db244ef11c3047" name="a5fb93ccbf4f2bc1ca6db244ef11c3047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb93ccbf4f2bc1ca6db244ef11c3047">&#9670;&#160;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename A, StrExprForType&lt; K &gt; E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp; simstr::str::prepend </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вставить строковое выражение в начало стандартной строки. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- тип символов. </td></tr>
    <tr><td class="paramname">A</td><td>- тип аллокатора. </td></tr>
    <tr><td class="paramname">E</td><td>- тип строкового выражения. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- строка. </td></tr>
    <tr><td class="paramname">expr</td><td>- строковое выражение для вставки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K, std::char_traits&lt;K&gt;, A&gt;&amp; - ссылку на переданную строку.</dd></dl>
<p>Метод получает у строкового выражения его длину, увеличивает размер строки, сдвигает её содержимое и материализует строковое выражение в её начало, без использования промежуточных буферов. До C++23 используется resize, начиная с C++23 - resize_and_overwrite.</p>
<p>ВАЖНО!!! части строкового выражения не должны ссылаться на саму строку, иначе результат неопределён!!! </p>

</div>
</div>
<a id="a0be21b9e8525cd67515fb5a2dc78c6ba" name="a0be21b9e8525cd67515fb5a2dc78c6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be21b9e8525cd67515fb5a2dc78c6ba">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp; simstr::str::replace </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Функция поиска подстрок в стандартной строке и замены найденных вхождений на другую подстроку. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- тип символов строки. </td></tr>
    <tr><td class="paramname">A</td><td>- тип аллокатора строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- строка, в которой заменяем вхождения подстрок. </td></tr>
    <tr><td class="paramname">pattern</td><td>- искомая подстрока (любой тип, конвертирующийся в <a class="el" href="structsimstr_1_1simple__str.html" title="Простейший класс иммутабельной не владеющей строки.">simple_str</a>). </td></tr>
    <tr><td class="paramname">repl</td><td>- строка для замены (любой тип, конвертирующийся в <a class="el" href="structsimstr_1_1simple__str.html" title="Простейший класс иммутабельной не владеющей строки.">simple_str</a>). </td></tr>
    <tr><td class="paramname">offset</td><td>- начальное смещение для поиска. </td></tr>
    <tr><td class="paramname">max_count</td><td>- максимальное количество замен. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K, std::char_traits&lt;K&gt;, A&gt;&amp; - ссылку на модифицируемую строку. </dd></dl>

</div>
</div>
<a id="ad6f51f3eac15eafa21d00aa3b10c81f7" name="ad6f51f3eac15eafa21d00aa3b10c81f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f51f3eac15eafa21d00aa3b10c81f7">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename A, StrExprForType&lt; K &gt; E, typename T&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, T&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp; simstr::str::replace </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; K, std::char_traits&lt; K &gt;, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Функция поиска подстрок в стандартной строке и замены найденных вхождений на значение строкового выражения. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- тип символов строки. </td></tr>
    <tr><td class="paramname">A</td><td>- тип аллокатора строки. </td></tr>
    <tr><td class="paramname">E</td><td>- тип строкового выражения. </td></tr>
    <tr><td class="paramname">T</td><td>- тип подстроки поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- строка, в которой заменяем вхождения подстрок. </td></tr>
    <tr><td class="paramname">pattern</td><td>- искомая подстрока (любой тип, конвертирующийся в <a class="el" href="structsimstr_1_1simple__str.html" title="Простейший класс иммутабельной не владеющей строки.">simple_str</a>). </td></tr>
    <tr><td class="paramname">repl</td><td>- строковое выражение для замены. </td></tr>
    <tr><td class="paramname">offset</td><td>- начальное смещение для поиска. </td></tr>
    <tr><td class="paramname">max_count</td><td>- максимальное количество замен. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K, std::char_traits&lt;K&gt;, A&gt;&amp; - ссылку на модифицируемую строку.</dd></dl>
<p>Части строкового выражения не должны ссылаться на саму модифицируемую строку. Если искомая подстрока не найдена, то строковое выражение даже не вычисляется. Затем при осуществлении замены строковое выражение вычисляется только один раз в место первой замены, а в следующие места замен просто копируется символы из первого места. Это позволяет экономить память и время, если вам надо сделать замену на какую-либо "сборную" строку. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimstr.html">simstr</a></li><li class="navelem"><a class="el" href="namespacesimstr_1_1str.html">str</a></li>
    <li class="footer">Создано системой <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

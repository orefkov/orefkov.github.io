<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: simstr::str_algs&lt; K, StrRef, Impl, Mutable &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.3.1</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsimstr_1_1str__algs.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsimstr_1_1str__algs-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simstr::str_algs&lt; K, StrRef, Impl, Mutable &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class with basic constant string algorithms.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sstring_8h_source.html">sstring.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for simstr::str_algs&lt; K, StrRef, Impl, Mutable &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsimstr_1_1str__algs.png" usemap="#simstr::str_5Falgs_3C_20K_2C_20StrRef_2C_20Impl_2C_20Mutable_20_3E_map" alt=""/>
  <map id="simstr::str_5Falgs_3C_20K_2C_20StrRef_2C_20Impl_2C_20Mutable_20_3E_map" name="simstr::str_5Falgs_3C_20K_2C_20StrRef_2C_20Impl_2C_20Mutable_20_3E_map">
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; K, N, forShared, Allocator &gt;" shape="rect" coords="270,56,530,80"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u8s, N &gt;" shape="rect" coords="270,112,530,136"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; wchar_t, N &gt;" shape="rect" coords="270,168,530,192"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u16s, N &gt;" shape="rect" coords="270,224,530,248"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u32s, N &gt;" shape="rect" coords="270,280,530,304"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u8s, N, true &gt;" shape="rect" coords="270,336,530,360"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; wchar_t, N, true &gt;" shape="rect" coords="270,392,530,416"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u16s, N, true &gt;" shape="rect" coords="270,448,530,472"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u32s, N, true &gt;" shape="rect" coords="270,504,530,528"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; u8s &gt;" shape="rect" coords="270,560,530,584"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; wchar_t &gt;" shape="rect" coords="270,616,530,640"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; u16s &gt;" shape="rect" coords="270,672,530,696"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; u32s &gt;" shape="rect" coords="270,728,530,752"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; K, Allocator &gt;" shape="rect" coords="270,784,530,808"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; u8s &gt;" shape="rect" coords="270,840,530,864"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; wchar_t &gt;" shape="rect" coords="270,896,530,920"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; u16s &gt;" shape="rect" coords="270,952,530,976"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; u32s &gt;" shape="rect" coords="270,1008,530,1032"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9efa353bc382a6e476b1180f0cbd64be" id="r_a9efa353bc382a6e476b1180f0cbd64be"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9efa353bc382a6e476b1180f0cbd64be">place</a> (K *ptr) const noexcept</td></tr>
<tr class="memdesc:a9efa353bc382a6e476b1180f0cbd64be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string to the specified buffer.  <br /></td></tr>
<tr class="separator:a9efa353bc382a6e476b1180f0cbd64be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa371442f5d71650b6759407a74ba7f6c" id="r_aa371442f5d71650b6759407a74ba7f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa371442f5d71650b6759407a74ba7f6c">copy_to</a> (K *buffer, size_t bufSize)</td></tr>
<tr class="memdesc:aa371442f5d71650b6759407a74ba7f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string to the specified buffer.  <br /></td></tr>
<tr class="separator:aa371442f5d71650b6759407a74ba7f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032bb26b7a123fc2a391597e0b1478c8" id="r_a032bb26b7a123fc2a391597e0b1478c8"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a032bb26b7a123fc2a391597e0b1478c8">size</a> () const</td></tr>
<tr class="memdesc:a032bb26b7a123fc2a391597e0b1478c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the string in characters.  <br /></td></tr>
<tr class="separator:a032bb26b7a123fc2a391597e0b1478c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb514b2a1711b54c063b6b77adfb524" id="r_a9cb514b2a1711b54c063b6b77adfb524"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb514b2a1711b54c063b6b77adfb524">operator str_piece</a> () const noexcept</td></tr>
<tr class="memdesc:a9cb514b2a1711b54c063b6b77adfb524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert itself to a "string chunk" that includes the entire string.  <br /></td></tr>
<tr class="separator:a9cb514b2a1711b54c063b6b77adfb524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d10266d4f76dfa7e1f79e603e947b1" id="r_a19d10266d4f76dfa7e1f79e603e947b1"><td class="memItemLeft" align="right" valign="top">constexpr str_piece&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d10266d4f76dfa7e1f79e603e947b1">to_str</a> () const noexcept</td></tr>
<tr class="memdesc:a19d10266d4f76dfa7e1f79e603e947b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert itself to a "string chunk" that includes the entire string.  <br /></td></tr>
<tr class="separator:a19d10266d4f76dfa7e1f79e603e947b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4e13ca8dd62c156b460b40be5722d8" id="r_a1c4e13ca8dd62c156b460b40be5722d8"><td class="memTemplParams" colspan="2">template&lt;typename = int&gt; <br />
requires is_one_of_std_char_v&lt;K&gt;</td></tr>
<tr class="memitem:a1c4e13ca8dd62c156b460b40be5722d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::basic_string_view&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c4e13ca8dd62c156b460b40be5722d8">to_sv</a> () const noexcept</td></tr>
<tr class="memdesc:a1c4e13ca8dd62c156b460b40be5722d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::string_view.  <br /></td></tr>
<tr class="separator:a1c4e13ca8dd62c156b460b40be5722d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14461bfb4a7760db97bf50bb834c197" id="r_af14461bfb4a7760db97bf50bb834c197"><td class="memTemplParams" colspan="2">template&lt;typename = int&gt; <br />
requires is_one_of_std_char_v&lt;K&gt;</td></tr>
<tr class="memitem:af14461bfb4a7760db97bf50bb834c197"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::basic_string&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af14461bfb4a7760db97bf50bb834c197">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af14461bfb4a7760db97bf50bb834c197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::string.  <br /></td></tr>
<tr class="separator:af14461bfb4a7760db97bf50bb834c197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bb2523d89124db15ab675dd7b661dd" id="r_a85bb2523d89124db15ab675dd7b661dd"><td class="memItemLeft" align="right" valign="top">constexpr str_piece&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85bb2523d89124db15ab675dd7b661dd">operator()</a> (ptrdiff_t from, ptrdiff_t len=0) const noexcept</td></tr>
<tr class="memdesc:a85bb2523d89124db15ab675dd7b661dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string as "simple_str".  <br /></td></tr>
<tr class="separator:a85bb2523d89124db15ab675dd7b661dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3cdef6c7633c7da8dac91187cc545e" id="r_a2d3cdef6c7633c7da8dac91187cc545e"><td class="memItemLeft" align="right" valign="top">constexpr str_piece&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d3cdef6c7633c7da8dac91187cc545e">mid</a> (size_t from, size_t len=-1) const noexcept</td></tr>
<tr class="memdesc:a2d3cdef6c7633c7da8dac91187cc545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string as "string chunk".  <br /></td></tr>
<tr class="separator:a2d3cdef6c7633c7da8dac91187cc545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56043b721d327307a88b3be41d36bc5" id="r_af56043b721d327307a88b3be41d36bc5"><td class="memItemLeft" align="right" valign="top">constexpr str_piece&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af56043b721d327307a88b3be41d36bc5">from_to</a> (size_t from, size_t to) const noexcept</td></tr>
<tr class="memdesc:af56043b721d327307a88b3be41d36bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substring <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a> from position from to position to (not including it).  <br /></td></tr>
<tr class="separator:af56043b721d327307a88b3be41d36bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cc821a25864d4e5550973e104efe98" id="r_a03cc821a25864d4e5550973e104efe98"><td class="memItemLeft" align="right" valign="top"><a id="a03cc821a25864d4e5550973e104efe98" name="a03cc821a25864d4e5550973e104efe98"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!</b> () const noexcept</td></tr>
<tr class="memdesc:a03cc821a25864d4e5550973e104efe98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for emptiness. <br /></td></tr>
<tr class="separator:a03cc821a25864d4e5550973e104efe98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28acaa475e182b6df9010bd99dfd9c1" id="r_ae28acaa475e182b6df9010bd99dfd9c1"><td class="memItemLeft" align="right" valign="top">constexpr K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae28acaa475e182b6df9010bd99dfd9c1">at</a> (ptrdiff_t idx) const</td></tr>
<tr class="memdesc:ae28acaa475e182b6df9010bd99dfd9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at the given position.  <br /></td></tr>
<tr class="separator:ae28acaa475e182b6df9010bd99dfd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac72f56788a268face1e9315ac514390" id="r_aac72f56788a268face1e9315ac514390"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac72f56788a268face1e9315ac514390">compare</a> (str_piece o) const</td></tr>
<tr class="memdesc:aac72f56788a268face1e9315ac514390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character.  <br /></td></tr>
<tr class="separator:aac72f56788a268face1e9315ac514390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cbab476dcc336ea5f2bceee89b14ca" id="r_ab4cbab476dcc336ea5f2bceee89b14ca"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4cbab476dcc336ea5f2bceee89b14ca">strcmp</a> (const K *text) const</td></tr>
<tr class="memdesc:ab4cbab476dcc336ea5f2bceee89b14ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare with C-string character by character.  <br /></td></tr>
<tr class="separator:ab4cbab476dcc336ea5f2bceee89b14ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8402c183e1c28ed0f06aa2fe28bedc" id="r_aef8402c183e1c28ed0f06aa2fe28bedc"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef8402c183e1c28ed0f06aa2fe28bedc">equal</a> (str_piece other) const noexcept</td></tr>
<tr class="memdesc:aef8402c183e1c28ed0f06aa2fe28bedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">String comparison for equality.  <br /></td></tr>
<tr class="separator:aef8402c183e1c28ed0f06aa2fe28bedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae891863b2c4ed81e603838890173496d" id="r_ae891863b2c4ed81e603838890173496d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae891863b2c4ed81e603838890173496d">operator==</a> (const <a class="el" href="classsimstr_1_1str__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ae891863b2c4ed81e603838890173496d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator comparing strings for equality.  <br /></td></tr>
<tr class="separator:ae891863b2c4ed81e603838890173496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882ecc460b3d9e6b6786121796b89372" id="r_a882ecc460b3d9e6b6786121796b89372"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a882ecc460b3d9e6b6786121796b89372">operator&lt;=&gt;</a> (const <a class="el" href="classsimstr_1_1str__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a882ecc460b3d9e6b6786121796b89372"><td class="mdescLeft">&#160;</td><td class="mdescRight">String comparison operator.  <br /></td></tr>
<tr class="separator:a882ecc460b3d9e6b6786121796b89372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8ea7c375d988ab82099d10d0779118" id="r_a3d8ea7c375d988ab82099d10d0779118"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:a3d8ea7c375d988ab82099d10d0779118"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d8ea7c375d988ab82099d10d0779118">operator==</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:a3d8ea7c375d988ab82099d10d0779118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for comparing a string and a string literal for equality.  <br /></td></tr>
<tr class="separator:a3d8ea7c375d988ab82099d10d0779118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac967d356ab7df7db6245866aa34d5232" id="r_ac967d356ab7df7db6245866aa34d5232"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:ac967d356ab7df7db6245866aa34d5232"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac967d356ab7df7db6245866aa34d5232">operator&lt;=&gt;</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ac967d356ab7df7db6245866aa34d5232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator between a string and a string literal.  <br /></td></tr>
<tr class="separator:ac967d356ab7df7db6245866aa34d5232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d481d6eb2d043ac8ce5d0d5e7ec86" id="r_ae89d481d6eb2d043ac8ce5d0d5e7ec86"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89d481d6eb2d043ac8ce5d0d5e7ec86">compare_ia</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:ae89d481d6eb2d043ac8ce5d0d5e7ec86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character and not case sensitive ASCII characters.  <br /></td></tr>
<tr class="separator:ae89d481d6eb2d043ac8ce5d0d5e7ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd1a4d1a8b9c8e5aaa199f8914fe474" id="r_a2cd1a4d1a8b9c8e5aaa199f8914fe474"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd1a4d1a8b9c8e5aaa199f8914fe474">equal_ia</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:a2cd1a4d1a8b9c8e5aaa199f8914fe474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is equal to another string, character-by-character-insensitive, of ASCII characters.  <br /></td></tr>
<tr class="separator:a2cd1a4d1a8b9c8e5aaa199f8914fe474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d3a1a76af2a3153cc4b329e486dac6" id="r_af1d3a1a76af2a3153cc4b329e486dac6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1d3a1a76af2a3153cc4b329e486dac6">less_ia</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:af1d3a1a76af2a3153cc4b329e486dac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is smaller than another string, character-by-character-insensitive, ASCII characters.  <br /></td></tr>
<tr class="separator:af1d3a1a76af2a3153cc4b329e486dac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400250ea87cc59daa152dc9ddb57491f" id="r_a400250ea87cc59daa152dc9ddb57491f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400250ea87cc59daa152dc9ddb57491f">compare_iu</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:a400250ea87cc59daa152dc9ddb57491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character without taking into account the case of Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a400250ea87cc59daa152dc9ddb57491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf0990c46a280cd363da46bef12e02f" id="r_adbf0990c46a280cd363da46bef12e02f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbf0990c46a280cd363da46bef12e02f">equal_iu</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:adbf0990c46a280cd363da46bef12e02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is equal to another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:adbf0990c46a280cd363da46bef12e02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79e99462478b57d62873f7942ff2b6" id="r_a4e79e99462478b57d62873f7942ff2b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e79e99462478b57d62873f7942ff2b6">less_iu</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:a4e79e99462478b57d62873f7942ff2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is smaller than another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a4e79e99462478b57d62873f7942ff2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8390e23702a40a3f550fce9c04d1e8d1" id="r_a8390e23702a40a3f550fce9c04d1e8d1"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8390e23702a40a3f550fce9c04d1e8d1">find</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a8390e23702a40a3f550fce9c04d1e8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a8390e23702a40a3f550fce9c04d1e8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33894b131f47fba7559eda085111409c" id="r_a33894b131f47fba7559eda085111409c"><td class="memTemplParams" colspan="2">template&lt;typename Exc, typename ... Args&gt; <br />
requires std::is_constructible_v&lt;Exc, Args...&gt;</td></tr>
<tr class="memitem:a33894b131f47fba7559eda085111409c"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33894b131f47fba7559eda085111409c">find_or_throw</a> (str_piece pattern, size_t offset=0, Args &amp;&amp;... args) const noexcept</td></tr>
<tr class="memdesc:a33894b131f47fba7559eda085111409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string or throw an exception.  <br /></td></tr>
<tr class="separator:a33894b131f47fba7559eda085111409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ccd354949c2af5ed75676b36791527" id="r_ad6ccd354949c2af5ed75676b36791527"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6ccd354949c2af5ed75676b36791527">find_end</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ad6ccd354949c2af5ed75676b36791527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:ad6ccd354949c2af5ed75676b36791527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d58b99ec86c7c0f469349c12ad07de" id="r_a58d58b99ec86c7c0f469349c12ad07de"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d58b99ec86c7c0f469349c12ad07de">find_or_all</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a58d58b99ec86c7c0f469349c12ad07de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string or the end of the string.  <br /></td></tr>
<tr class="separator:a58d58b99ec86c7c0f469349c12ad07de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a9f3ade055eb5db285d726f388f64" id="r_ae90a9f3ade055eb5db285d726f388f64"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae90a9f3ade055eb5db285d726f388f64">find_end_or_all</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ae90a9f3ade055eb5db285d726f388f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the first occurrence of a substring in this string, or the end of a string.  <br /></td></tr>
<tr class="separator:ae90a9f3ade055eb5db285d726f388f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee58c2b8fd6e049423cb859dd7ad164" id="r_a8ee58c2b8fd6e049423cb859dd7ad164"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ee58c2b8fd6e049423cb859dd7ad164">find_last</a> (str_piece pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a8ee58c2b8fd6e049423cb859dd7ad164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the last occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a8ee58c2b8fd6e049423cb859dd7ad164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c54be3da183bf0f7f04071c484ceff7" id="r_a3c54be3da183bf0f7f04071c484ceff7"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c54be3da183bf0f7f04071c484ceff7">find_end_of_last</a> (str_piece pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a3c54be3da183bf0f7f04071c484ceff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the last occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a3c54be3da183bf0f7f04071c484ceff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3683cb297886257bd6259c2e0f77bd21" id="r_a3683cb297886257bd6259c2e0f77bd21"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3683cb297886257bd6259c2e0f77bd21">find_last_or_all</a> (str_piece pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a3683cb297886257bd6259c2e0f77bd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the last occurrence of a substring in this string or the end of the string.  <br /></td></tr>
<tr class="separator:a3683cb297886257bd6259c2e0f77bd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef25980678fac58bdf7112e3354eb68" id="r_a5ef25980678fac58bdf7112e3354eb68"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ef25980678fac58bdf7112e3354eb68">find_end_of_last_or_all</a> (str_piece pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a5ef25980678fac58bdf7112e3354eb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the last occurrence of a substring in this string, or the end of a string.  <br /></td></tr>
<tr class="separator:a5ef25980678fac58bdf7112e3354eb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e02eb727a2351300d4349d6637fe262" id="r_a6e02eb727a2351300d4349d6637fe262"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e02eb727a2351300d4349d6637fe262">contains</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a6e02eb727a2351300d4349d6637fe262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string contains the specified substring.  <br /></td></tr>
<tr class="separator:a6e02eb727a2351300d4349d6637fe262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4000d2493f15cd529bc78ae2d1c581c7" id="r_a4000d2493f15cd529bc78ae2d1c581c7"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4000d2493f15cd529bc78ae2d1c581c7">find</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a4000d2493f15cd529bc78ae2d1c581c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a character in this string.  <br /></td></tr>
<tr class="separator:a4000d2493f15cd529bc78ae2d1c581c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76489dd5307a12260f1766f514016fe6" id="r_a76489dd5307a12260f1766f514016fe6"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76489dd5307a12260f1766f514016fe6">find_or_all</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a76489dd5307a12260f1766f514016fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a character in this string or the end of a string.  <br /></td></tr>
<tr class="separator:a76489dd5307a12260f1766f514016fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab344db1789674fe5c9dbd31fcfbbe254" id="r_ab344db1789674fe5c9dbd31fcfbbe254"><td class="memTemplParams" colspan="2">template&lt;typename Op&gt; </td></tr>
<tr class="memitem:ab344db1789674fe5c9dbd31fcfbbe254"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab344db1789674fe5c9dbd31fcfbbe254">for_all_finded</a> (const Op &amp;op, str_piece pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:ab344db1789674fe5c9dbd31fcfbbe254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor on all found occurrences of a substring in this string.  <br /></td></tr>
<tr class="separator:ab344db1789674fe5c9dbd31fcfbbe254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713475a34317581d09f86728d8ddb44c" id="r_a713475a34317581d09f86728d8ddb44c"><td class="memItemLeft" align="right" valign="top">constexpr std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a713475a34317581d09f86728d8ddb44c">find_all</a> (str_piece pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a713475a34317581d09f86728d8ddb44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all occurrences of a substring in this string.  <br /></td></tr>
<tr class="separator:a713475a34317581d09f86728d8ddb44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f7e754f87cfa55e8ec0bcb4f44efc1" id="r_ae7f7e754f87cfa55e8ec0bcb4f44efc1"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7f7e754f87cfa55e8ec0bcb4f44efc1">find_last</a> (K s, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:ae7f7e754f87cfa55e8ec0bcb4f44efc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character in this string.  <br /></td></tr>
<tr class="separator:ae7f7e754f87cfa55e8ec0bcb4f44efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0216228858201c6bd0c0375dcb3d575" id="r_ac0216228858201c6bd0c0375dcb3d575"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0216228858201c6bd0c0375dcb3d575">find_first_of</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac0216228858201c6bd0c0375dcb3d575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:ac0216228858201c6bd0c0375dcb3d575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bb2222b4e7c3830bacd27357b5733e" id="r_a97bb2222b4e7c3830bacd27357b5733e"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97bb2222b4e7c3830bacd27357b5733e">find_first_of_idx</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a97bb2222b4e7c3830bacd27357b5733e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:a97bb2222b4e7c3830bacd27357b5733e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff07b785db7f341898a931ecffee7056" id="r_aff07b785db7f341898a931ecffee7056"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff07b785db7f341898a931ecffee7056">find_first_not_of</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:aff07b785db7f341898a931ecffee7056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character not from the given character set.  <br /></td></tr>
<tr class="separator:aff07b785db7f341898a931ecffee7056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad775d1f04c93d2ba8a1a32775fd8e3ff" id="r_ad775d1f04c93d2ba8a1a32775fd8e3ff"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad775d1f04c93d2ba8a1a32775fd8e3ff">find_last_of</a> (str_piece pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:ad775d1f04c93d2ba8a1a32775fd8e3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:ad775d1f04c93d2ba8a1a32775fd8e3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12d2001ab5e2aed830cc78a1f718536" id="r_af12d2001ab5e2aed830cc78a1f718536"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af12d2001ab5e2aed830cc78a1f718536">find_last_of_idx</a> (str_piece pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:af12d2001ab5e2aed830cc78a1f718536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:af12d2001ab5e2aed830cc78a1f718536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc411c9a47381f1b565f9931e7ee6d07" id="r_adc411c9a47381f1b565f9931e7ee6d07"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc411c9a47381f1b565f9931e7ee6d07">find_last_not_of</a> (str_piece pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:adc411c9a47381f1b565f9931e7ee6d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character not from the given character set.  <br /></td></tr>
<tr class="separator:adc411c9a47381f1b565f9931e7ee6d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d443fd3ca34c3e6ebd728e2f511acb" id="r_ab8d443fd3ca34c3e6ebd728e2f511acb"><td class="memItemLeft" align="right" valign="top">constexpr my_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8d443fd3ca34c3e6ebd728e2f511acb">substr</a> (ptrdiff_t from, ptrdiff_t len=0) const</td></tr>
<tr class="memdesc:ab8d443fd3ca34c3e6ebd728e2f511acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a substring. Works similarly to operator(), only the result is the same type as the method applied to.  <br /></td></tr>
<tr class="separator:ab8d443fd3ca34c3e6ebd728e2f511acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62256e9942d3337c50a9458374ac52f3" id="r_a62256e9942d3337c50a9458374ac52f3"><td class="memItemLeft" align="right" valign="top">constexpr my_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62256e9942d3337c50a9458374ac52f3">str_mid</a> (size_t from, size_t len=-1) const</td></tr>
<tr class="memdesc:a62256e9942d3337c50a9458374ac52f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string with an object of the same type to which the method is applied, similar to mid.  <br /></td></tr>
<tr class="separator:a62256e9942d3337c50a9458374ac52f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5321022f75db5f7c791c145e7fe0f1" id="r_a3b5321022f75db5f7c791c145e7fe0f1"><td class="memTemplParams" colspan="2">template&lt;ToIntNumber T, bool CheckOverflow = true, unsigned Base = 0, bool SkipWs = true, bool AllowSign = true&gt; </td></tr>
<tr class="memitem:a3b5321022f75db5f7c791c145e7fe0f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b5321022f75db5f7c791c145e7fe0f1">as_int</a> () const noexcept</td></tr>
<tr class="memdesc:a3b5321022f75db5f7c791c145e7fe0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number of the given type.  <br /></td></tr>
<tr class="separator:a3b5321022f75db5f7c791c145e7fe0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356a572ad74e9d512c0d36d1e6699d96" id="r_a356a572ad74e9d512c0d36d1e6699d96"><td class="memTemplParams" colspan="2">template&lt;ToIntNumber T, bool CheckOverflow = true, unsigned Base = 0, bool SkipWs = true, bool AllowSign = true&gt; </td></tr>
<tr class="memitem:a356a572ad74e9d512c0d36d1e6699d96"><td class="memTemplItemLeft" align="right" valign="top">constexpr convert_result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a356a572ad74e9d512c0d36d1e6699d96">to_int</a> () const noexcept</td></tr>
<tr class="memdesc:a356a572ad74e9d512c0d36d1e6699d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number of the given type.  <br /></td></tr>
<tr class="separator:a356a572ad74e9d512c0d36d1e6699d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af52e61e73c687a34ff6978304edc3" id="r_aa1af52e61e73c687a34ff6978304edc3"><td class="memTemplParams" colspan="2">template&lt;bool SkipWS = true, bool AllowPlus = true&gt; </td></tr>
<tr class="memitem:aa1af52e61e73c687a34ff6978304edc3"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1af52e61e73c687a34ff6978304edc3">to_double</a> () const noexcept</td></tr>
<tr class="memdesc:aa1af52e61e73c687a34ff6978304edc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <br /></td></tr>
<tr class="separator:aa1af52e61e73c687a34ff6978304edc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683d9d722cc772870832128793e8a624" id="r_a683d9d722cc772870832128793e8a624"><td class="memTemplParams" colspan="2">template&lt;bool SkipWS = true&gt; <br />
requires (sizeof(K) == 1)</td></tr>
<tr class="memitem:a683d9d722cc772870832128793e8a624"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a683d9d722cc772870832128793e8a624">to_double_hex</a> () const noexcept</td></tr>
<tr class="memdesc:a683d9d722cc772870832128793e8a624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string in hex form to double.  <br /></td></tr>
<tr class="separator:a683d9d722cc772870832128793e8a624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17421202713ebd4d62ddf175023f535" id="r_ac17421202713ebd4d62ddf175023f535"><td class="memTemplParams" colspan="2">template&lt;ToIntNumber T&gt; </td></tr>
<tr class="memitem:ac17421202713ebd4d62ddf175023f535"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac17421202713ebd4d62ddf175023f535">as_number</a> (T &amp;t) const</td></tr>
<tr class="memdesc:ac17421202713ebd4d62ddf175023f535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an integer.  <br /></td></tr>
<tr class="separator:ac17421202713ebd4d62ddf175023f535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860598fca0df848662d7d8578a8f6da" id="r_af860598fca0df848662d7d8578a8f6da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af860598fca0df848662d7d8578a8f6da">as_number</a> (double &amp;t) const</td></tr>
<tr class="memdesc:af860598fca0df848662d7d8578a8f6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <br /></td></tr>
<tr class="separator:af860598fca0df848662d7d8578a8f6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0476580fd6fa230fd46d0fe5a1f33e" id="r_aed0476580fd6fa230fd46d0fe5a1f33e"><td class="memTemplParams" colspan="2">template&lt;typename T, typename Op&gt; </td></tr>
<tr class="memitem:aed0476580fd6fa230fd46d0fe5a1f33e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed0476580fd6fa230fd46d0fe5a1f33e">splitf</a> (str_piece delimeter, const Op &amp;beforeFunc, size_t offset=0) const</td></tr>
<tr class="memdesc:aed0476580fd6fa230fd46d0fe5a1f33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into parts at a given delimiter, possibly applying a functor to each substring.  <br /></td></tr>
<tr class="separator:aed0476580fd6fa230fd46d0fe5a1f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346fe7eb58168d714387f2c3065f78d0" id="r_a346fe7eb58168d714387f2c3065f78d0"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a346fe7eb58168d714387f2c3065f78d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a346fe7eb58168d714387f2c3065f78d0">split</a> (str_piece delimeter, size_t offset=0) const</td></tr>
<tr class="memdesc:a346fe7eb58168d714387f2c3065f78d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into substrings using a given delimiter.  <br /></td></tr>
<tr class="separator:a346fe7eb58168d714387f2c3065f78d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25dce601de84e9e5f0c78de89a71cf9" id="r_ac25dce601de84e9e5f0c78de89a71cf9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1_splitter.html">Splitter</a>&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac25dce601de84e9e5f0c78de89a71cf9">splitter</a> (str_piece delimeter) const</td></tr>
<tr class="memdesc:ac25dce601de84e9e5f0c78de89a71cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <code><a class="el" href="classsimstr_1_1_splitter.html" title="Class for sequentially obtaining substrings by a given delimiter.">Splitter</a></code> object by the given splitter, which allows sequential get substrings using the <code>next()</code> method while <code>is_done()</code> is false.  <br /></td></tr>
<tr class="separator:ac25dce601de84e9e5f0c78de89a71cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0749cac4a635847a7a57e244281fcd97" id="r_a0749cac4a635847a7a57e244281fcd97"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0749cac4a635847a7a57e244281fcd97">starts_with</a> (str_piece prefix) const noexcept</td></tr>
<tr class="memdesc:a0749cac4a635847a7a57e244281fcd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string begins with the given substring.  <br /></td></tr>
<tr class="separator:a0749cac4a635847a7a57e244281fcd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affea5af6d58202e885267ae12615e3fb" id="r_affea5af6d58202e885267ae12615e3fb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affea5af6d58202e885267ae12615e3fb">starts_with_ia</a> (str_piece prefix) const noexcept</td></tr>
<tr class="memdesc:affea5af6d58202e885267ae12615e3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string begins with the given substring in a case-insensitive ASCII character.  <br /></td></tr>
<tr class="separator:affea5af6d58202e885267ae12615e3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26465c7fdac87e8d215e836bdbf6e8c3" id="r_a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26465c7fdac87e8d215e836bdbf6e8c3">starts_with_iu</a> (str_piece prefix) const noexcept</td></tr>
<tr class="memdesc:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string starts with the given substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9b707b45b955a9d525f5f699b82341" id="r_a3d9b707b45b955a9d525f5f699b82341"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d9b707b45b955a9d525f5f699b82341">prefix_in</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:a3d9b707b45b955a9d525f5f699b82341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this string is the beginning of another string.  <br /></td></tr>
<tr class="separator:a3d9b707b45b955a9d525f5f699b82341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748fd0f63cd688dbfbbb12ddb4ad0042" id="r_a748fd0f63cd688dbfbbb12ddb4ad0042"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a748fd0f63cd688dbfbbb12ddb4ad0042">ends_with</a> (str_piece suffix) const noexcept</td></tr>
<tr class="memdesc:a748fd0f63cd688dbfbbb12ddb4ad0042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring.  <br /></td></tr>
<tr class="separator:a748fd0f63cd688dbfbbb12ddb4ad0042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ac7184386cd4e60e65c799cf5df83" id="r_adc8ac7184386cd4e60e65c799cf5df83"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc8ac7184386cd4e60e65c799cf5df83">ends_with_ia</a> (str_piece suffix) const noexcept</td></tr>
<tr class="memdesc:adc8ac7184386cd4e60e65c799cf5df83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring in a case-insensitive ASCII character.  <br /></td></tr>
<tr class="separator:adc8ac7184386cd4e60e65c799cf5df83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535d655a6702861b788830a1d266e48f" id="r_a535d655a6702861b788830a1d266e48f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a535d655a6702861b788830a1d266e48f">ends_with_iu</a> (str_piece suffix) const noexcept</td></tr>
<tr class="memdesc:a535d655a6702861b788830a1d266e48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a535d655a6702861b788830a1d266e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b79211345b6f993a30fecff2eba10df" id="r_a4b79211345b6f993a30fecff2eba10df"><td class="memItemLeft" align="right" valign="top"><a id="a4b79211345b6f993a30fecff2eba10df" name="a4b79211345b6f993a30fecff2eba10df"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ascii</b> () const noexcept</td></tr>
<tr class="memdesc:a4b79211345b6f993a30fecff2eba10df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string contains only ASCII characters. <br /></td></tr>
<tr class="separator:a4b79211345b6f993a30fecff2eba10df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dffe997b57c8543ac242fff94b346a" id="r_a30dffe997b57c8543ac242fff94b346a"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a30dffe997b57c8543ac242fff94b346a"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a30dffe997b57c8543ac242fff94b346a">upperred_only_ascii</a> () const</td></tr>
<tr class="memdesc:a30dffe997b57c8543ac242fff94b346a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in uppercase ASCII characters.  <br /></td></tr>
<tr class="separator:a30dffe997b57c8543ac242fff94b346a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dd9a33977e5ef7878079085214a783" id="r_a08dd9a33977e5ef7878079085214a783"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a08dd9a33977e5ef7878079085214a783"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08dd9a33977e5ef7878079085214a783">lowered_only_ascii</a> () const</td></tr>
<tr class="memdesc:a08dd9a33977e5ef7878079085214a783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in lowercase ASCII characters.  <br /></td></tr>
<tr class="separator:a08dd9a33977e5ef7878079085214a783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3ef69a372dab777c952f22c492689" id="r_a6ae3ef69a372dab777c952f22c492689"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a6ae3ef69a372dab777c952f22c492689"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ae3ef69a372dab777c952f22c492689">upperred</a> () const</td></tr>
<tr class="memdesc:a6ae3ef69a372dab777c952f22c492689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in upper case Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a6ae3ef69a372dab777c952f22c492689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51ac2887746e40214eeee7d52460f4" id="r_a8d51ac2887746e40214eeee7d52460f4"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a8d51ac2887746e40214eeee7d52460f4"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d51ac2887746e40214eeee7d52460f4">lowered</a> () const</td></tr>
<tr class="memdesc:a8d51ac2887746e40214eeee7d52460f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in lowercase Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a8d51ac2887746e40214eeee7d52460f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29130d837f80814b37c7baa57a22392b" id="r_a29130d837f80814b37c7baa57a22392b"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a29130d837f80814b37c7baa57a22392b"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29130d837f80814b37c7baa57a22392b">replaced</a> (str_piece pattern, str_piece repl, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a29130d837f80814b37c7baa57a22392b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string with occurrences of substrings replaced.  <br /></td></tr>
<tr class="separator:a29130d837f80814b37c7baa57a22392b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af142fe005925c6d4503e98ff23e126f8" id="r_af142fe005925c6d4503e98ff23e126f8"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename M, size_t L = const_lit_for&lt;K, M&gt;::Count&gt; </td></tr>
<tr class="memitem:af142fe005925c6d4503e98ff23e126f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_replaces&lt; K, N - 1, L - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af142fe005925c6d4503e98ff23e126f8">replace_init</a> (T &amp;&amp;pattern, M &amp;&amp;repl) const</td></tr>
<tr class="memdesc:af142fe005925c6d4503e98ff23e126f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that produces a string with replaced substrings given by string literals.  <br /></td></tr>
<tr class="separator:af142fe005925c6d4503e98ff23e126f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0ee1f7d2e81f09bbf60becebb3cd32" id="r_a7a0ee1f7d2e81f09bbf60becebb3cd32"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a7a0ee1f7d2e81f09bbf60becebb3cd32"><td class="memTemplItemLeft" align="right" valign="top">constexpr R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a0ee1f7d2e81f09bbf60becebb3cd32">trimmed</a> () const</td></tr>
<tr class="memdesc:a7a0ee1f7d2e81f09bbf60becebb3cd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the left and right.  <br /></td></tr>
<tr class="separator:a7a0ee1f7d2e81f09bbf60becebb3cd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5087dc2570361c3733b981749ee0af3" id="r_aa5087dc2570361c3733b981749ee0af3"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:aa5087dc2570361c3733b981749ee0af3"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5087dc2570361c3733b981749ee0af3">trimmed_left</a> () const</td></tr>
<tr class="memdesc:aa5087dc2570361c3733b981749ee0af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the left.  <br /></td></tr>
<tr class="separator:aa5087dc2570361c3733b981749ee0af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfe9d42e11ad3d5d6402de39ff67194" id="r_a6bfe9d42e11ad3d5d6402de39ff67194"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a6bfe9d42e11ad3d5d6402de39ff67194"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6bfe9d42e11ad3d5d6402de39ff67194">trimmed_right</a> () const</td></tr>
<tr class="memdesc:a6bfe9d42e11ad3d5d6402de39ff67194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the right.  <br /></td></tr>
<tr class="separator:a6bfe9d42e11ad3d5d6402de39ff67194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef209fc5249c973fd6853c37bd6c52d0" id="r_aef209fc5249c973fd6853c37bd6c52d0"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:aef209fc5249c973fd6853c37bd6c52d0"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef209fc5249c973fd6853c37bd6c52d0">trimmed</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:aef209fc5249c973fd6853c37bd6c52d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the left and right.  <br /></td></tr>
<tr class="separator:aef209fc5249c973fd6853c37bd6c52d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b26a03e3f0f06f58695c2bf83085263" id="r_a1b26a03e3f0f06f58695c2bf83085263"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:a1b26a03e3f0f06f58695c2bf83085263"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b26a03e3f0f06f58695c2bf83085263">trimmed_left</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a1b26a03e3f0f06f58695c2bf83085263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the left.  <br /></td></tr>
<tr class="separator:a1b26a03e3f0f06f58695c2bf83085263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e110b24fc0c97c21e59b466e5aa344f" id="r_a8e110b24fc0c97c21e59b466e5aa344f"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:a8e110b24fc0c97c21e59b466e5aa344f"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e110b24fc0c97c21e59b466e5aa344f">trimmed_right</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a8e110b24fc0c97c21e59b466e5aa344f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the right.  <br /></td></tr>
<tr class="separator:a8e110b24fc0c97c21e59b466e5aa344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678aa93ea710405b57c42abd110481a5" id="r_a678aa93ea710405b57c42abd110481a5"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:a678aa93ea710405b57c42abd110481a5"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a678aa93ea710405b57c42abd110481a5">trimmed_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a678aa93ea710405b57c42abd110481a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, left and right.  <br /></td></tr>
<tr class="separator:a678aa93ea710405b57c42abd110481a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f8d05593c163518bdee7d036a271d3" id="r_ab7f8d05593c163518bdee7d036a271d3"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:ab7f8d05593c163518bdee7d036a271d3"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7f8d05593c163518bdee7d036a271d3">trimmed_left_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab7f8d05593c163518bdee7d036a271d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, left.  <br /></td></tr>
<tr class="separator:ab7f8d05593c163518bdee7d036a271d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bafb34363268b0e826652945bcf4c0" id="r_a72bafb34363268b0e826652945bcf4c0"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:a72bafb34363268b0e826652945bcf4c0"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72bafb34363268b0e826652945bcf4c0">trimmed_right_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a72bafb34363268b0e826652945bcf4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, right.  <br /></td></tr>
<tr class="separator:a72bafb34363268b0e826652945bcf4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c44f690d2f35cd001e2b4a6f8ddd8b" id="r_a50c44f690d2f35cd001e2b4a6f8ddd8b"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a50c44f690d2f35cd001e2b4a6f8ddd8b"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a50c44f690d2f35cd001e2b4a6f8ddd8b">trimmed</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:a50c44f690d2f35cd001e2b4a6f8ddd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed, left and right.  <br /></td></tr>
<tr class="separator:a50c44f690d2f35cd001e2b4a6f8ddd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527f7faf2b1c3cb1176f64bc21b64930" id="r_a527f7faf2b1c3cb1176f64bc21b64930"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a527f7faf2b1c3cb1176f64bc21b64930"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a527f7faf2b1c3cb1176f64bc21b64930">trimmed_left</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:a527f7faf2b1c3cb1176f64bc21b64930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed from the left.  <br /></td></tr>
<tr class="separator:a527f7faf2b1c3cb1176f64bc21b64930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50252bba2dc037ddb4d64c74049f4a3" id="r_aa50252bba2dc037ddb4d64c74049f4a3"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:aa50252bba2dc037ddb4d64c74049f4a3"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa50252bba2dc037ddb4d64c74049f4a3">trimmed_right</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:aa50252bba2dc037ddb4d64c74049f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed to the right.  <br /></td></tr>
<tr class="separator:aa50252bba2dc037ddb4d64c74049f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76189081415ac6d1a94f2612796963f3" id="r_a76189081415ac6d1a94f2612796963f3"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a76189081415ac6d1a94f2612796963f3"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76189081415ac6d1a94f2612796963f3">trimmed_with_spaces</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:a76189081415ac6d1a94f2612796963f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, left and right.  <br /></td></tr>
<tr class="separator:a76189081415ac6d1a94f2612796963f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2840ba24d010e214d6e30a13ce59215" id="r_aa2840ba24d010e214d6e30a13ce59215"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:aa2840ba24d010e214d6e30a13ce59215"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2840ba24d010e214d6e30a13ce59215">trimmed_left_with_spaces</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:aa2840ba24d010e214d6e30a13ce59215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, left.  <br /></td></tr>
<tr class="separator:aa2840ba24d010e214d6e30a13ce59215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dd40ceb456ffbe03e2317617afcaf9" id="r_a39dd40ceb456ffbe03e2317617afcaf9"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a39dd40ceb456ffbe03e2317617afcaf9"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39dd40ceb456ffbe03e2317617afcaf9">trimmed_right_with_spaces</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:a39dd40ceb456ffbe03e2317617afcaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, right.  <br /></td></tr>
<tr class="separator:a39dd40ceb456ffbe03e2317617afcaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt;<br />
class simstr::str_algs&lt; K, StrRef, Impl, Mutable &gt;</div><p>A class with basic constant string algorithms. </p>
<p>Is the base for classes that can perform constant operations on strings. Doesnt know anything about storing strings, neither itself nor the descendant class, that is, it works only with a pointer to a string and its length. To work, the descendant class must implement the following methods:</p><ul>
<li>size_t length() const noexcept - returns the length of the string.</li>
<li>const K* symbols() const noexcept - returns a pointer to the beginning of the line.</li>
<li>bool is_empty() const noexcept - checks whether the string is empty. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- character type. </td></tr>
    <tr><td class="paramname">StrRef</td><td>- storage type for the string chunk. </td></tr>
    <tr><td class="paramname">Impl</td><td>- the final class is the successor. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b5321022f75db5f7c791c145e7fe0f1" name="a3b5321022f75db5f7c791c145e7fe0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5321022f75db5f7c791c145e7fe0f1">&#9670;&#160;</a></span>as_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;ToIntNumber T, bool CheckOverflow = true, unsigned Base = 0, bool SkipWs = true, bool AllowSign = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::as_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a number of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- the desired number type. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- check for overflow. </td></tr>
    <tr><td class="paramname">Base</td><td>- the base of the number, from -1 to 36, except 1.<ul>
<li>If 0: then tries to determine the base by the prefix 0[xX] as 16, 0 as 8, otherwise 10.</li>
<li>If -1: then tries to determine the base by prefixes:<ul>
<li>0 or 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
</ul>
</li>
<li>in other cases 10. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- skip whitespace characters at the beginning of the line. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- whether the '+' sign is allowed before a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - a number, the result of the transformation, how much it turned out, or 0 if it overflows. </dd></dl>

</div>
</div>
<a id="af860598fca0df848662d7d8578a8f6da" name="af860598fca0df848662d7d8578a8f6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af860598fca0df848662d7d8578a8f6da">&#9670;&#160;</a></span>as_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- the variable into which the result is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17421202713ebd4d62ddf175023f535" name="ac17421202713ebd4d62ddf175023f535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17421202713ebd4d62ddf175023f535">&#9670;&#160;</a></span>as_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;ToIntNumber T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to an integer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- number type, inferred from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- the variable into which the result is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae28acaa475e182b6df9010bd99dfd9c1" name="ae28acaa475e182b6df9010bd99dfd9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28acaa475e182b6df9010bd99dfd9c1">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::at </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the character at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- symbol index. For negative values, it is counted from the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>K - character.</dd></dl>
<p>Does not check for line boundaries. </p>

</div>
</div>
<a id="aac72f56788a268face1e9315ac514390" name="aac72f56788a268face1e9315ac514390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac72f56788a268face1e9315ac514390">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="ae89d481d6eb2d043ac8ce5d0d5e7ec86" name="ae89d481d6eb2d043ac8ce5d0d5e7ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89d481d6eb2d043ac8ce5d0d5e7ec86">&#9670;&#160;</a></span>compare_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::compare_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character and not case sensitive ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a400250ea87cc59daa152dc9ddb57491f" name="a400250ea87cc59daa152dc9ddb57491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400250ea87cc59daa152dc9ddb57491f">&#9670;&#160;</a></span>compare_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::compare_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character without taking into account the case of Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a6e02eb727a2351300d4349d6637fe262" name="a6e02eb727a2351300d4349d6637fe262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e02eb727a2351300d4349d6637fe262">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string contains the specified substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a id="aa371442f5d71650b6759407a74ba7f6c" name="aa371442f5d71650b6759407a74ba7f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa371442f5d71650b6759407a74ba7f6c">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string to the specified buffer. </p>
<p>The method adds <code>\0</code> after the copied characters. Does not exceed buffer boundaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to buffer </td></tr>
    <tr><td class="paramname">bufSize</td><td>- buffer size in characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a748fd0f63cd688dbfbbb12ddb4ad0042" name="a748fd0f63cd688dbfbbb12ddb4ad0042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748fd0f63cd688dbfbbb12ddb4ad0042">&#9670;&#160;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc8ac7184386cd4e60e65c799cf5df83" name="adc8ac7184386cd4e60e65c799cf5df83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8ac7184386cd4e60e65c799cf5df83">&#9670;&#160;</a></span>ends_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::ends_with_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring in a case-insensitive ASCII character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a535d655a6702861b788830a1d266e48f" name="a535d655a6702861b788830a1d266e48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535d655a6702861b788830a1d266e48f">&#9670;&#160;</a></span>ends_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::ends_with_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef8402c183e1c28ed0f06aa2fe28bedc" name="aef8402c183e1c28ed0f06aa2fe28bedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8402c183e1c28ed0f06aa2fe28bedc">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::equal </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String comparison for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a2cd1a4d1a8b9c8e5aaa199f8914fe474" name="a2cd1a4d1a8b9c8e5aaa199f8914fe474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd1a4d1a8b9c8e5aaa199f8914fe474">&#9670;&#160;</a></span>equal_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::equal_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is equal to another string, character-by-character-insensitive, of ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="adbf0990c46a280cd363da46bef12e02f" name="adbf0990c46a280cd363da46bef12e02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf0990c46a280cd363da46bef12e02f">&#9670;&#160;</a></span>equal_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::equal_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is equal to another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a4000d2493f15cd529bc78ae2d1c581c7" name="a4000d2493f15cd529bc78ae2d1c581c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4000d2493f15cd529bc78ae2d1c581c7">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a8390e23702a40a3f550fce9c04d1e8d1" name="a8390e23702a40a3f550fce9c04d1e8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8390e23702a40a3f550fce9c04d1e8d1">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a713475a34317581d09f86728d8ddb44c" name="a713475a34317581d09f86728d8ddb44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713475a34317581d09f86728d8ddb44c">&#9670;&#160;</a></span>find_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all occurrences of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- the maximum number of occurrences to be processed, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;size_t&gt; - a vector with the positions of the beginnings of the found occurrences. </dd></dl>

</div>
</div>
<a id="ad6ccd354949c2af5ed75676b36791527" name="ad6ccd354949c2af5ed75676b36791527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ccd354949c2af5ed75676b36791527">&#9670;&#160;</a></span>find_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_end </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a3c54be3da183bf0f7f04071c484ceff7" name="a3c54be3da183bf0f7f04071c484ceff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c54be3da183bf0f7f04071c484ceff7">&#9670;&#160;</a></span>find_end_of_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_end_of_last </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the last occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the last occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a5ef25980678fac58bdf7112e3354eb68" name="a5ef25980678fac58bdf7112e3354eb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef25980678fac58bdf7112e3354eb68">&#9670;&#160;</a></span>find_end_of_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_end_of_last_or_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the last occurrence of a substring in this string, or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the last occurrence of the substring, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="ae90a9f3ade055eb5db285d726f388f64" name="ae90a9f3ade055eb5db285d726f388f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90a9f3ade055eb5db285d726f388f64">&#9670;&#160;</a></span>find_end_or_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_end_or_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the first occurrence of a substring in this string, or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the occurrence of the substring, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="aff07b785db7f341898a931ecffee7056" name="aff07b785db7f341898a931ecffee7056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff07b785db7f341898a931ecffee7056">&#9670;&#160;</a></span>find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character not from the given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the character set. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ac0216228858201c6bd0c0375dcb3d575" name="ac0216228858201c6bd0c0375dcb3d575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0216228858201c6bd0c0375dcb3d575">&#9670;&#160;</a></span>find_first_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a97bb2222b4e7c3830bacd27357b5733e" name="a97bb2222b4e7c3830bacd27357b5733e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bb2222b4e7c3830bacd27357b5733e">&#9670;&#160;</a></span>find_first_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_first_of_idx </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t, size_t&gt; - a pair from the position of the found occurrence and the number of the found character in the set, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ae7f7e754f87cfa55e8ec0bcb4f44efc1" name="ae7f7e754f87cfa55e8ec0bcb4f44efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f7e754f87cfa55e8ec0bcb4f44efc1">&#9670;&#160;</a></span>find_last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a8ee58c2b8fd6e049423cb859dd7ad164" name="a8ee58c2b8fd6e049423cb859dd7ad164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee58c2b8fd6e049423cb859dd7ad164">&#9670;&#160;</a></span>find_last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the last occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="adc411c9a47381f1b565f9931e7ee6d07" name="adc411c9a47381f1b565f9931e7ee6d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc411c9a47381f1b565f9931e7ee6d07">&#9670;&#160;</a></span>find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character not from the given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the character set. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ad775d1f04c93d2ba8a1a32775fd8e3ff" name="ad775d1f04c93d2ba8a1a32775fd8e3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad775d1f04c93d2ba8a1a32775fd8e3ff">&#9670;&#160;</a></span>find_last_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="af12d2001ab5e2aed830cc78a1f718536" name="af12d2001ab5e2aed830cc78a1f718536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12d2001ab5e2aed830cc78a1f718536">&#9670;&#160;</a></span>find_last_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last_of_idx </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t, size_t&gt; - a pair from the position of the found occurrence and the number of the found character in the set, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a3683cb297886257bd6259c2e0f77bd21" name="a3683cb297886257bd6259c2e0f77bd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3683cb297886257bd6259c2e0f77bd21">&#9670;&#160;</a></span>find_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last_or_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the last occurrence of a substring in this string or the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position at which the substring begins, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a76489dd5307a12260f1766f514016fe6" name="a76489dd5307a12260f1766f514016fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76489dd5307a12260f1766f514016fe6">&#9670;&#160;</a></span>find_or_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a character in this string or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or string length if not found. </dd></dl>

</div>
</div>
<a id="a58d58b99ec86c7c0f469349c12ad07de" name="a58d58b99ec86c7c0f469349c12ad07de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d58b99ec86c7c0f469349c12ad07de">&#9670;&#160;</a></span>find_or_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string or the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position at which the substring begins, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a33894b131f47fba7559eda085111409c" name="a33894b131f47fba7559eda085111409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33894b131f47fba7559eda085111409c">&#9670;&#160;</a></span>find_or_throw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename Exc, typename ... Args&gt; <br />
requires std::is_constructible_v&lt;Exc, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_or_throw </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string or throw an exception. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exc</td><td>- exception type. </td></tr>
    <tr><td class="paramname">Args...</td><td>- types of parameters for constructing an exception, inferred from the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
    <tr><td class="paramname">args</td><td>- arguments for the exception constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the substring occurrence, or throws an Exc exception if not found. </dd></dl>

</div>
</div>
<a id="ab344db1789674fe5c9dbd31fcfbbe254" name="ab344db1789674fe5c9dbd31fcfbbe254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab344db1789674fe5c9dbd31fcfbbe254">&#9670;&#160;</a></span>for_all_finded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename Op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::for_all_finded </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor on all found occurrences of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is a functor that takes a string. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- the maximum number of occurrences to be processed, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af56043b721d327307a88b3be41d36bc5" name="af56043b721d327307a88b3be41d36bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56043b721d327307a88b3be41d36bc5">&#9670;&#160;</a></span>from_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str_piece <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::from_to </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the substring <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a> from position from to position to (not including it). </p>
<p>For performance reasons, the method does not check for line boundaries in any way, use in scenarios when you know for sure that these are positions inside the line and to &gt;= from. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position. </td></tr>
    <tr><td class="paramname">to</td><td>- final position (not included in the result). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </dd></dl>

</div>
</div>
<a id="af1d3a1a76af2a3153cc4b329e486dac6" name="af1d3a1a76af2a3153cc4b329e486dac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d3a1a76af2a3153cc4b329e486dac6">&#9670;&#160;</a></span>less_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::less_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is smaller than another string, character-by-character-insensitive, ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the string is smaller. </dd></dl>

</div>
</div>
<a id="a4e79e99462478b57d62873f7942ff2b6" name="a4e79e99462478b57d62873f7942ff2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79e99462478b57d62873f7942ff2b6">&#9670;&#160;</a></span>less_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::less_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is smaller than another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the string is smaller. </dd></dl>

</div>
</div>
<a id="a8d51ac2887746e40214eeee7d52460f4" name="a8d51ac2887746e40214eeee7d52460f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d51ac2887746e40214eeee7d52460f4">&#9670;&#160;</a></span>lowered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::lowered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in lowercase Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - lowercase copy of the string. </dd></dl>

</div>
</div>
<a id="a08dd9a33977e5ef7878079085214a783" name="a08dd9a33977e5ef7878079085214a783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dd9a33977e5ef7878079085214a783">&#9670;&#160;</a></span>lowered_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::lowered_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in lowercase ASCII characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - lowercase copy of the string. </dd></dl>

</div>
</div>
<a id="a2d3cdef6c7633c7da8dac91187cc545e" name="a2d3cdef6c7633c7da8dac91187cc545e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3cdef6c7633c7da8dac91187cc545e">&#9670;&#160;</a></span>mid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str_piece <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string as "string chunk". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If the string size is exceeded, it will return an empty string. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". When going beyond the line, it will return everything up to the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </dd></dl>

</div>
</div>
<a id="a9cb514b2a1711b54c063b6b77adfb524" name="a9cb514b2a1711b54c063b6b77adfb524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb514b2a1711b54c063b6b77adfb524">&#9670;&#160;</a></span>operator str_piece()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator str_piece </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert itself to a "string chunk" that includes the entire string. </p>
<dl class="section return"><dt>Returns</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="a85bb2523d89124db15ab675dd7b661dd" name="a85bb2523d89124db15ab675dd7b661dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bb2523d89124db15ab675dd7b661dd">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str_piece <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string as "simple_str". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>.</dd></dl>
<p>If <code>from</code> is less than zero, then <code>-from</code> characters are counted from the end of the line towards the beginning. If <code>len</code> is less than or equal to zero, then count <code>-len</code> characters from the end of the line</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, 2) == <span class="stringliteral">&quot;56&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5) == <span class="stringliteral">&quot;56789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, -1) == <span class="stringliteral">&quot;5678&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3) == <span class="stringliteral">&quot;789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3, 2) == <span class="stringliteral">&quot;78&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-4, -1) == <span class="stringliteral">&quot;678&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a882ecc460b3d9e6b6786121796b89372" name="a882ecc460b3d9e6b6786121796b89372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882ecc460b3d9e6b6786121796b89372">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac967d356ab7df7db6245866aa34d5232" name="ac967d356ab7df7db6245866aa34d5232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac967d356ab7df7db6245866aa34d5232">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator between a string and a string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is a string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae891863b2c4ed81e603838890173496d" name="ae891863b2c4ed81e603838890173496d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae891863b2c4ed81e603838890173496d">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator comparing strings for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a3d8ea7c375d988ab82099d10d0779118" name="a3d8ea7c375d988ab82099d10d0779118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8ea7c375d988ab82099d10d0779118">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for comparing a string and a string literal for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9efa353bc382a6e476b1180f0cbd64be" name="a9efa353bc382a6e476b1180f0cbd64be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa353bc382a6e476b1180f0cbd64be">&#9670;&#160;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::place </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string to the specified buffer. </p>
<p>The method assumes that the size of the allocated buffer is sufficient for the entire line, i.e. <code>length()</code> was previously requested. Does not add <code>\0</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the character after the end of the symbols placed in the buffer. </dd></dl>

</div>
</div>
<a id="a3d9b707b45b955a9d525f5f699b82341" name="a3d9b707b45b955a9d525f5f699b82341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9b707b45b955a9d525f5f699b82341">&#9670;&#160;</a></span>prefix_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::prefix_in </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this string is the beginning of another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af142fe005925c6d4503e98ff23e126f8" name="af142fe005925c6d4503e98ff23e126f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142fe005925c6d4503e98ff23e126f8">&#9670;&#160;</a></span>replace_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename M, size_t L = const_lit_for&lt;K, M&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_replaces&lt; K, N - 1, L - 1 &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::replace_init </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>repl</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string expression that produces a string with replaced substrings given by string literals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- string literal, substring to be changed. </td></tr>
    <tr><td class="paramname">repl</td><td>- string literal, substring to change to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression that replaces substrings. </dd></dl>

</div>
</div>
<a id="a29130d837f80814b37c7baa57a22392b" name="a29130d837f80814b37c7baa57a22392b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29130d837f80814b37c7baa57a22392b">&#9670;&#160;</a></span>replaced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::replaced </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string with occurrences of substrings replaced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to replace with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position of the search. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R a string of the given type, by default the same whose method was called. </dd></dl>

</div>
</div>
<a id="a032bb26b7a123fc2a391597e0b1478c8" name="a032bb26b7a123fc2a391597e0b1478c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032bb26b7a123fc2a391597e0b1478c8">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the string in characters. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="a346fe7eb58168d714387f2c3065f78d0" name="a346fe7eb58168d714387f2c3065f78d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346fe7eb58168d714387f2c3065f78d0">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::split </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>delimeter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into substrings using a given delimiter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- container type for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeter</td><td>- delimiter. </td></tr>
    <tr><td class="paramname">offset</td><td>- the position to start searching for the separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - container with the result. </dd></dl>

</div>
</div>
<a id="aed0476580fd6fa230fd46d0fe5a1f33e" name="aed0476580fd6fa230fd46d0fe5a1f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0476580fd6fa230fd46d0fe5a1f33e">&#9670;&#160;</a></span>splitf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename Op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::splitf </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>delimeter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>beforeFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into parts at a given delimiter, possibly applying a functor to each substring. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of container for folding substrings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeter</td><td>- substring delimiter. </td></tr>
    <tr><td class="paramname">beforeFunc</td><td>- a functor to apply to the found substrings, before placing them in the result. </td></tr>
    <tr><td class="paramname">offset</td><td>- the position to start searching for the separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - result.</dd></dl>
<p>For each substring found, if the functor can accept it, the functor is called, and the substring is assigned to the result of the functor. Next, the substring tries to be added to the result, calling one of its methods - <code>emplace_back</code>, <code>push_back</code>, <code>operator[]</code>. If none of this method no, nothing is done, just calling the functor. <code>operator[]</code> tries to apply if the result can have a size via <code>std::size</code> and we do not exceed this size. At the same time, if the found substring turns out to match the entire string, the result is attempted place not a substring, but the entire string object, which allows, for example, to effectively copy sstring. </p>

</div>
</div>
<a id="ac25dce601de84e9e5f0c78de89a71cf9" name="ac25dce601de84e9e5f0c78de89a71cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25dce601de84e9e5f0c78de89a71cf9">&#9670;&#160;</a></span>splitter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1_splitter.html">Splitter</a>&lt; K &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::splitter </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>delimeter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <code><a class="el" href="classsimstr_1_1_splitter.html" title="Class for sequentially obtaining substrings by a given delimiter.">Splitter</a></code> object by the given splitter, which allows sequential get substrings using the <code>next()</code> method while <code>is_done()</code> is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeter</td><td>- delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsimstr_1_1_splitter.html" title="Class for sequentially obtaining substrings by a given delimiter.">Splitter&lt;K&gt;</a>. </dd></dl>

</div>
</div>
<a id="a0749cac4a635847a7a57e244281fcd97" name="a0749cac4a635847a7a57e244281fcd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0749cac4a635847a7a57e244281fcd97">&#9670;&#160;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string begins with the given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affea5af6d58202e885267ae12615e3fb" name="affea5af6d58202e885267ae12615e3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affea5af6d58202e885267ae12615e3fb">&#9670;&#160;</a></span>starts_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::starts_with_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string begins with the given substring in a case-insensitive ASCII character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26465c7fdac87e8d215e836bdbf6e8c3" name="a26465c7fdac87e8d215e836bdbf6e8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26465c7fdac87e8d215e836bdbf6e8c3">&#9670;&#160;</a></span>starts_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::starts_with_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string starts with the given substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62256e9942d3337c50a9458374ac52f3" name="a62256e9942d3337c50a9458374ac52f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62256e9942d3337c50a9458374ac52f3">&#9670;&#160;</a></span>str_mid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_type <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::str_mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string with an object of the same type to which the method is applied, similar to mid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If the string size is exceeded, it will return an empty string. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". When going beyond the line, it will return everything up to the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the same type to which the method is applied. </dd></dl>

</div>
</div>
<a id="ab4cbab476dcc336ea5f2bceee89b14ca" name="ab4cbab476dcc336ea5f2bceee89b14ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cbab476dcc336ea5f2bceee89b14ca">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::strcmp </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare with C-string character by character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="ab8d443fd3ca34c3e6ebd728e2f511acb" name="ab8d443fd3ca34c3e6ebd728e2f511acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d443fd3ca34c3e6ebd728e2f511acb">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_type <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a substring. Works similarly to operator(), only the result is the same type as the method applied to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If less than zero, it is counted from the end of the line towards the beginning. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". If less than or equal to zero, then count len characters from the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type - a substring, an object of the same type to which the method is applied. </dd></dl>

</div>
</div>
<a id="aa1af52e61e73c687a34ff6978304edc3" name="aa1af52e61e73c687a34ff6978304edc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af52e61e73c687a34ff6978304edc3">&#9670;&#160;</a></span>to_double()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;bool SkipWS = true, bool AllowPlus = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_double </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="a683d9d722cc772870832128793e8a624" name="a683d9d722cc772870832128793e8a624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683d9d722cc772870832128793e8a624">&#9670;&#160;</a></span>to_double_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;bool SkipWS = true&gt; <br />
requires (sizeof(K) == 1)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_double_hex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string in hex form to double. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="a356a572ad74e9d512c0d36d1e6699d96" name="a356a572ad74e9d512c0d36d1e6699d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a572ad74e9d512c0d36d1e6699d96">&#9670;&#160;</a></span>to_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;ToIntNumber T, bool CheckOverflow = true, unsigned Base = 0, bool SkipWs = true, bool AllowSign = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">convert_result&lt; T &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a number of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- the desired number type. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- check for overflow. </td></tr>
    <tr><td class="paramname">Base</td><td>- the base of the number, from -1 to 36, except 1.<ul>
<li>If 0: then tries to determine the base by the prefix 0[xX] as 16, 0 as 8, otherwise 10</li>
<li>If -1: then tries to determine the base by prefixes:<ul>
<li>0 or 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
</ul>
</li>
<li>in other cases 10. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- skip whitespace characters at the beginning of the line. All characters with ASCII codes &lt;= 32 are skipped. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- whether the '+' sign is allowed before a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>convert_result&lt;T&gt; - a tuple of the received number, the success of the conversion and the number of characters processed. </dd></dl>

</div>
</div>
<a id="a19d10266d4f76dfa7e1f79e603e947b1" name="a19d10266d4f76dfa7e1f79e603e947b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d10266d4f76dfa7e1f79e603e947b1">&#9670;&#160;</a></span>to_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str_piece <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert itself to a "string chunk" that includes the entire string. </p>
<dl class="section return"><dt>Returns</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="af14461bfb4a7760db97bf50bb834c197" name="af14461bfb4a7760db97bf50bb834c197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14461bfb4a7760db97bf50bb834c197">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename = int&gt; <br />
requires is_one_of_std_char_v&lt;K&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; K &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::string. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a1c4e13ca8dd62c156b460b40be5722d8" name="a1c4e13ca8dd62c156b460b40be5722d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4e13ca8dd62c156b460b40be5722d8">&#9670;&#160;</a></span>to_sv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename = int&gt; <br />
requires is_one_of_std_char_v&lt;K&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string_view&lt; K &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_sv </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::string_view. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a7a0ee1f7d2e81f09bbf60becebb3cd32" name="a7a0ee1f7d2e81f09bbf60becebb3cd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0ee1f7d2e81f09bbf60becebb3cd32">&#9670;&#160;</a></span>trimmed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with whitespace characters removed at the beginning and end. </dd></dl>

</div>
</div>
<a id="a50c44f690d2f35cd001e2b4a6f8ddd8b" name="a50c44f690d2f35cd001e2b4a6f8ddd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c44f690d2f35cd001e2b4a6f8ddd8b">&#9670;&#160;</a></span>trimmed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and at the end. </dd></dl>

</div>
</div>
<a id="aef209fc5249c973fd6853c37bd6c52d0" name="aef209fc5249c973fd6853c37bd6c52d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef209fc5249c973fd6853c37bd6c52d0">&#9670;&#160;</a></span>trimmed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and at the end. </dd></dl>

</div>
</div>
<a id="aa5087dc2570361c3733b981749ee0af3" name="aa5087dc2570361c3733b981749ee0af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5087dc2570361c3733b981749ee0af3">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with leading whitespace characters removed. </dd></dl>

</div>
</div>
<a id="a527f7faf2b1c3cb1176f64bc21b64930" name="a527f7faf2b1c3cb1176f64bc21b64930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527f7faf2b1c3cb1176f64bc21b64930">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed from the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning. </dd></dl>

</div>
</div>
<a id="a1b26a03e3f0f06f58695c2bf83085263" name="a1b26a03e3f0f06f58695c2bf83085263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b26a03e3f0f06f58695c2bf83085263">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning. </dd></dl>

</div>
</div>
<a id="aa2840ba24d010e214d6e30a13ce59215" name="aa2840ba24d010e214d6e30a13ce59215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2840ba24d010e214d6e30a13ce59215">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and whitespace characters. </dd></dl>

</div>
</div>
<a id="ab7f8d05593c163518bdee7d036a271d3" name="ab7f8d05593c163518bdee7d036a271d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f8d05593c163518bdee7d036a271d3">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and whitespace characters. </dd></dl>

</div>
</div>
<a id="a6bfe9d42e11ad3d5d6402de39ff67194" name="a6bfe9d42e11ad3d5d6402de39ff67194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfe9d42e11ad3d5d6402de39ff67194">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with whitespace characters removed at the end. </dd></dl>

</div>
</div>
<a id="aa50252bba2dc037ddb4d64c74049f4a3" name="aa50252bba2dc037ddb4d64c74049f4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50252bba2dc037ddb4d64c74049f4a3">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed to the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the pattern removed at the end. </dd></dl>

</div>
</div>
<a id="a8e110b24fc0c97c21e59b466e5aa344f" name="a8e110b24fc0c97c21e59b466e5aa344f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e110b24fc0c97c21e59b466e5aa344f">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the literal removed at the end. </dd></dl>

</div>
</div>
<a id="a39dd40ceb456ffbe03e2317617afcaf9" name="a39dd40ceb456ffbe03e2317617afcaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dd40ceb456ffbe03e2317617afcaf9">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the template removed at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a72bafb34363268b0e826652945bcf4c0" name="a72bafb34363268b0e826652945bcf4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bafb34363268b0e826652945bcf4c0">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the literal removed at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a76189081415ac6d1a94f2612796963f3" name="a76189081415ac6d1a94f2612796963f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76189081415ac6d1a94f2612796963f3">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a678aa93ea710405b57c42abd110481a5" name="a678aa93ea710405b57c42abd110481a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678aa93ea710405b57c42abd110481a5">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a6ae3ef69a372dab777c952f22c492689" name="a6ae3ef69a372dab777c952f22c492689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3ef69a372dab777c952f22c492689">&#9670;&#160;</a></span>upperred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::upperred </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in upper case Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - uppercase copy of the string. </dd></dl>

</div>
</div>
<a id="a30dffe997b57c8543ac242fff94b346a" name="a30dffe997b57c8543ac242fff94b346a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dffe997b57c8543ac242fff94b346a">&#9670;&#160;</a></span>upperred_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::upperred_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in uppercase ASCII characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - uppercase copy of the string. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="sstring_8h_source.html">sstring.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimstr.html">simstr</a></li><li class="navelem"><a class="el" href="classsimstr_1_1str__algs.html">str_algs</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

<html>
<head>
    <meta charset="UTF-8" />
    <link href="results.css" rel="stylesheet" />
    <title>SimStr benchmarks results</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let bench_sets = {};
        let activeBuilder = buildTestsByPlatformsBar;
        let buildAsLine = {
            "Copy not literal Str with N symbols": "Length of the copied string",
            "Replace All Str To Longer Size": "Length of the string to be replaced",
            "Replace All Str To Same Size": "Length of the string to be replaced"
        };
        function hl() {
            document.querySelectorAll('.tooltiptext.code').forEach((el) => {
                hljs.highlightElement(el);
            });
        }
        function addBarChart(id, data) {
            let canvas = document.getElementById('chart' + id);
            new Chart(canvas, {
                type: 'bar',
                data: data,
                options: {
                    scales: {
                        y: {
                            beginAtZero: true
                        },
                        x: {
                            title: {
                                text: "Time (ns)",
                                display: true
                            }
                        }
                    },
                    indexAxis: 'y',
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                font: {
                                    family: "'Cascadia Code', Consolas, 'Courier New', Courier, monospace"
                                }
                            }
                        }
                    }
                }
            });
        }
        function platformChecked(idx) {
            return document.getElementById('pl' + idx).checked;
        }
        function buildPlatformsByTestsBar(bsName) {
            if (buildAsLine[bsName]) {
                buildPlatformsByTestsLine(bsName, buildAsLine[bsName]);
                return;
            }
            let data = { labels: [], datasets: [] };
            for (const i in platform_names) {
                if (platformChecked(i))
                    data.datasets.push({ label: platform_names[i], data: [], borderWidth: 1 });
            }
            let bs = bench_sets[bsName];
            for (const test of bs.tests) {
                data.labels.push(test.name);
                let ds = 0;
                for (const i in test.data) {
                    if (platformChecked(i)) {
                        data.datasets[ds++].data.push(test.data[i]);
                    }
                }
            }
            addBarChart(bs.id, data);
        }
        function buildTestsByPlatformsBar(bsName) {
            if (buildAsLine[bsName], buildAsLine[bsName]) {
                buildTestsByPlatformsLine(bsName, buildAsLine[bsName]);
                return;
            }
            let data = { labels: [], datasets: [] };
            let bs = bench_sets[bsName];
            for (const test of bs.tests) {
                data.datasets.push({ label: test.name, data: [], borderWidth: 1 });
            }
            for (const i in platform_names) {
                if (platformChecked(i)) {
                    data.labels.push(platform_names[i]);
                    for (const j in bs.tests) {
                        data.datasets[j].data.push(bs.tests[j].data[i]);
                    }
                }
            }
            addBarChart(bs.id, data);
        }
        function buildCanvas(plCount) {
            document.querySelectorAll("canvas.bench_chart").forEach(e => e.remove());
            for (var bs_name in bench_sets) {
                let bs = bench_sets[bs_name];
                if (plCount) {
                    let canvas = document.createElement('canvas');
                    canvas.id = "chart" + bs.id;
                    canvas.classList.add('bench_chart');
                    let h = 20 * plCount * bs.tests.length;
                    canvas.style.width = "100%";
                    canvas.style.height = h + "px";
                    canvas.height = h * devicePixelRatio;
                    document.getElementById(bs.id).after(canvas);
                }
            }
        }
        function addLineChart(canvas, data, title, scaleTitle) {
            new Chart(canvas, {
                type: 'line',
                data: data,
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                text: scaleTitle,
                                display: true
                            }
                        },
                        x: {
                            title: {
                                text: "Time (ns)",
                                display: true
                            }
                        }
                    },
                    indexAxis: 'y',
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                        },
                        legend: {
                            position: 'right',
                            labels: {
                                font: {
                                    family: "'Cascadia Code', Consolas, 'Courier New', Courier, monospace"
                                }
                            }
                        }
                    }
                }
            });
        }
        function buildTestsByPlatformsLineOne(bs, canvas, plIdx, scaleTitle) {
            let data = { datasets: [] };
            let prevTest = '';
            let curData = undefined;
            for (const test of bs.tests) {
                let m = test.name.match(/(.+)[\/\|](\d+)$/);
                if (m[1] != prevTest) {
                    prevTest = m[1];
                    curData = { label: prevTest, data: [], borderWidth: 1 };
                    data.datasets.push(curData);
                }
                curData.data.push([test.data[plIdx], m[2]]);
            }
            addLineChart(canvas, data, platform_names[plIdx], scaleTitle);
        }
        function buildTestsByPlatformsLine(bsName, scaleTitle) {
            let bs = bench_sets[bsName];
            let canvas = document.getElementById('chart' + bs.id);
            let after = null;

            for (const i in platform_names) {
                if (platformChecked(i)) {
                    if (!canvas) {
                        canvas = document.createElement('canvas');
                        canvas.classList.add('bench_chart');
                        canvas.style.width = "100%";
                        after.after(canvas);
                    }
                    canvas.style.height = "300px";
                    canvas.height = 300 * devicePixelRatio;
                    buildTestsByPlatformsLineOne(bs, canvas, i, scaleTitle);
                    after = canvas;
                    canvas = null;
                }
            }
        }
        function buildPlatformsByTestsLineOne(bs, canvas, after, testData, title, scaleTitle) {
            let data = { datasets: [] };
            for (const i in platform_names) {
                if (platformChecked(i)) {
                    ds = {label: platform_names[i], data: []};
                    for (const test of testData) {
                        ds.data.push([test.data[i], test.count]);
                    }
                    data.datasets.push(ds);
                }
            }
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.classList.add('bench_chart');
                canvas.style.width = "100%";
                after.after(canvas);
            }
            canvas.style.height = "300px";
            canvas.height = 300 * devicePixelRatio;
            addLineChart(canvas, data, title, scaleTitle);
            return canvas;
        }
        function buildPlatformsByTestsLine(bsName, scaleTitle) {
            let bs = bench_sets[bsName];
            let canvas = document.getElementById('chart' + bs.id);
            let after = null;
            let data = [];
            let prevTest = '';
            for (const test of bs.tests) {
                let m = test.name.match(/(.+)[\/\|](\d+)$/);
                if (m[1] != prevTest) {
                    if (data.length) {
                        after = buildPlatformsByTestsLineOne(bs, canvas, after, data, prevTest, scaleTitle);
                        canvas = null;
                    }
                    prevTest = m[1];
                    data = [];
                }
                data.push({count: m[2], data: test.data});
            }
            if (data.length) {
                buildPlatformsByTestsLineOne(bs, canvas, after, data, prevTest, scaleTitle);
            }
        }
        function buildCharts() {
            let plCount = 0;
            for (const i in platform_names) {
                if (platformChecked(i))
                    plCount++;
            }
            buildCanvas(plCount);
            for (var bs_name in bench_sets) {
                activeBuilder(bs_name);
            }
        }
        function switchGrouping() {
            activeBuilder = document.getElementById('gbp').checked ? buildTestsByPlatformsBar : buildPlatformsByTestsBar;
            buildCharts();
        }
        document.addEventListener('DOMContentLoaded', (event) => {
            if (!hljs) {
                let scriptTag = document.createElement('script');
                scriptTag.src = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js";
                scriptTag.onload = hl;
                scriptTag.onreadystatechange = hl;
                document.body.appendChild(scriptTag);
            } else {
                hl();
            }
            if (!Chart) {
                let scriptTag = document.createElement('script');
                scriptTag.src = "https://cdn.jsdelivr.net/npm/chart.js";
                scriptTag.onload = buildCharts;
                scriptTag.onreadystatechange = buildCharts;
                document.body.appendChild(scriptTag);
            } else {
                buildCharts();
            }
        });
    </script>
</head><body><div class="header"><h2>SimStr benchmarks results</h2>
<span>All times in ns.</span>
<span><a href="https://github.com/orefkov/simstr/blob/main/bench/bench_str.cpp">Source for benchmarks</a></span>
<div>Group tests by platforms in charts: <input type="checkbox" id="gbp" checked onchange="switchGrouping()"/></div><div class="test_platforms"><h3>Test configurations:</h3><ul>
<li><span class="platform">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</span><span class="tooltip">32 X 2494.22 MHz CPU s<span class="tooltiptext">CPU Caches:
  L1 Data 32 KiB (x16)
  L1 Instruction 32 KiB (x16)
  L2 Unified 256 KiB (x16)
  L3 Unified 40960 KiB (x1)
Load Average: 0.37, 0.82, 0.77
***WARNING*** ASLR is enabled, the results may have unreproducible noise in them.</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl0" checked onchange="buildCharts()"/></li>
<li><span class="platform">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</span><span class="tooltip">32 X 2494.22 MHz CPU s<span class="tooltiptext">CPU Caches:
  L1 Data 32 KiB (x16)
  L1 Instruction 32 KiB (x16)
  L2 Unified 256 KiB (x16)
  L3 Unified 40960 KiB (x1)
Load Average: 0.00, 0.00, 0.00
***WARNING*** ASLR is enabled, the results may have unreproducible noise in them.</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl1" checked onchange="buildCharts()"/></li>
<li><span class="platform">Xeon E5-2682 v4, Windows 10, Clang-19</span><span class="tooltip">32 X 2494 MHz CPU s<span class="tooltiptext">CPU Caches:
  L1 Data 32 KiB (x16)
  L1 Instruction 32 KiB (x16)
  L2 Unified 256 KiB (x16)
  L3 Unified 40960 KiB (x1)</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl2" checked onchange="buildCharts()"/></li>
<li><span class="platform">Xeon E5-2682 v4, Windows 10, MSVC-19</span><span class="tooltip">32 X 2494 MHz CPU s<span class="tooltiptext">CPU Caches:
  L1 Data 32 KiB (x16)
  L1 Instruction 32 KiB (x16)
  L2 Unified 256 KiB (x16)
  L3 Unified 40960 KiB (x1)</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl3" checked onchange="buildCharts()"/></li>
<li><span class="platform">Xeon E5-2682 v4, WASM Firefox, Clang-21</span><span class="tooltip">32 X 2513.96 MHz CPU s<span class="tooltiptext">Firefox: 146.0.1.60 webasm</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl4" checked onchange="buildCharts()"/></li>
</ul></div></div>
<script>const platform_names=['Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21','Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13','Xeon E5-2682 v4, Windows 10, Clang-19','Xeon E5-2682 v4, Windows 10, MSVC-19','Xeon E5-2682 v4, WASM Firefox, Clang-21'];</script>


<div class="benchset" id="bs1"><h4><a id="bs70109915512075798510" href="#bs70109915512075798510">#</a>&nbsp;Concatenate string + Number + &quot;Literal&quot;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and number by std to std::string<span class="tooltiptext code">void ConcatStdToStd(benchmark::State&amp; state) {
    std::string s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = s1 + std::to_string(i) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">213</td><td class="benchmarkresult">207</td><td class="benchmarkresult">266</td><td class="benchmarkresult">321</td><td class="benchmarkresult">917</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and number by StrExpr to std::string<span class="tooltiptext code">void ConcatSimToStd(benchmark::State&amp; state) {
    std::string s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = +s1 + i + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">110</td><td class="benchmarkresult">101</td><td class="benchmarkresult">157</td><td class="benchmarkresult">255</td><td class="benchmarkresult">439</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat stringa and number by StrExpr to simstr::stringa<span class="tooltiptext code">void ConcatSimToSim(benchmark::State&amp; state) {
    stra s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            stringa str = s1 + i + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">stringa при том же размере, что и std::string,
вмещает в SSO 23 символа вместо 15, поэтому
в конце теста std::string приходится аллоцировать память,
а в stringa весь тест входит в SSO.</span></span></td><td class="benchmarkresult">67.3</td><td class="benchmarkresult">78.9</td><td class="benchmarkresult">68.0</td><td class="benchmarkresult">107</td><td class="benchmarkresult">212</td></tr>
</tbody></table></div><script>bench_sets['Concatenate string + Number + "Literal"'] = {id:'bs1', tests:[
{name:'Concat std::string and number by std to std::string',data:[213,207,266,321,917]},
{name:'Concat std::string and number by StrExpr to std::string',data:[110,101,157,255,439]},
{name:'Concat stringa and number by StrExpr to simstr::stringa',data:[67.3,78.9,68.0,107,212]}
]}</script>

<div class="benchset" id="bs2"><h4><a id="bs146911715078927772520" href="#bs146911715078927772520">#</a>&nbsp;Concatenate string + Hex Number + &quot;Literal&quot;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and hex number by std to std::string<span class="tooltiptext code">void ConcatStdToStdHex(benchmark::State&amp; state) {
    // We use a short string so that the longest result is 15 characters and fits in the std::string SSO buffer.
    std::string s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            // What is standard method to get hex number?
            std::string str = s1 + std::format(&quot;0x{:x}&quot;, i) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">860</td><td class="benchmarkresult">934</td><td class="benchmarkresult">1522</td><td class="benchmarkresult">1848</td><td class="benchmarkresult">1752</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and hex number by StrExpr to std::string<span class="tooltiptext code">void ConcatSimToStdHex(benchmark::State&amp; state) {
    // We use a short string so that the longest result is 15 characters and fits in the std::string SSO buffer.
    std::string s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = +s1 + e_hex&lt;HexFlags::Short>(i) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">71.7</td><td class="benchmarkresult">64.9</td><td class="benchmarkresult">95.7</td><td class="benchmarkresult">128</td><td class="benchmarkresult">377</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat stringa and hex number by StrExpr to simstr::stringa<span class="tooltiptext code">void ConcatSimToSimHex(benchmark::State&amp; state) {
    // stringa SSO buffer is 23, but we use a short string to compare under the same conditions
    stra s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            stringa str = s1 + e_hex&lt;HexFlags::Short>(i) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">71.4</td><td class="benchmarkresult">70.8</td><td class="benchmarkresult">69.6</td><td class="benchmarkresult">99.9</td><td class="benchmarkresult">189</td></tr>
</tbody></table></div><script>bench_sets['Concatenate string + Hex Number + "Literal"'] = {id:'bs2', tests:[
{name:'Concat std::string and hex number by std to std::string',data:[860,934,1522,1848,1752]},
{name:'Concat std::string and hex number by StrExpr to std::string',data:[71.7,64.9,95.7,128,377]},
{name:'Concat stringa and hex number by StrExpr to simstr::stringa',data:[71.4,70.8,69.6,99.9,189]}
]}</script>

<div class="benchset" id="bs3"><h4><a id="bs59672599204338055190" href="#bs59672599204338055190">#</a>&nbsp;Concatenate string + &quot;Literal&quot;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string by std to std::string<span class="tooltiptext code">void ConcatStdToStdS(benchmark::State&amp; state) {
    std::string s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = s1 + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">49.2</td><td class="benchmarkresult">50.7</td><td class="benchmarkresult">41.2</td><td class="benchmarkresult">55.4</td><td class="benchmarkresult">110</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string by StrExpr to std::string<span class="tooltiptext code">void ConcatSimToStdS(benchmark::State&amp; state) {
    std::string s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = +s1 + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">31.5</td><td class="benchmarkresult">33.0</td><td class="benchmarkresult">38.3</td><td class="benchmarkresult">69.4</td><td class="benchmarkresult">107</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat stringa by StrExpr to stringa<span class="tooltiptext code">void ConcatSimToSimS(benchmark::State&amp; state) {
    stra s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            stringa str = s1 + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">28.8</td><td class="benchmarkresult">31.5</td><td class="benchmarkresult">40.3</td><td class="benchmarkresult">53.2</td><td class="benchmarkresult">92.3</td></tr>
</tbody></table></div><script>bench_sets['Concatenate string + "Literal"'] = {id:'bs3', tests:[
{name:'Concat std::string by std to std::string',data:[49.2,50.7,41.2,55.4,110]},
{name:'Concat std::string by StrExpr to std::string',data:[31.5,33.0,38.3,69.4,107]},
{name:'Concat stringa by StrExpr to stringa',data:[28.8,31.5,40.3,53.2,92.3]}
]}</script>

<div class="benchset" id="bs4"><h4><a id="bs77666948964429305550" href="#bs77666948964429305550">#</a>&nbsp;Create Empty Str</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Пустые строки, ничего необычного.</span></span></td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">2.55</td><td class="benchmarkresult">2.15</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.368</td><td class="benchmarkresult">0.752</td><td class="benchmarkresult">0.364</td><td class="benchmarkresult">1.84</td><td class="benchmarkresult">0.975</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.369</td><td class="benchmarkresult">0.188</td><td class="benchmarkresult">0.359</td><td class="benchmarkresult">1.83</td><td class="benchmarkresult">0.967</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.748</td><td class="benchmarkresult">0.759</td><td class="benchmarkresult">0.725</td><td class="benchmarkresult">2.20</td><td class="benchmarkresult">2.21</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">2.53</td><td class="benchmarkresult">2.26</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">1.12</td><td class="benchmarkresult">1.14</td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">2.56</td><td class="benchmarkresult">2.56</td></tr>
</tbody></table></div><script>bench_sets['Create Empty Str'] = {id:'bs4', tests:[
{name:'std::string e;',data:[1.10,1.13,1.11,2.55,2.15]},
{name:'std::string_view e;',data:[0.368,0.752,0.364,1.84,0.975]},
{name:'ssa e;',data:[0.369,0.188,0.359,1.83,0.967]},
{name:'stringa e;',data:[0.748,0.759,0.725,2.20,2.21]},
{name:'lstringa<20> e;',data:[1.13,1.13,1.13,2.53,2.26]},
{name:'lstringa<40> e;',data:[1.12,1.14,1.13,2.56,2.56]}
]}</script>

<div class="benchset" id="bs5"><h4><a id="bs181001525395597238060" href="#bs181001525395597238060">#</a>&nbsp;Create Str from short literal (9 symbols)</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e      = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Короткий литерал помещается во внутренний буфер std::string,
время тратится только на копирование 10 байтов.</span></span></td><td class="benchmarkresult">1.85</td><td class="benchmarkresult">1.89</td><td class="benchmarkresult">1.83</td><td class="benchmarkresult">2.60</td><td class="benchmarkresult">2.33</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">И string_view, и ssa - по сути одно и то же:
указатель на текст и его длина.</span></span></td><td class="benchmarkresult">0.730</td><td class="benchmarkresult">0.758</td><td class="benchmarkresult">0.724</td><td class="benchmarkresult">1.85</td><td class="benchmarkresult">1.23</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e              = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.371</td><td class="benchmarkresult">0.766</td><td class="benchmarkresult">0.360</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">0.997</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e          = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">stringa при инициализации константным литералом так же
сохраняет только указатель на текст и его длину.</span></span></td><td class="benchmarkresult">1.85</td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">1.81</td><td class="benchmarkresult">2.24</td><td class="benchmarkresult">2.59</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e     = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Внутреннего буфера хватает для размещения символов,
время уходит только на копирование байтов.</span></span></td><td class="benchmarkresult">1.84</td><td class="benchmarkresult">1.87</td><td class="benchmarkresult">1.83</td><td class="benchmarkresult">2.55</td><td class="benchmarkresult">2.65</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e     = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">1.84</td><td class="benchmarkresult">1.89</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">2.54</td><td class="benchmarkresult">2.69</td></tr>
</tbody></table></div><script>bench_sets['Create Str from short literal (9 symbols)'] = {id:'bs5', tests:[
{name:'std::string e      = "Test text";',data:[1.85,1.89,1.83,2.60,2.33]},
{name:'std::string_view e = "Test text";',data:[0.730,0.758,0.724,1.85,1.23]},
{name:'ssa e              = "Test text";',data:[0.371,0.766,0.360,1.82,0.997]},
{name:'stringa e          = "Test text";',data:[1.85,1.13,1.81,2.24,2.59]},
{name:'lstringa<20> e     = "Test text";',data:[1.84,1.87,1.83,2.55,2.65]},
{name:'lstringa<40> e     = "Test text";',data:[1.84,1.89,1.82,2.54,2.69]}
]}</script>

<div class="benchset" id="bs6"><h4><a id="bs132333183298742730280" href="#bs132333183298742730280">#</a>&nbsp;Create Str from long literal (30 symbols)</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e      = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Вот тут уже литерал не помещается во внутренний буфер,
возникает аллокация и копирование 30-и байтов.
Но как же отстает аллокация под Windows от Linux'а, 20 vs 70 ns...</span></span></td><td class="benchmarkresult">19.4</td><td class="benchmarkresult">18.9</td><td class="benchmarkresult">73.5</td><td class="benchmarkresult">77.0</td><td class="benchmarkresult">16.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">string_view и ssa по прежнему ничего не делают, кроме
запоминания указателя на текст и его размера.</span></span></td><td class="benchmarkresult">0.735</td><td class="benchmarkresult">0.759</td><td class="benchmarkresult">0.729</td><td class="benchmarkresult">1.85</td><td class="benchmarkresult">1.24</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e              = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.368</td><td class="benchmarkresult">0.764</td><td class="benchmarkresult">0.365</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">0.979</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e          = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">stringa на константных литералах не отстает!</span></span></td><td class="benchmarkresult">1.85</td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">2.20</td><td class="benchmarkresult">2.64</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e     = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">lstringa<20> может вместить в себя до 23 символов,
Очевидно, что для 30-и символов уже нужна аллокация.</span></span></td><td class="benchmarkresult">20.3</td><td class="benchmarkresult">21.7</td><td class="benchmarkresult">76.6</td><td class="benchmarkresult">77.5</td><td class="benchmarkresult">17.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e     = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А в lstringa<40> влезает до 47 символов, так что просто
копируется 30 байтов.</span></span></td><td class="benchmarkresult">2.53</td><td class="benchmarkresult">1.88</td><td class="benchmarkresult">2.53</td><td class="benchmarkresult">3.28</td><td class="benchmarkresult">2.96</td></tr>
</tbody></table></div><script>bench_sets['Create Str from long literal (30 symbols)'] = {id:'bs6', tests:[
{name:'std::string e      = "123456789012345678901234567890";',data:[19.4,18.9,73.5,77.0,16.3]},
{name:'std::string_view e = "123456789012345678901234567890";',data:[0.735,0.759,0.729,1.85,1.24]},
{name:'ssa e              = "123456789012345678901234567890";',data:[0.368,0.764,0.365,1.82,0.979]},
{name:'stringa e          = "123456789012345678901234567890";',data:[1.85,1.13,1.82,2.20,2.64]},
{name:'lstringa<20> e     = "123456789012345678901234567890";',data:[20.3,21.7,76.6,77.5,17.4]},
{name:'lstringa<40> e     = "123456789012345678901234567890";',data:[2.53,1.88,2.53,3.28,2.96]}
]}</script>

<div class="benchset" id="bs7"><h4><a id="bs6234433963744178700" href="#bs6234433963744178700">#</a>&nbsp;Create copy of Str with 9 symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e      = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Строка в пределах SSO, так что просто копирует байты.</span></span></td><td class="benchmarkresult">4.82</td><td class="benchmarkresult">5.02</td><td class="benchmarkresult">1.84</td><td class="benchmarkresult">5.38</td><td class="benchmarkresult">2.23</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.372</td><td class="benchmarkresult">0.387</td><td class="benchmarkresult">0.368</td><td class="benchmarkresult">2.86</td><td class="benchmarkresult">1.23</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e              = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">ssa и string_view не владеют строкой, копируется
только информация о строке.</span></span></td><td class="benchmarkresult">0.368</td><td class="benchmarkresult">0.380</td><td class="benchmarkresult">0.359</td><td class="benchmarkresult">2.92</td><td class="benchmarkresult">1.22</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e          = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Копирование stringa происходит быстро,
особенно если она инициализирована литералом.</span></span></td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.15</td><td class="benchmarkresult">1.30</td><td class="benchmarkresult">4.03</td><td class="benchmarkresult">2.58</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e     = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">В обоих случаях хватает внутреннего буфера.</span></span></td><td class="benchmarkresult">4.12</td><td class="benchmarkresult">4.70</td><td class="benchmarkresult">5.22</td><td class="benchmarkresult">7.66</td><td class="benchmarkresult">16.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e     = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Только копируются байты.</span></span></td><td class="benchmarkresult">4.12</td><td class="benchmarkresult">4.94</td><td class="benchmarkresult">5.16</td><td class="benchmarkresult">8.45</td><td class="benchmarkresult">15.0</td></tr>
</tbody></table></div><script>bench_sets['Create copy of Str with 9 symbols'] = {id:'bs7', tests:[
{name:'std::string e      = "Test text"; auto c{e};',data:[4.82,5.02,1.84,5.38,2.23]},
{name:'std::string_view e = "Test text"; auto c{e};',data:[0.372,0.387,0.368,2.86,1.23]},
{name:'ssa e              = "Test text"; auto c{e};',data:[0.368,0.380,0.359,2.92,1.22]},
{name:'stringa e          = "Test text"; auto c{e};',data:[1.10,1.15,1.30,4.03,2.58]},
{name:'lstringa<20> e     = "Test text"; auto c{e};',data:[4.12,4.70,5.22,7.66,16.1]},
{name:'lstringa<40> e     = "Test text"; auto c{e};',data:[4.12,4.94,5.16,8.45,15.0]}
]}</script>

<div class="benchset" id="bs8"><h4><a id="bs76384575499199461500" href="#bs76384575499199461500">#</a>&nbsp;Create copy of Str with 30 symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e      = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Копирования длинной строки вызывает аллокацию,
SSO уже не хватает. И снова как же отстаёт аллокация под Windows...</span></span></td><td class="benchmarkresult">19.9</td><td class="benchmarkresult">24.7</td><td class="benchmarkresult">76.1</td><td class="benchmarkresult">77.9</td><td class="benchmarkresult">37.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.733</td><td class="benchmarkresult">0.767</td><td class="benchmarkresult">0.726</td><td class="benchmarkresult">1.84</td><td class="benchmarkresult">1.24</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e              = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.370</td><td class="benchmarkresult">0.759</td><td class="benchmarkresult">0.365</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">0.986</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e          = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А вот у stringa копирование литерала не зависит от его длины,
сравни с предыдущим бенчмарком.</span></span></td><td class="benchmarkresult">1.85</td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">1.85</td><td class="benchmarkresult">2.93</td><td class="benchmarkresult">2.64</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e     = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Не влезает, аллокация.</span></span></td><td class="benchmarkresult">19.9</td><td class="benchmarkresult">21.0</td><td class="benchmarkresult">75.1</td><td class="benchmarkresult">79.9</td><td class="benchmarkresult">15.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e     = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Уложили во внутренний буфер.</span></span></td><td class="benchmarkresult">4.53</td><td class="benchmarkresult">4.57</td><td class="benchmarkresult">4.41</td><td class="benchmarkresult">6.61</td><td class="benchmarkresult">14.7</td></tr>
</tbody></table></div><script>bench_sets['Create copy of Str with 30 symbols'] = {id:'bs8', tests:[
{name:'std::string e      = "123456789012345678901234567890"; auto c{e};',data:[19.9,24.7,76.1,77.9,37.1]},
{name:'std::string_view e = "123456789012345678901234567890"; auto c{e};',data:[0.733,0.767,0.726,1.84,1.24]},
{name:'ssa e              = "123456789012345678901234567890"; auto c{e};',data:[0.370,0.759,0.365,1.82,0.986]},
{name:'stringa e          = "123456789012345678901234567890"; auto c{e};',data:[1.85,1.13,1.85,2.93,2.64]},
{name:'lstringa<20> e     = "123456789012345678901234567890"; auto c{e};',data:[19.9,21.0,75.1,79.9,15.9]},
{name:'lstringa<40> e     = "123456789012345678901234567890"; auto c{e};',data:[4.53,4.57,4.41,6.61,14.7]}
]}</script>

<div class="benchset" id="bs9"><h4><a id="bs21623892135774528620" href="#bs21623892135774528620">#</a>&nbsp;Find 9 symbols text in end of 99 symbols text</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Здесь "победила дружба", у всех типов по колонке примерно одинаково.
Однако, Windows и Linux явно в разных весовых категориях.</span></span></td><td class="benchmarkresult">7.15</td><td class="benchmarkresult">7.26</td><td class="benchmarkresult">38.9</td><td class="benchmarkresult">41.6</td><td class="benchmarkresult">53.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">7.07</td><td class="benchmarkresult">6.94</td><td class="benchmarkresult">38.5</td><td class="benchmarkresult">39.5</td><td class="benchmarkresult">57.6</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.79</td><td class="benchmarkresult">6.58</td><td class="benchmarkresult">17.7</td><td class="benchmarkresult">21.9</td><td class="benchmarkresult">57.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">7.01</td><td class="benchmarkresult">6.89</td><td class="benchmarkresult">19.4</td><td class="benchmarkresult">29.5</td><td class="benchmarkresult">59.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20>::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.35</td><td class="benchmarkresult">6.50</td><td class="benchmarkresult">17.8</td><td class="benchmarkresult">22.0</td><td class="benchmarkresult">52.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40>::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.43</td><td class="benchmarkresult">6.57</td><td class="benchmarkresult">18.0</td><td class="benchmarkresult">20.8</td><td class="benchmarkresult">53.0</td></tr>
</tbody></table></div><script>bench_sets['Find 9 symbols text in end of 99 symbols text'] = {id:'bs9', tests:[
{name:'std::string::find;',data:[7.15,7.26,38.9,41.6,53.3]},
{name:'std::string_view::find;',data:[7.07,6.94,38.5,39.5,57.6]},
{name:'ssa::find;',data:[6.79,6.58,17.7,21.9,57.4]},
{name:'stringa::find;',data:[7.01,6.89,19.4,29.5,59.1]},
{name:'lstringa<20>::find;',data:[6.35,6.50,17.8,22.0,52.1]},
{name:'lstringa<40>::find;',data:[6.43,6.57,18.0,20.8,53.0]}
]}</script>

<div class="benchset" id="bs10"><h4><a id="bs170792414351801782640" href="#bs170792414351801782640">#</a>&nbsp;Copy not literal Str with N symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/15<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.91</td><td class="benchmarkresult">4.96</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">5.14</td><td class="benchmarkresult">35.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/16<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Явно виден скачок, где заканчивается SSO и начинается аллокация.
Обратите внимание, что WASM - 32-битный, и там размер
SSO у std::string меньше, насколько я помню, 11 символов + 0.</span></span></td><td class="benchmarkresult">22.3</td><td class="benchmarkresult">23.6</td><td class="benchmarkresult">78.2</td><td class="benchmarkresult">82.9</td><td class="benchmarkresult">37.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/23<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Дальше просто добавляется время на копирование байтов.</span></span></td><td class="benchmarkresult">22.3</td><td class="benchmarkresult">24.0</td><td class="benchmarkresult">79.7</td><td class="benchmarkresult">82.0</td><td class="benchmarkresult">37.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/24<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">22.1</td><td class="benchmarkresult">23.5</td><td class="benchmarkresult">79.2</td><td class="benchmarkresult">82.7</td><td class="benchmarkresult">37.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/32<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">22.1</td><td class="benchmarkresult">23.8</td><td class="benchmarkresult">81.1</td><td class="benchmarkresult">90.4</td><td class="benchmarkresult">40.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/64<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">22.6</td><td class="benchmarkresult">23.5</td><td class="benchmarkresult">82.3</td><td class="benchmarkresult">85.9</td><td class="benchmarkresult">41.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/128<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">23.6</td><td class="benchmarkresult">24.9</td><td class="benchmarkresult">82.2</td><td class="benchmarkresult">92.1</td><td class="benchmarkresult">42.5</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/256<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">28.1</td><td class="benchmarkresult">25.3</td><td class="benchmarkresult">85.3</td><td class="benchmarkresult">90.4</td><td class="benchmarkresult">61.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/512<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">28.1</td><td class="benchmarkresult">29.1</td><td class="benchmarkresult">87.9</td><td class="benchmarkresult">92.3</td><td class="benchmarkresult">60.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/1024<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">37.4</td><td class="benchmarkresult">37.1</td><td class="benchmarkresult">98.6</td><td class="benchmarkresult">104</td><td class="benchmarkresult">61.6</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/2048<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">75.0</td><td class="benchmarkresult">77.0</td><td class="benchmarkresult">131</td><td class="benchmarkresult">129</td><td class="benchmarkresult">81.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/4096<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Чем длиннее строка, тем дольше создаётся копия.</span></span></td><td class="benchmarkresult">115</td><td class="benchmarkresult">112</td><td class="benchmarkresult">171</td><td class="benchmarkresult">185</td><td class="benchmarkresult">126</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/15<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Здесь stringa инициализируется не литералом,
а значит, должна сама хранить символы.</span></span></td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.29</td><td class="benchmarkresult">4.02</td><td class="benchmarkresult">2.55</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/16<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Под WASM SSO у stringa составляет 15 символов. Кроме того,
собиралось без поддержки потоков, поэтому возможно атомарный
инкремент заменён на обычный, судя по времени.</span></span></td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.31</td><td class="benchmarkresult">4.00</td><td class="benchmarkresult">4.89</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/23<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">SSO в stringa до 23 символов, и даже 23
копируются быстрее, чем 15 в std::string.</span></span></td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.30</td><td class="benchmarkresult">4.05</td><td class="benchmarkresult">4.91</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/24<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Всё, не влезаем в SSO, а значит, используем shared буфер.
Добавляется время на атомарный инкремент счётчика.</span></span></td><td class="benchmarkresult">16.6</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.4</td><td class="benchmarkresult">4.92</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/32<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">4.89</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/64<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.5</td><td class="benchmarkresult">4.88</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/128<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">15.7</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">4.90</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/256<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.5</td><td class="benchmarkresult">4.85</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/512<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.4</td><td class="benchmarkresult">4.89</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/1024<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.6</td><td class="benchmarkresult">4.89</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/2048<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.3</td><td class="benchmarkresult">16.3</td><td class="benchmarkresult">18.6</td><td class="benchmarkresult">4.94</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/4096<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">И как видно, кроме инкремента нет накладных расходов,
время копирования не зависит от длины строки.</span></span></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.5</td><td class="benchmarkresult">4.90</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/15<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">lstringa<16> использует SSO до 23 символов.
А в WASM 32-битная архитектура, SSO до 19 символов.</span></span></td><td class="benchmarkresult">4.57</td><td class="benchmarkresult">4.52</td><td class="benchmarkresult">4.80</td><td class="benchmarkresult">7.46</td><td class="benchmarkresult">13.2</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/16<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.48</td><td class="benchmarkresult">4.56</td><td class="benchmarkresult">4.75</td><td class="benchmarkresult">7.29</td><td class="benchmarkresult">13.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/23<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.50</td><td class="benchmarkresult">4.51</td><td class="benchmarkresult">4.79</td><td class="benchmarkresult">7.35</td><td class="benchmarkresult">30.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/24<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">И после начинает вести себя при копировании, как std::string.</span></span></td><td class="benchmarkresult">24.0</td><td class="benchmarkresult">25.8</td><td class="benchmarkresult">77.1</td><td class="benchmarkresult">78.9</td><td class="benchmarkresult">30.5</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/32<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">23.8</td><td class="benchmarkresult">25.4</td><td class="benchmarkresult">80.0</td><td class="benchmarkresult">82.8</td><td class="benchmarkresult">35.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/64<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">25.5</td><td class="benchmarkresult">26.7</td><td class="benchmarkresult">78.4</td><td class="benchmarkresult">84.5</td><td class="benchmarkresult">34.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/128<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">25.4</td><td class="benchmarkresult">27.2</td><td class="benchmarkresult">83.3</td><td class="benchmarkresult">85.6</td><td class="benchmarkresult">34.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/256<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">27.2</td><td class="benchmarkresult">28.9</td><td class="benchmarkresult">81.4</td><td class="benchmarkresult">676</td><td class="benchmarkresult">53.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/512<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">36.9</td><td class="benchmarkresult">37.2</td><td class="benchmarkresult">85.3</td><td class="benchmarkresult">88.6</td><td class="benchmarkresult">51.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/1024<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">72.8</td><td class="benchmarkresult">74.0</td><td class="benchmarkresult">93.0</td><td class="benchmarkresult">98.9</td><td class="benchmarkresult">56.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/2048<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">74.7</td><td class="benchmarkresult">76.3</td><td class="benchmarkresult">130</td><td class="benchmarkresult">131</td><td class="benchmarkresult">77.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/4096<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">89.0</td><td class="benchmarkresult">90.7</td><td class="benchmarkresult">189</td><td class="benchmarkresult">188</td><td class="benchmarkresult">118</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/15<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">5.26</td><td class="benchmarkresult">4.48</td><td class="benchmarkresult">5.12</td><td class="benchmarkresult">8.13</td><td class="benchmarkresult">13.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/16<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">5.38</td><td class="benchmarkresult">4.50</td><td class="benchmarkresult">5.17</td><td class="benchmarkresult">8.10</td><td class="benchmarkresult">13.6</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/23<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">5.36</td><td class="benchmarkresult">4.47</td><td class="benchmarkresult">5.24</td><td class="benchmarkresult">8.13</td><td class="benchmarkresult">13.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/24<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">5.33</td><td class="benchmarkresult">4.56</td><td class="benchmarkresult">5.20</td><td class="benchmarkresult">8.18</td><td class="benchmarkresult">13.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/32<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">5.04</td><td class="benchmarkresult">4.11</td><td class="benchmarkresult">8.01</td><td class="benchmarkresult">11.1</td><td class="benchmarkresult">16.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/64<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.08</td><td class="benchmarkresult">5.75</td><td class="benchmarkresult">8.23</td><td class="benchmarkresult">11.1</td><td class="benchmarkresult">16.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/128<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.34</td><td class="benchmarkresult">7.19</td><td class="benchmarkresult">8.41</td><td class="benchmarkresult">11.5</td><td class="benchmarkresult">17.2</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/256<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">7.87</td><td class="benchmarkresult">8.09</td><td class="benchmarkresult">9.58</td><td class="benchmarkresult">12.5</td><td class="benchmarkresult">19.2</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/512<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Даже 512 символов копируются быстрее, чем
одна аллокация или атомарный инкремент.</span></span></td><td class="benchmarkresult">10.2</td><td class="benchmarkresult">10.3</td><td class="benchmarkresult">11.2</td><td class="benchmarkresult">14.2</td><td class="benchmarkresult">22.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/1024<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А дальше уже как у всех</span></span></td><td class="benchmarkresult">68.8</td><td class="benchmarkresult">74.7</td><td class="benchmarkresult">94.7</td><td class="benchmarkresult">98.9</td><td class="benchmarkresult">56.5</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/2048<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">74.2</td><td class="benchmarkresult">77.6</td><td class="benchmarkresult">128</td><td class="benchmarkresult">135</td><td class="benchmarkresult">74.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/4096<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">91.3</td><td class="benchmarkresult">92.1</td><td class="benchmarkresult">191</td><td class="benchmarkresult">193</td><td class="benchmarkresult">119</td></tr>
</tbody></table></div><script>bench_sets['Copy not literal Str with N symbols'] = {id:'bs10', tests:[
{name:'std::string copy{str_with_len_N};/15',data:[4.91,4.96,1.82,5.14,35.9]},
{name:'std::string copy{str_with_len_N};/16',data:[22.3,23.6,78.2,82.9,37.0]},
{name:'std::string copy{str_with_len_N};/23',data:[22.3,24.0,79.7,82.0,37.8]},
{name:'std::string copy{str_with_len_N};/24',data:[22.1,23.5,79.2,82.7,37.4]},
{name:'std::string copy{str_with_len_N};/32',data:[22.1,23.8,81.1,90.4,40.9]},
{name:'std::string copy{str_with_len_N};/64',data:[22.6,23.5,82.3,85.9,41.0]},
{name:'std::string copy{str_with_len_N};/128',data:[23.6,24.9,82.2,92.1,42.5]},
{name:'std::string copy{str_with_len_N};/256',data:[28.1,25.3,85.3,90.4,61.8]},
{name:'std::string copy{str_with_len_N};/512',data:[28.1,29.1,87.9,92.3,60.0]},
{name:'std::string copy{str_with_len_N};/1024',data:[37.4,37.1,98.6,104,61.6]},
{name:'std::string copy{str_with_len_N};/2048',data:[75.0,77.0,131,129,81.7]},
{name:'std::string copy{str_with_len_N};/4096',data:[115,112,171,185,126]},
{name:'stringa copy{str_with_len_N};/15',data:[1.10,1.10,1.29,4.02,2.55]},
{name:'stringa copy{str_with_len_N};/16',data:[1.11,1.10,1.31,4.00,4.89]},
{name:'stringa copy{str_with_len_N};/23',data:[1.11,1.11,1.30,4.05,4.91]},
{name:'stringa copy{str_with_len_N};/24',data:[16.6,16.1,15.8,18.4,4.92]},
{name:'stringa copy{str_with_len_N};/32',data:[16.2,16.1,15.8,18.3,4.89]},
{name:'stringa copy{str_with_len_N};/64',data:[16.2,16.1,15.8,18.5,4.88]},
{name:'stringa copy{str_with_len_N};/128',data:[16.2,16.1,15.7,18.3,4.90]},
{name:'stringa copy{str_with_len_N};/256',data:[16.2,16.1,15.8,18.5,4.85]},
{name:'stringa copy{str_with_len_N};/512',data:[16.2,16.2,15.8,18.4,4.89]},
{name:'stringa copy{str_with_len_N};/1024',data:[16.2,16.2,15.8,18.6,4.89]},
{name:'stringa copy{str_with_len_N};/2048',data:[16.2,16.3,16.3,18.6,4.94]},
{name:'stringa copy{str_with_len_N};/4096',data:[16.2,16.2,15.8,18.5,4.90]},
{name:'lstringa<16> copy{str_with_len_N};/15',data:[4.57,4.52,4.80,7.46,13.2]},
{name:'lstringa<16> copy{str_with_len_N};/16',data:[4.48,4.56,4.75,7.29,13.3]},
{name:'lstringa<16> copy{str_with_len_N};/23',data:[4.50,4.51,4.79,7.35,30.9]},
{name:'lstringa<16> copy{str_with_len_N};/24',data:[24.0,25.8,77.1,78.9,30.5]},
{name:'lstringa<16> copy{str_with_len_N};/32',data:[23.8,25.4,80.0,82.8,35.0]},
{name:'lstringa<16> copy{str_with_len_N};/64',data:[25.5,26.7,78.4,84.5,34.1]},
{name:'lstringa<16> copy{str_with_len_N};/128',data:[25.4,27.2,83.3,85.6,34.4]},
{name:'lstringa<16> copy{str_with_len_N};/256',data:[27.2,28.9,81.4,676,53.9]},
{name:'lstringa<16> copy{str_with_len_N};/512',data:[36.9,37.2,85.3,88.6,51.8]},
{name:'lstringa<16> copy{str_with_len_N};/1024',data:[72.8,74.0,93.0,98.9,56.3]},
{name:'lstringa<16> copy{str_with_len_N};/2048',data:[74.7,76.3,130,131,77.3]},
{name:'lstringa<16> copy{str_with_len_N};/4096',data:[89.0,90.7,189,188,118]},
{name:'lstringa<512> copy{str_with_len_N};/15',data:[5.26,4.48,5.12,8.13,13.7]},
{name:'lstringa<512> copy{str_with_len_N};/16',data:[5.38,4.50,5.17,8.10,13.6]},
{name:'lstringa<512> copy{str_with_len_N};/23',data:[5.36,4.47,5.24,8.13,13.7]},
{name:'lstringa<512> copy{str_with_len_N};/24',data:[5.33,4.56,5.20,8.18,13.8]},
{name:'lstringa<512> copy{str_with_len_N};/32',data:[5.04,4.11,8.01,11.1,16.8]},
{name:'lstringa<512> copy{str_with_len_N};/64',data:[6.08,5.75,8.23,11.1,16.9]},
{name:'lstringa<512> copy{str_with_len_N};/128',data:[6.34,7.19,8.41,11.5,17.2]},
{name:'lstringa<512> copy{str_with_len_N};/256',data:[7.87,8.09,9.58,12.5,19.2]},
{name:'lstringa<512> copy{str_with_len_N};/512',data:[10.2,10.3,11.2,14.2,22.7]},
{name:'lstringa<512> copy{str_with_len_N};/1024',data:[68.8,74.7,94.7,98.9,56.5]},
{name:'lstringa<512> copy{str_with_len_N};/2048',data:[74.2,77.6,128,135,74.8]},
{name:'lstringa<512> copy{str_with_len_N};/4096',data:[91.3,92.1,191,193,119]}
]}</script>

<div class="benchset" id="bs11"><h4><a id="bs94756718925776995960" href="#bs94756718925776995960">#</a>&nbsp;Convert to int &#39;1234567&#39;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string s = &quot;123456789&quot;; int res = std::strtol(s.c_str(), 0, 10);<span class="tooltiptext code">void ToIntStr10(benchmark::State&amp; state, const std::string&amp; s, int c) {
    for (auto _: state) {
        int res = std::strtol(s.c_str(), nullptr, 10);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">В simstr для конвертации в число достаточно куска строки,
нет нужды в null терминированности. Ближайший аналог такого
поведения "std::from_chars", но он к сожалению очень ограничен
по возможностям. Здесь я попытался произвести тесты, близкие по
логике к работе std::from_chars</span></span></td><td class="benchmarkresult">26.7</td><td class="benchmarkresult">27.2</td><td class="benchmarkresult">31.2</td><td class="benchmarkresult">32.4</td><td class="benchmarkresult">67.5</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view s = &quot;123456789&quot;; std::from_chars(s.data(), s.data() + s.size(), res, 10);<span class="tooltiptext code">void ToIntFromChars10(benchmark::State&amp; state, const std::string_view&amp; s, int c) {
    for (auto _: state) {
        int res = 0;
        std::from_chars(s.data(), s.data() + s.size(), res, 10);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">from_chars требует точного указания основания счисления,
не допускает знаков плюс, пробелов, префиксов 0x и т.п.</span></span></td><td class="benchmarkresult">14.9</td><td class="benchmarkresult">11.6</td><td class="benchmarkresult">13.8</td><td class="benchmarkresult">14.0</td><td class="benchmarkresult">27.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa s = &quot;123456789&quot;; int res = s.to_int&lt;int, true, 10, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr10(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 10, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Здесь для to_int заданы такие же ограничения - проверять переполнение,
десятичная система, без лидирующих пробелов и знака плюс</span></span></td><td class="benchmarkresult">12.5</td><td class="benchmarkresult">9.34</td><td class="benchmarkresult">14.2</td><td class="benchmarkresult">15.4</td><td class="benchmarkresult">18.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa s = &quot;123456789&quot;; int res = s.to_int&lt;int, true, 10, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr10(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 10, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">12.9</td><td class="benchmarkresult">7.87</td><td class="benchmarkresult">13.6</td><td class="benchmarkresult">15.1</td><td class="benchmarkresult">17.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> s = &quot;123456789&quot;; int res = s.to_int&lt;int, true, 10, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr10(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 10, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">12.8</td><td class="benchmarkresult">8.37</td><td class="benchmarkresult">13.8</td><td class="benchmarkresult">15.4</td><td class="benchmarkresult">19.2</td></tr>
</tbody></table></div><script>bench_sets['Convert to int \'1234567\''] = {id:'bs11', tests:[
{name:'std::string s = "123456789"; int res = std::strtol(s.c_str(), 0, 10);',data:[26.7,27.2,31.2,32.4,67.5]},
{name:'std::string_view s = "123456789"; std::from_chars(s.data(), s.data() + s.size(), res, 10);',data:[14.9,11.6,13.8,14.0,27.4]},
{name:'stringa s = "123456789"; int res = s.to_int<int, true, 10, false>',data:[12.5,9.34,14.2,15.4,18.8]},
{name:'ssa s = "123456789"; int res = s.to_int<int, true, 10, false>',data:[12.9,7.87,13.6,15.1,17.0]},
{name:'lstringa<20> s = "123456789"; int res = s.to_int<int, true, 10, false>',data:[12.8,8.37,13.8,15.4,19.2]}
]}</script>

<div class="benchset" id="bs12"><h4><a id="bs182426078870126042750" href="#bs182426078870126042750">#</a>&nbsp;Convert to unsigned &#39;abcDef&#39;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string s = &quot;abcDef&quot;; int res = std::strtol(s.c_str(), 0, 16);<span class="tooltiptext code">void ToIntStr16(benchmark::State&amp; state, const std::string&amp; s, int c) {
    for (auto _: state) {
        int res = std::strtol(s.c_str(), nullptr, 16);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Всё то же, только для 16ричной системы</span></span></td><td class="benchmarkresult">24.0</td><td class="benchmarkresult">23.8</td><td class="benchmarkresult">34.0</td><td class="benchmarkresult">35.6</td><td class="benchmarkresult">53.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view s = &quot;abcDef&quot;; std::from_chars(s.data(), s.data() + s.size(), res, 16);<span class="tooltiptext code">void ToIntFromChars16(benchmark::State&amp; state, const std::string_view&amp; s, int c) {
    for (auto _: state) {
        int res = 0;
        std::from_chars(s.data(), s.data() + s.size(), res, 16);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td></td><td class="benchmarkresult">9.85</td><td class="benchmarkresult">10.0</td><td class="benchmarkresult">8.20</td><td class="benchmarkresult">9.50</td><td class="benchmarkresult">29.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa s = &quot;abcDef&quot;; int res = s.to_int&lt;int, true, 16, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr16(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 16, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">11.6</td><td class="benchmarkresult">8.70</td><td class="benchmarkresult">12.5</td><td class="benchmarkresult">14.1</td><td class="benchmarkresult">17.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa s = &quot;abcDef&quot;; int res = s.to_int&lt;int, true, 16, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr16(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 16, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">11.3</td><td class="benchmarkresult">7.87</td><td class="benchmarkresult">11.8</td><td class="benchmarkresult">13.3</td><td class="benchmarkresult">16.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> s = &quot;abcDef&quot;; int res = s.to_int&lt;int, true, 16, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr16(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 16, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">11.4</td><td class="benchmarkresult">8.16</td><td class="benchmarkresult">11.7</td><td class="benchmarkresult">13.8</td><td class="benchmarkresult">18.1</td></tr>
</tbody></table></div><script>bench_sets['Convert to unsigned \'abcDef\''] = {id:'bs12', tests:[
{name:'std::string s = "abcDef"; int res = std::strtol(s.c_str(), 0, 16);',data:[24.0,23.8,34.0,35.6,53.3]},
{name:'std::string_view s = "abcDef"; std::from_chars(s.data(), s.data() + s.size(), res, 16);',data:[9.85,10.0,8.20,9.50,29.7]},
{name:'stringa s = "abcDef"; int res = s.to_int<int, true, 16, false>',data:[11.6,8.70,12.5,14.1,17.7]},
{name:'ssa s = "abcDef"; int res = s.to_int<int, true, 16, false>',data:[11.3,7.87,11.8,13.3,16.8]},
{name:'lstringa<20> s = "abcDef"; int res = s.to_int<int, true, 16, false>',data:[11.4,8.16,11.7,13.8,18.1]}
]}</script>

<div class="benchset" id="bs13"><h4><a id="bs52606100125109966680" href="#bs52606100125109966680">#</a>&nbsp;Convert to int &#39;    1234567&#39;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string s = &quot;    123456789&quot;; int res = std::strtol(s.c_str(), 0, 0);<span class="tooltiptext code">void ToIntStr0(benchmark::State&amp; state, const std::string&amp; s, int c) {
    for (auto _: state) {
        int res = std::strtol(s.c_str(), nullptr, 0);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А здесь уже парсинг произвольного числа.</span></span></td><td class="benchmarkresult">28.5</td><td class="benchmarkresult">28.7</td><td class="benchmarkresult">44.0</td><td class="benchmarkresult">44.8</td><td class="benchmarkresult">72.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa s = &quot;    123456789&quot;; int res = s.to_int&lt;int>; // Check overflow<span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr0(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">19.2</td><td class="benchmarkresult">14.8</td><td class="benchmarkresult">18.6</td><td class="benchmarkresult">20.7</td><td class="benchmarkresult">24.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa s = &quot;    123456789&quot;; int res = s.to_int&lt;int, false>; // No check overflow<span class="tooltiptext code">void ToIntNoOverflow(benchmark::State&amp; state, ssa t, int c) {
    for (auto _: state) {
        int res = t.to_int&lt;int, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">15.4</td><td class="benchmarkresult">10.6</td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">18.8</td><td class="benchmarkresult">23.3</td></tr>
</tbody></table></div><script>bench_sets['Convert to int \'    1234567\''] = {id:'bs13', tests:[
{name:'std::string s = "    123456789"; int res = std::strtol(s.c_str(), 0, 0);',data:[28.5,28.7,44.0,44.8,72.9]},
{name:'stringa s = "    123456789"; int res = s.to_int<int>; // Check overflow',data:[19.2,14.8,18.6,20.7,24.8]},
{name:'ssa s = "    123456789"; int res = s.to_int<int, false>; // No check overflow',data:[15.4,10.6,16.2,18.8,23.3]}
]}</script>

<div class="benchset" id="bs14"><h4><a id="bs182348477702821075660" href="#bs182348477702821075660">#</a>&nbsp;Convert to double &#39;1234.567e10&#39;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string s = &quot;1234.567e10&quot;; double res = std::strtod(s.c_str(), nullptr);<span class="tooltiptext code">void ToDoubleStr(benchmark::State&amp; state, const std::string&amp; s, double c) {
    for (auto _: state) {
        char* ptr = nullptr;
        double res = std::strtod(s.c_str(), &amp;ptr);
        if (ptr == s.c_str()) {
            state.SkipWithError(&quot;not equal&quot;);
        }
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td></td><td class="benchmarkresult">66.9</td><td class="benchmarkresult">63.9</td><td class="benchmarkresult">102</td><td class="benchmarkresult">102</td><td class="benchmarkresult">193</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view s = &quot;1234.567e10&quot;; std::from_chars(s.data(), s.data() + s.size(), res);<span class="tooltiptext code">void ToDoubleFromChars(benchmark::State&amp; state, const std::string_view&amp; s, double c) {
    for (auto _: state) {
        double res = 0;
        if (std::from_chars(s.data(), s.data() + s.size(), res).ec != std::errc{}) {
            state.SkipWithError(&quot;not equal&quot;);
        }
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td></td><td class="benchmarkresult">25.8</td><td class="benchmarkresult">24.0</td><td class="benchmarkresult">60.3</td><td class="benchmarkresult">80.5</td><td class="benchmarkresult">109</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa s = &quot;1234.567e10&quot;; double res = *s.to_double()<span class="tooltiptext code">template&lt;typename T>
void ToDoubleSimStr(benchmark::State&amp; state, T t, double c) {
    for (auto _: state) {
        auto r = t.template to_double&lt;false>();
        if (!r) {
            state.SkipWithError(&quot;not equal&quot;);
        }
        double res = *r;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">25.6</td><td class="benchmarkresult">24.8</td><td class="benchmarkresult">36.0</td><td class="benchmarkresult">37.0</td><td class="benchmarkresult">42.5</td></tr>
</tbody></table></div><script>bench_sets['Convert to double \'1234.567e10\''] = {id:'bs14', tests:[
{name:'std::string s = "1234.567e10"; double res = std::strtod(s.c_str(), nullptr);',data:[66.9,63.9,102,102,193]},
{name:'std::string_view s = "1234.567e10"; std::from_chars(s.data(), s.data() + s.size(), res);',data:[25.8,24.0,60.3,80.5,109]},
{name:'ssa s = "1234.567e10"; double res = *s.to_double()',data:[25.6,24.8,36.0,37.0,42.5]}
]}</script>

<div class="benchset" id="bs15"><h4><a id="bs96505608161678391610" href="#bs96505608161678391610">#</a>&nbsp;Append const literal of 16 bytes 64 times, 1024 total length</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; ... str &lt;&lt; &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">void AppendStreamConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        std::string result;
        std::stringstream str;
        for (size_t c = 0; c &lt; 64; c++) {
            str &lt;&lt; TEXT_16;
        }
        result = str.str();
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(str);
    }
}</span></span></td><td></td><td class="benchmarkresult">1400</td><td class="benchmarkresult">1396</td><td class="benchmarkresult">4738</td><td class="benchmarkresult">5752</td><td class="benchmarkresult">4390</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">void AppendStdStringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        std::string result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td></td><td class="benchmarkresult">353</td><td class="benchmarkresult">341</td><td class="benchmarkresult">1068</td><td class="benchmarkresult">1271</td><td class="benchmarkresult">625</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td></td><td class="benchmarkresult">345</td><td class="benchmarkresult">372</td><td class="benchmarkresult">743</td><td class="benchmarkresult">936</td><td class="benchmarkresult">729</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;128> str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Чем больше внутренний буфер, тем меньше раз требуется
аллокация, тем быстрее результат.</span></span></td><td class="benchmarkresult">242</td><td class="benchmarkresult">249</td><td class="benchmarkresult">400</td><td class="benchmarkresult">535</td><td class="benchmarkresult">585</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td></td><td class="benchmarkresult">231</td><td class="benchmarkresult">230</td><td class="benchmarkresult">255</td><td class="benchmarkresult">353</td><td class="benchmarkresult">504</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;1024> str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td></td><td class="benchmarkresult">138</td><td class="benchmarkresult">142</td><td class="benchmarkresult">154</td><td class="benchmarkresult">232</td><td class="benchmarkresult">423</td></tr>
</tbody></table></div><script>bench_sets['Append const literal of 16 bytes 64 times, 1024 total length'] = {id:'bs15', tests:[
{name:'std::stringstream str; ... str << "abbaabbaabbaabba";',data:[1400,1396,4738,5752,4390]},
{name:'std::string str; ... str += "abbaabbaabbaabba";',data:[353,341,1068,1271,625]},
{name:'lstringa<8> str; ... str += "abbaabbaabbaabba";',data:[345,372,743,936,729]},
{name:'lstringa<128> str; ... str += "abbaabbaabbaabba";',data:[242,249,400,535,585]},
{name:'lstringa<512> str; ... str += "abbaabbaabbaabba";',data:[231,230,255,353,504]},
{name:'lstringa<1024> str; ... str += "abbaabbaabbaabba";',data:[138,142,154,232,423]}
]}</script>

<div class="benchset" id="bs16"><h4><a id="bs36931044816721597850" href="#bs36931044816721597850">#</a>&nbsp;Append string of 16 bytes and const literal of 16 bytes 32 times, 1024 total length</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; ... str &lt;&lt; str_var &lt;&lt; &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">void AppendStreamStrConstLiteral(benchmark::State&amp; state) {
    std::string s1 = TEXT_16;
    for (auto _: state) {
        std::string result;
        std::stringstream s;
        for (size_t c = 0; c &lt; 32; c++) {
            s &lt;&lt; s1 &lt;&lt; TEXT_16;
        }
        result = s.str();
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
    }
}</span></span></td><td></td><td class="benchmarkresult">1398</td><td class="benchmarkresult">1382</td><td class="benchmarkresult">4642</td><td class="benchmarkresult">5642</td><td class="benchmarkresult">4491</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">void AppendStdStrStrConstLiteral(benchmark::State&amp; state) {
    std::string p1 = TEXT_16;
    for (auto _: state) {
        std::string result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">1281</td><td class="benchmarkresult">1278</td><td class="benchmarkresult">3795</td><td class="benchmarkresult">3902</td><td class="benchmarkresult">1908</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteral(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">402</td><td class="benchmarkresult">436</td><td class="benchmarkresult">773</td><td class="benchmarkresult">806</td><td class="benchmarkresult">861</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;128> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteral(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">328</td><td class="benchmarkresult">361</td><td class="benchmarkresult">501</td><td class="benchmarkresult">551</td><td class="benchmarkresult">690</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteral(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">279</td><td class="benchmarkresult">319</td><td class="benchmarkresult">314</td><td class="benchmarkresult">396</td><td class="benchmarkresult">614</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;1024> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteral(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">240</td><td class="benchmarkresult">261</td><td class="benchmarkresult">228</td><td class="benchmarkresult">271</td><td class="benchmarkresult">545</td></tr>
</tbody></table></div><script>bench_sets['Append string of 16 bytes and const literal of 16 bytes 32 times, 1024 total length'] = {id:'bs16', tests:[
{name:'std::stringstream str; ... str << str_var << "abbaabbaabbaabba";',data:[1398,1382,4642,5642,4491]},
{name:'std::string str; ... str += str_var + "abbaabbaabbaabba";',data:[1281,1278,3795,3902,1908]},
{name:'lstringa<8> str; ... str += str_var + "abbaabbaabbaabba";',data:[402,436,773,806,861]},
{name:'lstringa<128> str; ... str += str_var + "abbaabbaabbaabba";',data:[328,361,501,551,690]},
{name:'lstringa<512> str; ... str += str_var + "abbaabbaabbaabba";',data:[279,319,314,396,614]},
{name:'lstringa<1024> str; ... str += str_var + "abbaabbaabbaabba";',data:[240,261,228,271,545]}
]}</script>

<div class="benchset" id="bs17"><h4><a id="bs8293767858383349360" href="#bs8293767858383349360">#</a>&nbsp;Append string of 16 bytes and const literal of 16 bytes 2048 times, 65536 total length</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; ... str &lt;&lt; str_var &lt;&lt; &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">void AppendStreamStrConstLiteralBig(benchmark::State&amp; state) {
    std::string s1 = TEXT_16;
    for (auto _: state) {
        std::string result;
        std::stringstream s;
        for (size_t c = 0; c &lt; 2048; c++) {
            s &lt;&lt; s1 &lt;&lt; TEXT_16;
        }
        result = s.str();
    #ifdef CHECK_RESULT
        if (result.size() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
    }
}</span></span></td><td></td><td class="benchmarkresult">118576</td><td class="benchmarkresult">118832</td><td class="benchmarkresult">214448</td><td class="benchmarkresult">292493</td><td class="benchmarkresult">222195</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">void AppendStdStrStrConstLiteralBig(benchmark::State&amp; state) {
    std::string p1 = TEXT_16;
    for (auto _: state) {
        std::string result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.size() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">74847</td><td class="benchmarkresult">71907</td><td class="benchmarkresult">189274</td><td class="benchmarkresult">191517</td><td class="benchmarkresult">105638</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteralBig(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">45291</td><td class="benchmarkresult">46401</td><td class="benchmarkresult">19006</td><td class="benchmarkresult">23698</td><td class="benchmarkresult">41260</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;128> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteralBig(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">25270</td><td class="benchmarkresult">25211</td><td class="benchmarkresult">18418</td><td class="benchmarkresult">22152</td><td class="benchmarkresult">36472</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteralBig(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">18376</td><td class="benchmarkresult">17344</td><td class="benchmarkresult">19236</td><td class="benchmarkresult">21284</td><td class="benchmarkresult">36824</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;1024> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteralBig(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">15720</td><td class="benchmarkresult">17376</td><td class="benchmarkresult">17274</td><td class="benchmarkresult">21435</td><td class="benchmarkresult">37428</td></tr>
</tbody></table></div><script>bench_sets['Append string of 16 bytes and const literal of 16 bytes 2048 times, 65536 total length'] = {id:'bs17', tests:[
{name:'std::stringstream str; ... str << str_var << "abbaabbaabbaabba"; 2048 times',data:[118576,118832,214448,292493,222195]},
{name:'std::string str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[74847,71907,189274,191517,105638]},
{name:'lstringa<8> str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[45291,46401,19006,23698,41260]},
{name:'lstringa<128> str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[25270,25211,18418,22152,36472]},
{name:'lstringa<512> str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[18376,17344,19236,21284,36824]},
{name:'lstringa<1024> str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[15720,17376,17274,21435,37428]}
]}</script>

<div class="benchset" id="bs18"><h4><a id="bs66949588770596833730" href="#bs66949588770596833730">#</a>&nbsp;Append 2 string of 16 bytes 32 times, 1024 total length</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; ... str &lt;&lt; str_var1 &lt;&lt; str_var2;<span class="tooltiptext code">void AppendStream2String(benchmark::State&amp; state) {
    std::string s1 = TEXT_16;
    std::string s2 = TEXT_16;
    for (auto _: state) {
        std::string result;
        std::stringstream s;
        for (size_t c = 0; c &lt; 32; c++) {
            s &lt;&lt; s1 &lt;&lt; s2;
        }
        result = s.str();
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">1421</td><td class="benchmarkresult">1411</td><td class="benchmarkresult">4447</td><td class="benchmarkresult">5356</td><td class="benchmarkresult">4459</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str; ... str += str_var1 + str_var2;<span class="tooltiptext code">void AppendStdStr2String(benchmark::State&amp; state) {
    std::string s1 = TEXT_16;
    std::string s2 = TEXT_16;

    for (auto _: state) {
        std::string result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">1415</td><td class="benchmarkresult">1351</td><td class="benchmarkresult">3936</td><td class="benchmarkresult">3878</td><td class="benchmarkresult">2341</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> str; ... str += str_var1 + str_var2;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstring2String(benchmark::State&amp; state) {
    stra s1 = TEXT_16;
    stra s2 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">525</td><td class="benchmarkresult">629</td><td class="benchmarkresult">850</td><td class="benchmarkresult">901</td><td class="benchmarkresult">1092</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;128> str; ... str += str_var1 + str_var2;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstring2String(benchmark::State&amp; state) {
    stra s1 = TEXT_16;
    stra s2 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">407</td><td class="benchmarkresult">534</td><td class="benchmarkresult">570</td><td class="benchmarkresult">625</td><td class="benchmarkresult">1047</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> str; ... str += str_var1 + str_var2;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstring2String(benchmark::State&amp; state) {
    stra s1 = TEXT_16;
    stra s2 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">378</td><td class="benchmarkresult">481</td><td class="benchmarkresult">399</td><td class="benchmarkresult">460</td><td class="benchmarkresult">880</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;1024> str; ... str += str_var1 + str_var2;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstring2String(benchmark::State&amp; state) {
    stra s1 = TEXT_16;
    stra s2 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">295</td><td class="benchmarkresult">426</td><td class="benchmarkresult">294</td><td class="benchmarkresult">361</td><td class="benchmarkresult">827</td></tr>
</tbody></table></div><script>bench_sets['Append 2 string of 16 bytes 32 times, 1024 total length'] = {id:'bs18', tests:[
{name:'std::stringstream str; ... str << str_var1 << str_var2;',data:[1421,1411,4447,5356,4459]},
{name:'std::string str; ... str += str_var1 + str_var2;',data:[1415,1351,3936,3878,2341]},
{name:'lstringa<16> str; ... str += str_var1 + str_var2;',data:[525,629,850,901,1092]},
{name:'lstringa<128> str; ... str += str_var1 + str_var2;',data:[407,534,570,625,1047]},
{name:'lstringa<512> str; ... str += str_var1 + str_var2;',data:[378,481,399,460,880]},
{name:'lstringa<1024> str; ... str += str_var1 + str_var2;',data:[295,426,294,361,827]}
]}</script>

<div class="benchset" id="bs19"><h4><a id="bs130432147582115154460" href="#bs130432147582115154460">#</a>&nbsp;Append text, number, text</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; str &lt;&lt; &quot;test = &quot; &lt;&lt; k &lt;&lt; &quot; times&quot;;<span class="tooltiptext code">void AppendStreamStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            std::stringstream t;
            t &lt;&lt; &quot;test = &quot; &lt;&lt; k &lt;&lt; &quot; times&quot;;
            std::string result = t.str();
        #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
        #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">3030</td><td class="benchmarkresult">3150</td><td class="benchmarkresult">10923</td><td class="benchmarkresult">11923</td><td class="benchmarkresult">6292</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str = &quot;test = &quot; + std::to_string(k) + &quot; times&quot;;<span class="tooltiptext code">void AppendStdStringStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            std::string result = &quot;test = &quot; + std::to_string(k) + &quot; times&quot;;
        #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
        #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">472</td><td class="benchmarkresult">450</td><td class="benchmarkresult">1115</td><td class="benchmarkresult">1282</td><td class="benchmarkresult">1584</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">char buf[100]; sprintf(buf, &quot;test = %u times&quot;, k); std::string str = buf;<span class="tooltiptext code">void AppendSprintfStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            char buf[100];
            std::sprintf(buf, &quot;test = %u times&quot;, k);
            std::string result = buf;
        #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
        #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">1385</td><td class="benchmarkresult">1533</td><td class="benchmarkresult">2844</td><td class="benchmarkresult">2869</td><td class="benchmarkresult">2954</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str = std::format(&quot;test = {} times&quot;, k);<span class="tooltiptext code">void AppendFormatStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            std::string result = std::format(&quot;test = {} times&quot;, k);
        #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
        #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">1120</td><td class="benchmarkresult">1277</td><td class="benchmarkresult">2010</td><td class="benchmarkresult">2463</td><td class="benchmarkresult">2106</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str; str.format(&quot;test = {} times&quot;, k);<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStrF(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result;
            result.format(&quot;test = {} times&quot;, k);
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">В simstr format с первого раза не помещается в такую строку без аллокации.</span></span></td><td class="benchmarkresult">1370</td><td class="benchmarkresult">1574</td><td class="benchmarkresult">2102</td><td class="benchmarkresult">2695</td><td class="benchmarkresult">3415</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;32> str; str.format(&quot;test = {} times&quot;, k);<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStrF(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result;
            result.format(&quot;test = {} times&quot;, k);
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А в такую помещается. Используйте сразу буфера подходящего размера.</span></span></td><td class="benchmarkresult">998</td><td class="benchmarkresult">1054</td><td class="benchmarkresult">1019</td><td class="benchmarkresult">1542</td><td class="benchmarkresult">2535</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str = &quot;test = &quot; + k + &quot; times&quot;;<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result = &quot;test = &quot;_ss + k + &quot; times&quot;;
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Результат не помещается в SSO, возникает аллокация.</span></span></td><td class="benchmarkresult">304</td><td class="benchmarkresult">324</td><td class="benchmarkresult">816</td><td class="benchmarkresult">920</td><td class="benchmarkresult">663</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;32> str = &quot;test = &quot; + k + &quot; times&quot;;<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result = &quot;test = &quot;_ss + k + &quot; times&quot;;
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А здесь и ниже - результат укладывается в SSO.
Ещё раз - используйте сразу буфера подходящего размера.</span></span></td><td class="benchmarkresult">156</td><td class="benchmarkresult">158</td><td class="benchmarkresult">158</td><td class="benchmarkresult">177</td><td class="benchmarkresult">376</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa str = &quot;test = &quot; + k + &quot; times&quot;;<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result = &quot;test = &quot;_ss + k + &quot; times&quot;;
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Под WASM размер SSO 15 символов, что явно не хватает для размещения
результата, отсюда и такое время.</span></span></td><td class="benchmarkresult">148</td><td class="benchmarkresult">172</td><td class="benchmarkresult">156</td><td class="benchmarkresult">241</td><td class="benchmarkresult">590</td></tr>
</tbody></table></div><script>bench_sets['Append text, number, text'] = {id:'bs19', tests:[
{name:'std::stringstream str; str << "test = " << k << " times";',data:[3030,3150,10923,11923,6292]},
{name:'std::string str = "test = " + std::to_string(k) + " times";',data:[472,450,1115,1282,1584]},
{name:'char buf[100]; sprintf(buf, "test = %u times", k); std::string str = buf;',data:[1385,1533,2844,2869,2954]},
{name:'std::string str = std::format("test = {} times", k);',data:[1120,1277,2010,2463,2106]},
{name:'lstringa<8> str; str.format("test = {} times", k);',data:[1370,1574,2102,2695,3415]},
{name:'lstringa<32> str; str.format("test = {} times", k);',data:[998,1054,1019,1542,2535]},
{name:'lstringa<8> str = "test = " + k + " times";',data:[304,324,816,920,663]},
{name:'lstringa<32> str = "test = " + k + " times";',data:[156,158,158,177,376]},
{name:'stringa str = "test = " + k + " times";',data:[148,172,156,241,590]}
]}</script>

<div class="benchset" id="bs20"><h4><a id="bs7106975351756760120" href="#bs7106975351756760120">#</a>&nbsp;Split text and convert to int</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string::find + substr + std::strtol<span class="tooltiptext code">void SplitConvertIntStdString(benchmark::State&amp; state) {
    std::string numbers = NUMBER_LIST;
    for (auto _: state) {
        int total = 0;
        for (size_t start = 0; start &lt; numbers.length(); ) {
            int delim = numbers.find(&quot;-!-&quot;, start);
            if (delim == std::string::npos) {
                delim = numbers.size();
            }
            std::string part = numbers.substr(start, delim - start);
            total += std::strtol(part.c_str(), nullptr, 0);
            start = delim + 3;
        }
    #ifdef CHECK_RESULT
        if (total != 218) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(total);
        benchmark::DoNotOptimize(numbers);
    }
}</span></span></td><td></td><td class="benchmarkresult">271</td><td class="benchmarkresult">276</td><td class="benchmarkresult">552</td><td class="benchmarkresult">554</td><td class="benchmarkresult">657</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa::splitter + ssa::as_int<span class="tooltiptext code">void SplitConvertIntSimStr(benchmark::State&amp; state) {
    stra numbers = NUMBER_LIST;
    for (auto _: state) {
        int total = 0;
        for (auto splitter = numbers.splitter(&quot;-!-&quot;); !splitter.is_done();) {
            total += splitter.next().as_int&lt;int>();
        }
    #ifdef CHECK_RESULT
        if (total != 218) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(total);
        benchmark::DoNotOptimize(numbers);
    }
}</span></span></td><td></td><td class="benchmarkresult">160</td><td class="benchmarkresult">135</td><td class="benchmarkresult">160</td><td class="benchmarkresult">297</td><td class="benchmarkresult">268</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa::splitf + functor<span class="tooltiptext code">void SplitConvertIntSplitf(benchmark::State&amp; state) {
    stra numbers = NUMBER_LIST;
    for (auto _: state) {
        int total = 0;
        numbers.splitf&lt;void>(&quot;-!-&quot;, [&amp;](ssa&amp; part){total += part.as_int&lt;int>();});
    #ifdef CHECK_RESULT
        if (total != 218) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(total);
        benchmark::DoNotOptimize(numbers);
    }
}</span></span></td><td></td><td class="benchmarkresult">209</td><td class="benchmarkresult">133</td><td class="benchmarkresult">194</td><td class="benchmarkresult">217</td><td class="benchmarkresult">363</td></tr>
</tbody></table></div><script>bench_sets['Split text and convert to int'] = {id:'bs20', tests:[
{name:'std::string::find + substr + std::strtol',data:[271,276,552,554,657]},
{name:'ssa::splitter + ssa::as_int',data:[160,135,160,297,268]},
{name:'ssa::splitf + functor',data:[209,133,194,217,363]}
]}</script>

<div class="benchset" id="bs21"><h4><a id="bs151373809886162287550" href="#bs151373809886162287550">#</a>&nbsp;Replace symbols in text ~400 symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Naive (and wrong) replace symbols with std::string find + replace<span class="tooltiptext code">void ReplaceSymbolsStdStringNaiveWrong(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;
    std::vector&lt;std::pair&lt;u8s, std::string_view>> repl = {
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;}
    };

    auto repl_all = [](std::string&amp; str, char s, std::string_view repl) {
        size_t start_pos = 0;
        while((start_pos = str.find(s, start_pos)) != std::string::npos) {
            str.replace(start_pos, 1, repl);
            start_pos += repl.length();
        }
    };
    for (auto _: state) {
        std::string result{source};
        for (const auto&amp; r : repl) {
            repl_all(result, r.first, r.second);
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Это наивная реализация, которая неверно отработает на
таких заменах, как 'a'->'b' и 'b'->'a'. Но если замены не конфликтуют,
то работает быстро.</span></span></td><td class="benchmarkresult">869</td><td class="benchmarkresult">869</td><td class="benchmarkresult">1167</td><td class="benchmarkresult">1268</td><td class="benchmarkresult">3169</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace symbols with std::string find_first_of + replace<span class="tooltiptext code">void ReplaceSymbolsStdStringNaiveRight(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;
    std::vector&lt;std::pair&lt;u8s, std::string_view>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        std::string result{source};
        std::string pattern;
        for (const auto&amp; r : repl) {
            pattern += r.first;
        }
        size_t start_pos = 0;
        while((start_pos = result.find_first_of(pattern, start_pos)) != std::string::npos) {
            size_t idx = pattern.find(result[start_pos]);
            result.replace(start_pos, 1, repl[idx].second);
            start_pos += repl[idx].second.length();
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Дальше уже правильные реализации, не зависящие от конфликтующих замен.</span></span></td><td class="benchmarkresult">2471</td><td class="benchmarkresult">2433</td><td class="benchmarkresult">2074</td><td class="benchmarkresult">2197</td><td class="benchmarkresult">3849</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace symbols with std::string_view find_first_of + copy<span class="tooltiptext code">void ReplaceSymbolsStdString(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    const std::string_view repl_from = &quot;-&lt;>&#39;\&quot;&amp;&quot;;
    const std::string_view repl_to[] = {&quot;&quot;, &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;#39;&quot;, &quot;&amp;quot;&quot;, &quot;&amp;amp;&quot;};

    for (auto _: state) {
        std::string result;

        for (size_t start = 0; start &lt; source.size();) {
            size_t idx = source.find_first_of(repl_from, start);
            if (idx == std::string::npos) {
                result += source.substr(start);
                break;
            }
            if (idx > start) {
                result += source.substr(start, idx - start);
            }
            size_t what = repl_from.find(source[idx]);
            result += repl_to[what];

            start = idx + 1;
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1126</td><td class="benchmarkresult">1034</td><td class="benchmarkresult">2342</td><td class="benchmarkresult">2593</td><td class="benchmarkresult">3068</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace runtime symbols with string expressions and without remembering all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ReplaceSymbolsDynPatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    std::vector&lt;std::pair&lt;u8s, ssa>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        stringa result = expr_replace_symbols&lt;u8s, UseVector>{source, repl};

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1289</td><td class="benchmarkresult">1444</td><td class="benchmarkresult">1412</td><td class="benchmarkresult">1510</td><td class="benchmarkresult">3137</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace runtime symbols with simstr and memorization of all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ReplaceSymbolsDynPatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    std::vector&lt;std::pair&lt;u8s, ssa>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        stringa result = expr_replace_symbols&lt;u8s, UseVector>{source, repl};

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">995</td><td class="benchmarkresult">1133</td><td class="benchmarkresult">1334</td><td class="benchmarkresult">1371</td><td class="benchmarkresult">2700</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace const symbols with string expressions and without remembering all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ReplaceSymbolsCons2PatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    for (auto _: state) {
        stringa result = e_repl_const_symbols&lt;UseVector>(source,
            &#39;-&#39;, &quot;&quot;,
            &#39;&lt;&#39;, &quot;&amp;lt;&quot;,
            &#39;>&#39;, &quot;&amp;gt;&quot;,
            &#39;\&#39;&#39;, &quot;&amp;#39;&quot;,
            &#39;\&quot;&#39;, &quot;&amp;quot;&quot;,
            &#39;&amp;&#39;, &quot;&amp;amp;&quot;
        );

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1142</td><td class="benchmarkresult">1357</td><td class="benchmarkresult">1210</td><td class="benchmarkresult">1386</td><td class="benchmarkresult">2493</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace const symbols with string expressions and memorization of all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ReplaceSymbolsCons2PatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    for (auto _: state) {
        stringa result = e_repl_const_symbols&lt;UseVector>(source,
            &#39;-&#39;, &quot;&quot;,
            &#39;&lt;&#39;, &quot;&amp;lt;&quot;,
            &#39;>&#39;, &quot;&amp;gt;&quot;,
            &#39;\&#39;&#39;, &quot;&amp;#39;&quot;,
            &#39;\&quot;&#39;, &quot;&amp;quot;&quot;,
            &#39;&amp;&#39;, &quot;&amp;amp;&quot;
        );

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">914</td><td class="benchmarkresult">916</td><td class="benchmarkresult">1232</td><td class="benchmarkresult">1284</td><td class="benchmarkresult">2297</td></tr>
</tbody></table></div><script>bench_sets['Replace symbols in text ~400 symbols'] = {id:'bs21', tests:[
{name:'Naive (and wrong) replace symbols with std::string find + replace',data:[869,869,1167,1268,3169]},
{name:'replace symbols with std::string find_first_of + replace',data:[2471,2433,2074,2197,3849]},
{name:'replace symbols with std::string_view find_first_of + copy',data:[1126,1034,2342,2593,3068]},
{name:'replace runtime symbols with string expressions and without remembering all search results',data:[1289,1444,1412,1510,3137]},
{name:'replace runtime symbols with simstr and memorization of all search results',data:[995,1133,1334,1371,2700]},
{name:'replace const symbols with string expressions and without remembering all search results',data:[1142,1357,1210,1386,2493]},
{name:'replace const symbols with string expressions and memorization of all search results',data:[914,916,1232,1284,2297]}
]}</script>

<div class="benchset" id="bs22"><h4><a id="bs96756339547767401190" href="#bs96756339547767401190">#</a>&nbsp;Replace symbols in text ~40 symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Short Naive (and wrong) replace symbols with std::string find + replace<span class="tooltiptext code">void ShortReplaceSymbolsStdStringNaiveWrong(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;
    std::vector&lt;std::pair&lt;u8s, std::string_view>> repl = {
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;}
    };

    auto repl_all = [](std::string&amp; str, char s, std::string_view repl) {
        size_t start_pos = 0;
        while((start_pos = str.find(s, start_pos)) != std::string::npos) {
            str.replace(start_pos, 1, repl);
            start_pos += repl.length();
        }
    };
    for (auto _: state) {
        std::string result{source};
        for (const auto&amp; r : repl) {
            repl_all(result, r.first, r.second);
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">164</td><td class="benchmarkresult">165</td><td class="benchmarkresult">318</td><td class="benchmarkresult">339</td><td class="benchmarkresult">452</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace symbols with std::string find_first_of + replace<span class="tooltiptext code">void ShortReplaceSymbolsStdStringNaiveRight(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;
    std::vector&lt;std::pair&lt;u8s, std::string_view>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        std::string result{source};
        std::string pattern;
        for (const auto&amp; r : repl) {
            pattern += r.first;
        }
        size_t start_pos = 0;
        while((start_pos = result.find_first_of(pattern, start_pos)) != std::string::npos) {
            size_t idx = pattern.find(result[start_pos]);
            result.replace(start_pos, 1, repl[idx].second);
            start_pos += repl[idx].second.length();
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">318</td><td class="benchmarkresult">321</td><td class="benchmarkresult">378</td><td class="benchmarkresult">438</td><td class="benchmarkresult">517</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace symbols with std::string_view find_first_of + copy<span class="tooltiptext code">void ShortReplaceSymbolsStdString(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    const std::string_view repl_from = &quot;-&lt;>&#39;\&quot;&amp;&quot;;
    const std::string_view repl_to[] = {&quot;&quot;, &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;#39;&quot;, &quot;&amp;quot;&quot;, &quot;&amp;amp;&quot;};

    for (auto _: state) {
        std::string result;

        for (size_t start = 0; start &lt; source.size();) {
            size_t idx = source.find_first_of(repl_from, start);
            if (idx == std::string::npos) {
                result += source.substr(start);
                break;
            }
            if (idx > start) {
                result += source.substr(start, idx - start);
            }
            size_t what = repl_from.find_first_of(source[idx]);
            result += repl_to[what];

            start = idx + 1;
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">170</td><td class="benchmarkresult">160</td><td class="benchmarkresult">321</td><td class="benchmarkresult">357</td><td class="benchmarkresult">389</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace runtime symbols with string expressions and without remembering all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ShortReplaceSymbolsDynPatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    std::vector&lt;std::pair&lt;u8s, ssa>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        stringa result = expr_replace_symbols&lt;u8s, UseVector>{source, repl};

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">166</td><td class="benchmarkresult">191</td><td class="benchmarkresult">256</td><td class="benchmarkresult">277</td><td class="benchmarkresult">346</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace runtime symbols with simstr and memorization of all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ShortReplaceSymbolsDynPatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    std::vector&lt;std::pair&lt;u8s, ssa>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        stringa result = expr_replace_symbols&lt;u8s, UseVector>{source, repl};

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">181</td><td class="benchmarkresult">188</td><td class="benchmarkresult">354</td><td class="benchmarkresult">377</td><td class="benchmarkresult">370</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace const symbols with string expressions and without remembering all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ShortReplaceSymbolsCons2PatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    for (auto _: state) {
        stringa result = e_repl_const_symbols&lt;UseVector>(source,
            &#39;-&#39;, &quot;&quot;,
            &#39;&lt;&#39;, &quot;&amp;lt;&quot;,
            &#39;>&#39;, &quot;&amp;gt;&quot;,
            &#39;\&#39;&#39;, &quot;&amp;#39;&quot;,
            &#39;\&quot;&#39;, &quot;&amp;quot;&quot;,
            &#39;&amp;&#39;, &quot;&amp;amp;&quot;
        );

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">141</td><td class="benchmarkresult">158</td><td class="benchmarkresult">214</td><td class="benchmarkresult">320</td><td class="benchmarkresult">252</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace const symbols with string expressions and memorization of all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ShortReplaceSymbolsCons2PatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    for (auto _: state) {
        stringa result = e_repl_const_symbols&lt;UseVector>(source,
            &#39;-&#39;, &quot;&quot;,
            &#39;&lt;&#39;, &quot;&amp;lt;&quot;,
            &#39;>&#39;, &quot;&amp;gt;&quot;,
            &#39;\&#39;&#39;, &quot;&amp;#39;&quot;,
            &#39;\&quot;&#39;, &quot;&amp;quot;&quot;,
            &#39;&amp;&#39;, &quot;&amp;amp;&quot;
        );

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">152</td><td class="benchmarkresult">158</td><td class="benchmarkresult">325</td><td class="benchmarkresult">367</td><td class="benchmarkresult">312</td></tr>
</tbody></table></div><script>bench_sets['Replace symbols in text ~40 symbols'] = {id:'bs22', tests:[
{name:'Short Naive (and wrong) replace symbols with std::string find + replace',data:[164,165,318,339,452]},
{name:'Short replace symbols with std::string find_first_of + replace',data:[318,321,378,438,517]},
{name:'Short replace symbols with std::string_view find_first_of + copy',data:[170,160,321,357,389]},
{name:'Short replace runtime symbols with string expressions and without remembering all search results',data:[166,191,256,277,346]},
{name:'Short replace runtime symbols with simstr and memorization of all search results',data:[181,188,354,377,370]},
{name:'Short replace const symbols with string expressions and without remembering all search results',data:[141,158,214,320,252]},
{name:'Short replace const symbols with string expressions and memorization of all search results',data:[152,158,325,367,312]}
]}</script>

<div class="benchset" id="bs23"><h4><a id="bs77745698784557935900" href="#bs77745698784557935900">#</a>&nbsp;Replace All Str To Longer Size</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|64<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">160</td><td class="benchmarkresult">158</td><td class="benchmarkresult">229</td><td class="benchmarkresult">254</td><td class="benchmarkresult">376</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|256<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">539</td><td class="benchmarkresult">527</td><td class="benchmarkresult">771</td><td class="benchmarkresult">834</td><td class="benchmarkresult">1382</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|512<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1033</td><td class="benchmarkresult">986</td><td class="benchmarkresult">1450</td><td class="benchmarkresult">1579</td><td class="benchmarkresult">2720</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|1024<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">2264</td><td class="benchmarkresult">2333</td><td class="benchmarkresult">3198</td><td class="benchmarkresult">3287</td><td class="benchmarkresult">5616</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|2048<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">5783</td><td class="benchmarkresult">5714</td><td class="benchmarkresult">7933</td><td class="benchmarkresult">8270</td><td class="benchmarkresult">13498</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|64<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">148</td><td class="benchmarkresult">165</td><td class="benchmarkresult">327</td><td class="benchmarkresult">345</td><td class="benchmarkresult">348</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|256<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">441</td><td class="benchmarkresult">492</td><td class="benchmarkresult">649</td><td class="benchmarkresult">678</td><td class="benchmarkresult">1080</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|512<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">792</td><td class="benchmarkresult">943</td><td class="benchmarkresult">1080</td><td class="benchmarkresult">1152</td><td class="benchmarkresult">1910</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|1024<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1579</td><td class="benchmarkresult">1820</td><td class="benchmarkresult">1950</td><td class="benchmarkresult">2059</td><td class="benchmarkresult">3848</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|2048<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">2967</td><td class="benchmarkresult">3513</td><td class="benchmarkresult">3614</td><td class="benchmarkresult">3994</td><td class="benchmarkresult">7361</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|64<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">115</td><td class="benchmarkresult">143</td><td class="benchmarkresult">207</td><td class="benchmarkresult">219</td><td class="benchmarkresult">260</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|256<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">431</td><td class="benchmarkresult">457</td><td class="benchmarkresult">571</td><td class="benchmarkresult">550</td><td class="benchmarkresult">1001</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|512<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">808</td><td class="benchmarkresult">910</td><td class="benchmarkresult">992</td><td class="benchmarkresult">985</td><td class="benchmarkresult">1949</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|1024<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1610</td><td class="benchmarkresult">1822</td><td class="benchmarkresult">1844</td><td class="benchmarkresult">1893</td><td class="benchmarkresult">3872</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|2048<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">3105</td><td class="benchmarkresult">3562</td><td class="benchmarkresult">3456</td><td class="benchmarkresult">3554</td><td class="benchmarkresult">7745</td></tr>
</tbody></table></div><script>bench_sets['Replace All Str To Longer Size'] = {id:'bs23', tests:[
{name:'replace bb to ---- in std::string|64',data:[160,158,229,254,376]},
{name:'replace bb to ---- in std::string|256',data:[539,527,771,834,1382]},
{name:'replace bb to ---- in std::string|512',data:[1033,986,1450,1579,2720]},
{name:'replace bb to ---- in std::string|1024',data:[2264,2333,3198,3287,5616]},
{name:'replace bb to ---- in std::string|2048',data:[5783,5714,7933,8270,13498]},
{name:'replace bb to ---- in lstringa<8>|64',data:[148,165,327,345,348]},
{name:'replace bb to ---- in lstringa<8>|256',data:[441,492,649,678,1080]},
{name:'replace bb to ---- in lstringa<8>|512',data:[792,943,1080,1152,1910]},
{name:'replace bb to ---- in lstringa<8>|1024',data:[1579,1820,1950,2059,3848]},
{name:'replace bb to ---- in lstringa<8>|2048',data:[2967,3513,3614,3994,7361]},
{name:'replace bb to ---- by init stringa|64',data:[115,143,207,219,260]},
{name:'replace bb to ---- by init stringa|256',data:[431,457,571,550,1001]},
{name:'replace bb to ---- by init stringa|512',data:[808,910,992,985,1949]},
{name:'replace bb to ---- by init stringa|1024',data:[1610,1822,1844,1893,3872]},
{name:'replace bb to ---- by init stringa|2048',data:[3105,3562,3456,3554,7745]}
]}</script>

<div class="benchset" id="bs24"><h4><a id="bs74494088982050398630" href="#bs74494088982050398630">#</a>&nbsp;Replace All Str To Same Size</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|64<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">120</td><td class="benchmarkresult">128</td><td class="benchmarkresult">201</td><td class="benchmarkresult">209</td><td class="benchmarkresult">264</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|256<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">438</td><td class="benchmarkresult">391</td><td class="benchmarkresult">480</td><td class="benchmarkresult">535</td><td class="benchmarkresult">991</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|512<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">849</td><td class="benchmarkresult">724</td><td class="benchmarkresult">890</td><td class="benchmarkresult">954</td><td class="benchmarkresult">1955</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|1024<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1615</td><td class="benchmarkresult">1389</td><td class="benchmarkresult">1622</td><td class="benchmarkresult">1818</td><td class="benchmarkresult">3776</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|2048<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">3124</td><td class="benchmarkresult">2877</td><td class="benchmarkresult">3277</td><td class="benchmarkresult">3510</td><td class="benchmarkresult">7264</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|64<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">98.8</td><td class="benchmarkresult">102</td><td class="benchmarkresult">185</td><td class="benchmarkresult">190</td><td class="benchmarkresult">222</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|256<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">297</td><td class="benchmarkresult">306</td><td class="benchmarkresult">439</td><td class="benchmarkresult">435</td><td class="benchmarkresult">789</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|512<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">564</td><td class="benchmarkresult">546</td><td class="benchmarkresult">766</td><td class="benchmarkresult">763</td><td class="benchmarkresult">1491</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|1024<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1117</td><td class="benchmarkresult">1098</td><td class="benchmarkresult">1441</td><td class="benchmarkresult">1440</td><td class="benchmarkresult">2864</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|2048<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">2554</td><td class="benchmarkresult">2087</td><td class="benchmarkresult">2680</td><td class="benchmarkresult">2726</td><td class="benchmarkresult">5689</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|64<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">84.4</td><td class="benchmarkresult">112</td><td class="benchmarkresult">161</td><td class="benchmarkresult">178</td><td class="benchmarkresult">187</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|256<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">245</td><td class="benchmarkresult">282</td><td class="benchmarkresult">361</td><td class="benchmarkresult">399</td><td class="benchmarkresult">675</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|512<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">441</td><td class="benchmarkresult">525</td><td class="benchmarkresult">602</td><td class="benchmarkresult">662</td><td class="benchmarkresult">1230</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|1024<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">888</td><td class="benchmarkresult">1040</td><td class="benchmarkresult">1122</td><td class="benchmarkresult">1201</td><td class="benchmarkresult">2380</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|2048<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1672</td><td class="benchmarkresult">1998</td><td class="benchmarkresult">2077</td><td class="benchmarkresult">2293</td><td class="benchmarkresult">4667</td></tr>
</tbody></table></div><script>bench_sets['Replace All Str To Same Size'] = {id:'bs24', tests:[
{name:'replace bb to -- in std::string|64',data:[120,128,201,209,264]},
{name:'replace bb to -- in std::string|256',data:[438,391,480,535,991]},
{name:'replace bb to -- in std::string|512',data:[849,724,890,954,1955]},
{name:'replace bb to -- in std::string|1024',data:[1615,1389,1622,1818,3776]},
{name:'replace bb to -- in std::string|2048',data:[3124,2877,3277,3510,7264]},
{name:'replace bb to -- in lstringa<8>|64',data:[98.8,102,185,190,222]},
{name:'replace bb to -- in lstringa<8>|256',data:[297,306,439,435,789]},
{name:'replace bb to -- in lstringa<8>|512',data:[564,546,766,763,1491]},
{name:'replace bb to -- in lstringa<8>|1024',data:[1117,1098,1441,1440,2864]},
{name:'replace bb to -- in lstringa<8>|2048',data:[2554,2087,2680,2726,5689]},
{name:'replace bb to -- by init stringa|64',data:[84.4,112,161,178,187]},
{name:'replace bb to -- by init stringa|256',data:[245,282,361,399,675]},
{name:'replace bb to -- by init stringa|512',data:[441,525,602,662,1230]},
{name:'replace bb to -- by init stringa|1024',data:[888,1040,1122,1201,2380]},
{name:'replace bb to -- by init stringa|2048',data:[1672,1998,2077,2293,4667]}
]}</script>

<div class="benchset" id="bs25"><h4><a id="bs8410196985047277720" href="#bs8410196985047277720">#</a>&nbsp;Hash Map insert and find</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">hashStrMapA&lt;size_t> emplace &amp; find stringa;<span class="tooltiptext code">void HashMapSimStr(benchmark::State&amp; state) {
    for (auto _: state) {
        hashStrMapA&lt;size_t> store;
        for (size_t idx = 0; idx &lt; bs_sim.size(); idx++) {
            store.try_emplace(bs_sim[idx], idx);
        }
#ifdef CHECK_RESULT
        if (store.size() != bs_sim.size()) {
            state.SkipWithError(&quot;bad inserts&quot;);
        }
#endif
        for (size_t idx = 0; idx &lt; bs_sim.size(); idx++) {
            auto find = store.find(bs_sim[idx]);
            size_t res = find->second;
#ifdef CHECK_RESULT
            if (res != idx) {
                state.SkipWithError(&quot;bad find&quot;);
            }
#endif
            benchmark::DoNotOptimize(res);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Вставляем в hashStrMapA 10000 stringa длиной от 30 до 50
символов, а потом ищем их в ней</span></span></td><td class="benchmarkresult">3851662</td><td class="benchmarkresult">3777212</td><td class="benchmarkresult">3811336</td><td class="benchmarkresult">4241420</td><td class="benchmarkresult">3087513</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::unordered_map&lt;std::string, size_t> emplace &amp; find std::string;<span class="tooltiptext code">void HashMapStdStr(benchmark::State&amp; state) {
    for (auto _: state) {
        std::unordered_map&lt;std::string, size_t> store;
        for (size_t idx = 0; idx &lt; bs_std.size(); idx++) {
            store.try_emplace(bs_std[idx], idx);
        }
#ifdef CHECK_RESULT
        if (store.size() != bs_std.size()) {
            state.SkipWithError(&quot;bad inserts&quot;);
        }
#endif
        for (size_t idx = 0; idx &lt; bs_std.size(); idx++) {
            auto find = store.find(bs_std[idx]);
            size_t res = find->second;
#ifdef CHECK_RESULT
            if (res != idx) {
                state.SkipWithError(&quot;bad find&quot;);
            }
#endif
            benchmark::DoNotOptimize(res);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">То же самое c std::string и std::unordered_map</span></span></td><td class="benchmarkresult">3532980</td><td class="benchmarkresult">3699471</td><td class="benchmarkresult">5464472</td><td class="benchmarkresult">5380945</td><td class="benchmarkresult">3374437</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">hashStrMapA&lt;size_t> emplace &amp; find ssa;<span class="tooltiptext code">void HashMapSimSsa(benchmark::State&amp; state) {
    for (auto _: state) {
        hashStrMapA&lt;size_t> store;
        for (size_t idx = 0; idx &lt; bs_sim.size(); idx++) {
            store.emplace(bs_sim[idx], idx);
        }
#ifdef CHECK_RESULT
        if (store.size() != bs_sim.size()) {
            state.SkipWithError(&quot;bad inserts&quot;);
        }
#endif
        for (size_t idx = 0; idx &lt; bs_sim.size(); idx++) {
            ssa key = bs_sim[idx];
            auto find = store.find(key);
            size_t res = find->second;
#ifdef CHECK_RESULT
            if (res != idx) {
                state.SkipWithError(&quot;bad find&quot;);
            }
#endif
            benchmark::DoNotOptimize(res);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Теперь вставляем stringa, а ищем ssa</span></span></td><td class="benchmarkresult">3864988</td><td class="benchmarkresult">3813629</td><td class="benchmarkresult">3495700</td><td class="benchmarkresult">3970765</td><td class="benchmarkresult">3094176</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::unordered_map&lt;std::string, size_t> emplace &amp; find std::string_view;<span class="tooltiptext code">void HashMapStdStrView(benchmark::State&amp; state) {
    for (auto _: state) {
        std::unordered_map&lt;std::string, size_t> store;
        for (size_t idx = 0; idx &lt; bs_std.size(); idx++) {
            store.emplace(bs_std[idx], idx);
        }
#ifdef CHECK_RESULT
        if (store.size() != bs_std.size()) {
            state.SkipWithError(&quot;bad inserts&quot;);
        }
#endif
        for (size_t idx = 0; idx &lt; bs_std.size(); idx++) {
            std::string_view key = bs_std[idx];
            auto find = store.find(std::string{key});
            size_t res = find->second;
#ifdef CHECK_RESULT
            if (res != idx) {
                state.SkipWithError(&quot;bad find&quot;);
            }
#endif
            benchmark::DoNotOptimize(res);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Вставляем std::string, а ищем std::string_view</span></span></td><td class="benchmarkresult">4210033</td><td class="benchmarkresult">4166492</td><td class="benchmarkresult">6874367</td><td class="benchmarkresult">6424592</td><td class="benchmarkresult">3767333</td></tr>
</tbody></table></div><script>bench_sets['Hash Map insert and find'] = {id:'bs25', tests:[
{name:'hashStrMapA<size_t> emplace & find stringa;',data:[3851662,3777212,3811336,4241420,3087513]},
{name:'std::unordered_map<std::string, size_t> emplace & find std::string;',data:[3532980,3699471,5464472,5380945,3374437]},
{name:'hashStrMapA<size_t> emplace & find ssa;',data:[3864988,3813629,3495700,3970765,3094176]},
{name:'std::unordered_map<std::string, size_t> emplace & find std::string_view;',data:[4210033,4166492,6874367,6424592,3767333]}
]}</script>

<div class="benchset" id="bs26"><h4><a id="bs131384792586914680410" href="#bs131384792586914680410">#</a>&nbsp;Build Full Func Name</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name std::string;<span class="tooltiptext code">std::string build_full_name_std() const {
    std::string str{has_ret_type_resolver ? &quot;any&quot;sv : type_names_sv[(unsigned)ret_type]};
    str += &quot; &quot;;
    str += std_name;
    str += &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        if (add_comma) {
            str += &quot;, &quot;;
        }
        if (param.optional) {
            str += &quot;[&quot;;
        }
        param.allowed_types.to_stdstr(str);
        if (param.optional) {
            str += &quot;]&quot;;
        }
        add_comma = true;
    }
    if (unlim_params) {
        if (add_comma) {
            str += &quot;, &quot;;
        }
        str += &quot;...&quot;;
    }
    str += &quot;)&quot;;
    //std::cout &lt;&lt; &quot;Len=&quot; &lt;&lt; str.length() &lt;&lt; &quot;, Cap=&quot; &lt;&lt; str.capacity() &lt;&lt; &quot;\n&quot;;
    return str;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Обыденная задача, подобные часто могут встретится в работе:
По неким данным сгенерировать текст. В этом случае по данным
о неких функциях сформировать их полное имя с типами параметров и
возвращаемого значения. Алгоритм на std::string.</span></span></td><td class="benchmarkresult">703</td><td class="benchmarkresult">955</td><td class="benchmarkresult">1649</td><td class="benchmarkresult">1696</td><td class="benchmarkresult">2896</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name std::string 1;<span class="tooltiptext code">std::string build_full_name_std1() const {
    std::string str{has_ret_type_resolver ? &quot;any&quot;sv : type_names_sv[(unsigned)ret_type]};
    str += &quot; &quot; + std_name + &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        if (add_comma) {
            str += &quot;, &quot;;
        }
        if (param.optional) {
            str += &quot;[&quot;;
        }
        param.allowed_types.to_stdstr(str);
        if (param.optional) {
            str += &quot;]&quot;;
        }
        add_comma = true;
    }
    if (unlim_params) {
        if (add_comma) {
            str += &quot;, &quot;;
        }
        str += &quot;...&quot;;
    }
    str += &quot;)&quot;;
    //std::cout &lt;&lt; &quot;Len=&quot; &lt;&lt; str.length() &lt;&lt; &quot;, Cap=&quot; &lt;&lt; str.capacity() &lt;&lt; &quot;\n&quot;;
    return str;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Почти тот же алгоритм, но несколько последовательных
+= к строке заменены на одно += + + +.</span></span></td><td class="benchmarkresult">834</td><td class="benchmarkresult">1026</td><td class="benchmarkresult">1680</td><td class="benchmarkresult">1752</td><td class="benchmarkresult">3035</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name std::stream;<span class="tooltiptext code">std::string build_full_name_stream() const {
    std::ostringstream str;
    if (has_ret_type_resolver) {
        str &lt;&lt; &quot;any&quot;;
    } else {
        str &lt;&lt; type_names_sv[(unsigned)ret_type];
    }
    str &lt;&lt; &quot; &quot; &lt;&lt; std_name &lt;&lt; &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        if (add_comma) {
            str &lt;&lt; &quot;, &quot;;
        }
        if (param.optional) {
            str &lt;&lt; &quot;[&quot;;
        }
        param.allowed_types.to_stream(str);
        if (param.optional) {
            str &lt;&lt; &quot;]&quot;;
        }
        add_comma = true;
    }
    if (unlim_params) {
        if (add_comma) {
            str &lt;&lt; &quot;, &quot;;
        }
        str &lt;&lt; &quot;...&quot;;
    }
    str &lt;&lt; &quot;)&quot;;
    return str.str();
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Строим имя функции через std::ostringstream и <<</span></span></td><td class="benchmarkresult">2619</td><td class="benchmarkresult">2655</td><td class="benchmarkresult">8347</td><td class="benchmarkresult">9835</td><td class="benchmarkresult">6843</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name stringa;<span class="tooltiptext code">stringa build_full_name() const {
    lstringa&lt;512> str = e_choice(has_ret_type_resolver, &quot;any&quot;, type_names[(unsigned)ret_type]) + &quot; &quot; + name + &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        str += e_if(add_comma, &quot;, &quot;) + e_if(param.optional, &quot;[&quot;);
        param.allowed_types.to_simstr(str);
        if (param.optional) {
            str += &quot;]&quot;;
        }
        add_comma = true;
    }
    return str + e_if(unlim_params, e_if(add_comma, &quot;, &quot;) + &quot;...&quot;) + &quot;)&quot;;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Реализация на simstr строках и строковых выражениях.
Инфа о параметрах добавляется в текущую строку</span></span></td><td class="benchmarkresult">522</td><td class="benchmarkresult">595</td><td class="benchmarkresult">875</td><td class="benchmarkresult">907</td><td class="benchmarkresult">1396</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name stringa 1;<span class="tooltiptext code">stringa build_full_name1() const {
    lstringa&lt;512> str = e_choice(has_ret_type_resolver, &quot;any&quot;, type_names[(unsigned)ret_type]) + &quot; &quot; + name + &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        str += e_if(add_comma, &quot;, &quot;) + e_if(param.optional, &quot;[&quot;) + param.allowed_types.get_simstr() + e_if(param.optional, &quot;]&quot;);
        add_comma = true;
    }
    return str + e_if(unlim_params, e_if(add_comma, &quot;, &quot;) + &quot;...&quot;) + &quot;)&quot;;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Реализация на simstr строках и строковых выражениях.
Инфа о параметрах добавляется во временную строку, а потом
разом добавляется в текущую строку. Позволяет операции в цикле
записать в одну строку, но чуть проигрывает по времени выполнения.</span></span></td><td class="benchmarkresult">680</td><td class="benchmarkresult">668</td><td class="benchmarkresult">1012</td><td class="benchmarkresult">1033</td><td class="benchmarkresult">1640</td></tr>
</tbody></table></div><script>bench_sets['Build Full Func Name'] = {id:'bs26', tests:[
{name:'Build func full name std::string;',data:[703,955,1649,1696,2896]},
{name:'Build func full name std::string 1;',data:[834,1026,1680,1752,3035]},
{name:'Build func full name std::stream;',data:[2619,2655,8347,9835,6843]},
{name:'Build func full name stringa;',data:[522,595,875,907,1396]},
{name:'Build func full name stringa 1;',data:[680,668,1012,1033,1640]}
]}</script></body></html>
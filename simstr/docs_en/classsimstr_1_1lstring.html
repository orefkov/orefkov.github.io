<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: simstr::lstring&lt; K, N, forShared, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.6.4</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsimstr_1_1lstring.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsimstr_1_1lstring-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simstr::lstring&lt; K, N, forShared, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The mutable, owning string class. Contains an internal buffer for text of a given size.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sstring_8h_source.html">sstring.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for simstr::lstring&lt; K, N, forShared, Allocator &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsimstr_1_1lstring.png" usemap="#simstr::lstring_3C_20K_2C_20N_2C_20forShared_2C_20Allocator_20_3E_map" alt=""/>
  <map id="simstr::lstring_3C_20K_2C_20N_2C_20forShared_2C_20Allocator_20_3E_map" name="simstr::lstring_3C_20K_2C_20N_2C_20forShared_2C_20Allocator_20_3E_map">
<area href="classsimstr_1_1str__algs.html" alt="simstr::str_algs&lt; K, simple_str&lt; K &gt;, lstring&lt; K, N, false, allocator_string &gt;, true &gt;" shape="rect" coords="0,56,527,80"/>
<area href="classsimstr_1_1str__mutable.html" alt="simstr::str_mutable&lt; K, lstring&lt; K, N, false, allocator_string &gt; &gt;" shape="rect" coords="537,56,1064,80"/>
<area href="classsimstr_1_1str__storable.html" alt="simstr::str_storable&lt; K, lstring&lt; K, N, false, allocator_string &gt;, allocator_string &gt;" shape="rect" coords="1074,56,1601,80"/>
<area href="classsimstr_1_1from__utf__convertible.html" alt="simstr::from_utf_convertible&lt; K, lstring&lt; K, N, false, allocator_string &gt; &gt;" shape="rect" coords="1611,56,2138,80"/>
<area href="classsimstr_1_1str__src__algs.html" alt="simstr::str_src_algs&lt; K, simple_str&lt; K &gt;, lstring&lt; K, N, false, allocator_string &gt;, Mutable &gt;" shape="rect" coords="0,0,527,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2be8d42ca8175c4b1a92e27b980909a0" id="r_a2be8d42ca8175c4b1a92e27b980909a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: size_t { <a class="el" href="#a2be8d42ca8175c4b1a92e27b980909a0ae0156729d0c9b54b6917deaf5b6c30c0">LocalCapacity</a> = N | (sizeof(void*) / sizeof(K) - 1)
 }</td></tr>
<tr class="separator:a2be8d42ca8175c4b1a92e27b980909a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afdd649b8fc867ee9b324691920680575" id="r_afdd649b8fc867ee9b324691920680575"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (std::is_constructible_v&lt;allocator_t, Args...&gt; &amp;&amp; sizeof...(Args) &gt; 0)</td></tr>
<tr class="memitem:afdd649b8fc867ee9b324691920680575"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdd649b8fc867ee9b324691920680575">lstring</a> (Args &amp;&amp;... args) noexcept(std::is_nothrow_constructible_v&lt; allocator_t, Args... &gt;)</td></tr>
<tr class="memdesc:afdd649b8fc867ee9b324691920680575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty object.  <br /></td></tr>
<tr class="separator:afdd649b8fc867ee9b324691920680575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5503d97a198725d593e3518d159d3e" id="r_a5e5503d97a198725d593e3518d159d3e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a5e5503d97a198725d593e3518d159d3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e5503d97a198725d593e3518d159d3e">lstring</a> (<a class="el" href="structsimstr_1_1simple__str.html">s_str</a> other, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5e5503d97a198725d593e3518d159d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor from another string object.  <br /></td></tr>
<tr class="separator:a5e5503d97a198725d593e3518d159d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a16988e9dffa98991caca6d5a9d99b" id="r_a70a16988e9dffa98991caca6d5a9d99b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a70a16988e9dffa98991caca6d5a9d99b"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70a16988e9dffa98991caca6d5a9d99b">lstring</a> (size_t repeat, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a70a16988e9dffa98991caca6d5a9d99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">String repetition constructor.  <br /></td></tr>
<tr class="separator:a70a16988e9dffa98991caca6d5a9d99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fcf7732a4c93309d5ba65e131e8e94" id="r_ac8fcf7732a4c93309d5ba65e131e8e94"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:ac8fcf7732a4c93309d5ba65e131e8e94"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8fcf7732a4c93309d5ba65e131e8e94">lstring</a> (size_t count, K pad, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac8fcf7732a4c93309d5ba65e131e8e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character repetition constructor.  <br /></td></tr>
<tr class="separator:ac8fcf7732a4c93309d5ba65e131e8e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0896628d4b9c09f66c524431218d07" id="r_acb0896628d4b9c09f66c524431218d07"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:acb0896628d4b9c09f66c524431218d07"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb0896628d4b9c09f66c524431218d07">lstring</a> (const StrExprForType&lt; K &gt; auto &amp;expr, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acb0896628d4b9c09f66c524431218d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a string expression.  <br /></td></tr>
<tr class="separator:acb0896628d4b9c09f66c524431218d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce0cd4e01e1fa526be905447e5913ea" id="r_a6ce0cd4e01e1fa526be905447e5913ea"><td class="memTemplParams" colspan="2">template&lt;StrType&lt; K &gt; From, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a6ce0cd4e01e1fa526be905447e5913ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ce0cd4e01e1fa526be905447e5913ea">lstring</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6ce0cd4e01e1fa526be905447e5913ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from string source with replacement.  <br /></td></tr>
<tr class="separator:a6ce0cd4e01e1fa526be905447e5913ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b7f519594ae1b6a50b4b977cdd7969" id="r_a71b7f519594ae1b6a50b4b977cdd7969"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71b7f519594ae1b6a50b4b977cdd7969">lstring</a> (const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;other)</td></tr>
<tr class="memdesc:a71b7f519594ae1b6a50b4b977cdd7969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from another string of the same type.  <br /></td></tr>
<tr class="separator:a71b7f519594ae1b6a50b4b977cdd7969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b8a2a5ca5a73407148cf67efac0e69" id="r_a71b8a2a5ca5a73407148cf67efac0e69"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (sizeof...(Args) &gt; 0 &amp;&amp; std::is_convertible_v&lt;allocator_t, Args...&gt;)</td></tr>
<tr class="memitem:a71b8a2a5ca5a73407148cf67efac0e69"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71b8a2a5ca5a73407148cf67efac0e69">lstring</a> (const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;other, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a71b8a2a5ca5a73407148cf67efac0e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from another string of the same type, but with a different allocator.  <br /></td></tr>
<tr class="separator:a71b8a2a5ca5a73407148cf67efac0e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233aaa30d88d5c157f6f4a4dec31f499" id="r_a233aaa30d88d5c157f6f4a4dec31f499"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t I = const_lit_for&lt;K, T&gt;::Count, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a233aaa30d88d5c157f6f4a4dec31f499"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a233aaa30d88d5c157f6f4a4dec31f499">lstring</a> (T &amp;&amp;value, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a233aaa30d88d5c157f6f4a4dec31f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">String literal constructor.  <br /></td></tr>
<tr class="separator:a233aaa30d88d5c157f6f4a4dec31f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae595139d39bbb592c5e83139bef914cc" id="r_ae595139d39bbb592c5e83139bef914cc"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae595139d39bbb592c5e83139bef914cc">lstring</a> (<a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ae595139d39bbb592c5e83139bef914cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for moving from a string of the same type.  <br /></td></tr>
<tr class="separator:ae595139d39bbb592c5e83139bef914cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8590b10bbfc4eb95a53a575bff2221f" id="r_ab8590b10bbfc4eb95a53a575bff2221f"><td class="memTemplParams" colspan="2">template&lt;typename Op, typename... Args&gt; <br />
requires (std::is_constructible_v&lt;Allocator, Args...&gt; &amp;&amp; (std::is_invocable_v&lt;Op, <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&amp;&gt; || std::is_invocable_v&lt;Op, K*, size_t&gt;))</td></tr>
<tr class="memitem:ab8590b10bbfc4eb95a53a575bff2221f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8590b10bbfc4eb95a53a575bff2221f">lstring</a> (const Op &amp;op, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab8590b10bbfc4eb95a53a575bff2221f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fill constructor using a functor (see <a class="el" href="classsimstr_1_1str__mutable.html#a53aa57efa783f3d9484a4c9b09bd4f70" title="Fill a string buffer using a functor.">str_mutable::fill</a>).  <br /></td></tr>
<tr class="separator:ab8590b10bbfc4eb95a53a575bff2221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19f351477923bb3ca090955866e4315" id="r_ab19f351477923bb3ca090955866e4315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19f351477923bb3ca090955866e4315">operator=</a> (const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;other)</td></tr>
<tr class="memdesc:ab19f351477923bb3ca090955866e4315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator from a string of the same type.  <br /></td></tr>
<tr class="separator:ab19f351477923bb3ca090955866e4315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dda5e47ad2a1aba0861c7b1179a2e0" id="r_a44dda5e47ad2a1aba0861c7b1179a2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44dda5e47ad2a1aba0861c7b1179a2e0">operator=</a> (<a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a44dda5e47ad2a1aba0861c7b1179a2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator by moving from a string of the same type.  <br /></td></tr>
<tr class="separator:a44dda5e47ad2a1aba0861c7b1179a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dbdd5c648b4b399b4b8c147fc99d43" id="r_ad1dbdd5c648b4b399b4b8c147fc99d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1dbdd5c648b4b399b4b8c147fc99d43">operator=</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt; other)</td></tr>
<tr class="memdesc:ad1dbdd5c648b4b399b4b8c147fc99d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator from <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>.  <br /></td></tr>
<tr class="separator:ad1dbdd5c648b4b399b4b8c147fc99d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2731727eb853928098f7051a0dca8995" id="r_a2731727eb853928098f7051a0dca8995"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t S = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:a2731727eb853928098f7051a0dca8995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2731727eb853928098f7051a0dca8995">operator=</a> (T &amp;&amp;other)</td></tr>
<tr class="memdesc:a2731727eb853928098f7051a0dca8995"><td class="mdescLeft">&#160;</td><td class="mdescRight">String literal assignment operator.  <br /></td></tr>
<tr class="separator:a2731727eb853928098f7051a0dca8995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895f17a8dd5ef18c2ea0120f785d84cb" id="r_a895f17a8dd5ef18c2ea0120f785d84cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a895f17a8dd5ef18c2ea0120f785d84cb">operator=</a> (const StrExprForType&lt; K &gt; auto &amp;expr)</td></tr>
<tr class="memdesc:a895f17a8dd5ef18c2ea0120f785d84cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">String expression appending operator.  <br /></td></tr>
<tr class="separator:a895f17a8dd5ef18c2ea0120f785d84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9a64c776ee14ef49bb01e84eb87889" id="r_a4e9a64c776ee14ef49bb01e84eb87889"><td class="memItemLeft" align="right" valign="top"><a id="a4e9a64c776ee14ef49bb01e84eb87889" name="a4e9a64c776ee14ef49bb01e84eb87889"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> () const noexcept</td></tr>
<tr class="memdesc:a4e9a64c776ee14ef49bb01e84eb87889"><td class="mdescLeft">&#160;</td><td class="mdescRight">String length. <br /></td></tr>
<tr class="separator:a4e9a64c776ee14ef49bb01e84eb87889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc14bfdba77dd4027af118f6f52a5a93" id="r_acc14bfdba77dd4027af118f6f52a5a93"><td class="memItemLeft" align="right" valign="top"><a id="acc14bfdba77dd4027af118f6f52a5a93" name="acc14bfdba77dd4027af118f6f52a5a93"></a>
constexpr const K *&#160;</td><td class="memItemRight" valign="bottom"><b>symbols</b> () const noexcept</td></tr>
<tr class="memdesc:acc14bfdba77dd4027af118f6f52a5a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to constant characters. <br /></td></tr>
<tr class="separator:acc14bfdba77dd4027af118f6f52a5a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2deb75dd3dd26b43f363c7f3ac3bd7" id="r_aee2deb75dd3dd26b43f363c7f3ac3bd7"><td class="memItemLeft" align="right" valign="top"><a id="aee2deb75dd3dd26b43f363c7f3ac3bd7" name="aee2deb75dd3dd26b43f363c7f3ac3bd7"></a>
constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><b>str</b> () noexcept</td></tr>
<tr class="memdesc:aee2deb75dd3dd26b43f363c7f3ac3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a string buffer. <br /></td></tr>
<tr class="separator:aee2deb75dd3dd26b43f363c7f3ac3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c7ea2f2356a1a299814a418949fdcc" id="r_ab3c7ea2f2356a1a299814a418949fdcc"><td class="memItemLeft" align="right" valign="top"><a id="ab3c7ea2f2356a1a299814a418949fdcc" name="ab3c7ea2f2356a1a299814a418949fdcc"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const noexcept</td></tr>
<tr class="memdesc:ab3c7ea2f2356a1a299814a418949fdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the string empty? <br /></td></tr>
<tr class="separator:ab3c7ea2f2356a1a299814a418949fdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd7ce10d5ec5fda052efe8d7ab6827" id="r_ae2cd7ce10d5ec5fda052efe8d7ab6827"><td class="memItemLeft" align="right" valign="top"><a id="ae2cd7ce10d5ec5fda052efe8d7ab6827" name="ae2cd7ce10d5ec5fda052efe8d7ab6827"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:ae2cd7ce10d5ec5fda052efe8d7ab6827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string is empty, for compatibility with std::string. <br /></td></tr>
<tr class="separator:ae2cd7ce10d5ec5fda052efe8d7ab6827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeea9e8d11fee04982ac6df01b4f6a7c" id="r_aeeea9e8d11fee04982ac6df01b4f6a7c"><td class="memItemLeft" align="right" valign="top"><a id="aeeea9e8d11fee04982ac6df01b4f6a7c" name="aeeea9e8d11fee04982ac6df01b4f6a7c"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const noexcept</td></tr>
<tr class="memdesc:aeeea9e8d11fee04982ac6df01b4f6a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current row buffer capacity. <br /></td></tr>
<tr class="separator:aeeea9e8d11fee04982ac6df01b4f6a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c80a142e77e0927ab5a17a17ff5ef7" id="r_aa0c80a142e77e0927ab5a17a17ff5ef7"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0c80a142e77e0927ab5a17a17ff5ef7">reserve_no_preserve</a> (size_t newSize)</td></tr>
<tr class="memdesc:aa0c80a142e77e0927ab5a17a17ff5ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer large enough to hold newSize characters plus a terminating null.  <br /></td></tr>
<tr class="separator:aa0c80a142e77e0927ab5a17a17ff5ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8b36c694de6015158b41d597e7551" id="r_ae9b8b36c694de6015158b41d597e7551"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9b8b36c694de6015158b41d597e7551">reserve</a> (size_t newSize)</td></tr>
<tr class="memdesc:ae9b8b36c694de6015158b41d597e7551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer large enough to hold newSize characters plus a terminating null.  <br /></td></tr>
<tr class="separator:ae9b8b36c694de6015158b41d597e7551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc32346401f3c9db8cee093b193524e7" id="r_abc32346401f3c9db8cee093b193524e7"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc32346401f3c9db8cee093b193524e7">set_size</a> (size_t newSize)</td></tr>
<tr class="memdesc:abc32346401f3c9db8cee093b193524e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the current string, allocating space if necessary.  <br /></td></tr>
<tr class="separator:abc32346401f3c9db8cee093b193524e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4289d6b43caed9e13a78c13bf12c4794" id="r_a4289d6b43caed9e13a78c13bf12c4794"><td class="memItemLeft" align="right" valign="top"><a id="a4289d6b43caed9e13a78c13bf12c4794" name="a4289d6b43caed9e13a78c13bf12c4794"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_local</b> () const noexcept</td></tr>
<tr class="memdesc:a4289d6b43caed9e13a78c13bf12c4794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether a local or external buffer is used for characters. <br /></td></tr>
<tr class="separator:a4289d6b43caed9e13a78c13bf12c4794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1567876cf258412f403b78241c242fd8" id="r_a1567876cf258412f403b78241c242fd8"><td class="memItemLeft" align="right" valign="top"><a id="a1567876cf258412f403b78241c242fd8" name="a1567876cf258412f403b78241c242fd8"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>define_size</b> ()</td></tr>
<tr class="memdesc:a1567876cf258412f403b78241c242fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the length of the string. Searches for the character 0 in the string buffer to its capacity, and then sets the length of the line to the found 0. <br /></td></tr>
<tr class="separator:a1567876cf258412f403b78241c242fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e76a8afbb51ac9ebcf4bf91e7d8331" id="r_ae3e76a8afbb51ac9ebcf4bf91e7d8331"><td class="memItemLeft" align="right" valign="top"><a id="ae3e76a8afbb51ac9ebcf4bf91e7d8331" name="ae3e76a8afbb51ac9ebcf4bf91e7d8331"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="memdesc:ae3e76a8afbb51ac9ebcf4bf91e7d8331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the size of the external buffer to the smallest possible size to hold the string. If the string fits into the internal buffer, it copies it into it and frees the external buffer. <br /></td></tr>
<tr class="separator:ae3e76a8afbb51ac9ebcf4bf91e7d8331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb855ee5e85fe5890070280d1a1a1ca" id="r_accb855ee5e85fe5890070280d1a1a1ca"><td class="memItemLeft" align="right" valign="top"><a id="accb855ee5e85fe5890070280d1a1a1ca" name="accb855ee5e85fe5890070280d1a1a1ca"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:accb855ee5e85fe5890070280d1a1a1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a string empty without changing the string buffer. <br /></td></tr>
<tr class="separator:accb855ee5e85fe5890070280d1a1a1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcefdd6cce80dcd8983731dafd881b4" id="r_a2bcefdd6cce80dcd8983731dafd881b4"><td class="memItemLeft" align="right" valign="top"><a id="a2bcefdd6cce80dcd8983731dafd881b4" name="a2bcefdd6cce80dcd8983731dafd881b4"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:a2bcefdd6cce80dcd8983731dafd881b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the string empty and frees the external buffer, if there was one. <br /></td></tr>
<tr class="separator:a2bcefdd6cce80dcd8983731dafd881b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400250ea87cc59daa152dc9ddb57491f" id="r_a400250ea87cc59daa152dc9ddb57491f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a400250ea87cc59daa152dc9ddb57491f">compare_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a400250ea87cc59daa152dc9ddb57491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character without taking into account the case of Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a400250ea87cc59daa152dc9ddb57491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf0990c46a280cd363da46bef12e02f" id="r_adbf0990c46a280cd363da46bef12e02f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#adbf0990c46a280cd363da46bef12e02f">equal_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:adbf0990c46a280cd363da46bef12e02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is equal to another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:adbf0990c46a280cd363da46bef12e02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79e99462478b57d62873f7942ff2b6" id="r_a4e79e99462478b57d62873f7942ff2b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a4e79e99462478b57d62873f7942ff2b6">less_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a4e79e99462478b57d62873f7942ff2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is smaller than another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a4e79e99462478b57d62873f7942ff2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26465c7fdac87e8d215e836bdbf6e8c3" id="r_a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a26465c7fdac87e8d215e836bdbf6e8c3">starts_with_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string starts with the given substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535d655a6702861b788830a1d266e48f" id="r_a535d655a6702861b788830a1d266e48f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a535d655a6702861b788830a1d266e48f">ends_with_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a535d655a6702861b788830a1d266e48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a535d655a6702861b788830a1d266e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3ef69a372dab777c952f22c492689" id="r_a6ae3ef69a372dab777c952f22c492689"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a6ae3ef69a372dab777c952f22c492689">upperred</a> () const</td></tr>
<tr class="memdesc:a6ae3ef69a372dab777c952f22c492689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in upper case Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a6ae3ef69a372dab777c952f22c492689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51ac2887746e40214eeee7d52460f4" id="r_a8d51ac2887746e40214eeee7d52460f4"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a8d51ac2887746e40214eeee7d52460f4">lowered</a> () const</td></tr>
<tr class="memdesc:a8d51ac2887746e40214eeee7d52460f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in lowercase Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a8d51ac2887746e40214eeee7d52460f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af52e61e73c687a34ff6978304edc3" id="r_aa1af52e61e73c687a34ff6978304edc3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aa1af52e61e73c687a34ff6978304edc3">to_double</a> () const noexcept</td></tr>
<tr class="memdesc:aa1af52e61e73c687a34ff6978304edc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <br /></td></tr>
<tr class="separator:aa1af52e61e73c687a34ff6978304edc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860598fca0df848662d7d8578a8f6da" id="r_af860598fca0df848662d7d8578a8f6da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af860598fca0df848662d7d8578a8f6da">as_number</a> (double &amp;t) const</td></tr>
<tr class="memdesc:af860598fca0df848662d7d8578a8f6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <br /></td></tr>
<tr class="separator:af860598fca0df848662d7d8578a8f6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17421202713ebd4d62ddf175023f535" id="r_ac17421202713ebd4d62ddf175023f535"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ac17421202713ebd4d62ddf175023f535">as_number</a> (T &amp;t) const</td></tr>
<tr class="memdesc:ac17421202713ebd4d62ddf175023f535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an integer.  <br /></td></tr>
<tr class="separator:ac17421202713ebd4d62ddf175023f535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af893677739e0d24418f6acc0a29090cc" id="r_af893677739e0d24418f6acc0a29090cc"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place</a> (K *ptr) const noexcept</td></tr>
<tr class="memdesc:af893677739e0d24418f6acc0a29090cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string to the specified buffer.  <br /></td></tr>
<tr class="separator:af893677739e0d24418f6acc0a29090cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2498615b426546b65e9b6c4f973264" id="r_a3c2498615b426546b65e9b6c4f973264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a3c2498615b426546b65e9b6c4f973264">copy_to</a> (K *buffer, size_t bufSize)</td></tr>
<tr class="memdesc:a3c2498615b426546b65e9b6c4f973264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string to the specified buffer.  <br /></td></tr>
<tr class="separator:a3c2498615b426546b65e9b6c4f973264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2732ccf421fcd1ba606addcca7e6e42" id="r_aa2732ccf421fcd1ba606addcca7e6e42"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa2732ccf421fcd1ba606addcca7e6e42">size</a> () const</td></tr>
<tr class="memdesc:aa2732ccf421fcd1ba606addcca7e6e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the string in characters.  <br /></td></tr>
<tr class="separator:aa2732ccf421fcd1ba606addcca7e6e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2af1ee80a32a77ad30cffbf6987107" id="r_a1f2af1ee80a32a77ad30cffbf6987107"><td class="memItemLeft" align="right" valign="top">constexpr std::basic_string_view&lt; D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a1f2af1ee80a32a77ad30cffbf6987107">to_sv</a> () const noexcept</td></tr>
<tr class="memdesc:a1f2af1ee80a32a77ad30cffbf6987107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::basic_string_view.  <br /></td></tr>
<tr class="separator:a1f2af1ee80a32a77ad30cffbf6987107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c6b4c365f05e609a7b22cbf37b39c6" id="r_ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab4c6b4c365f05e609a7b22cbf37b39c6">operator std::basic_string_view&lt; D, Traits &gt;</a> () const</td></tr>
<tr class="memdesc:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::basic_string_view.  <br /></td></tr>
<tr class="separator:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc816f095922a510dfe466db1905fc63" id="r_adc816f095922a510dfe466db1905fc63"><td class="memItemLeft" align="right" valign="top">constexpr std::basic_string&lt; D, Traits, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#adc816f095922a510dfe466db1905fc63">to_string</a> () const</td></tr>
<tr class="memdesc:adc816f095922a510dfe466db1905fc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::basic_string.  <br /></td></tr>
<tr class="separator:adc816f095922a510dfe466db1905fc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9959513e8a072c51620248c4a29f4196" id="r_a9959513e8a072c51620248c4a29f4196"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9959513e8a072c51620248c4a29f4196">operator std::basic_string&lt; D, Traits, Allocator &gt;</a> () const</td></tr>
<tr class="memdesc:a9959513e8a072c51620248c4a29f4196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::basic_string.  <br /></td></tr>
<tr class="separator:a9959513e8a072c51620248c4a29f4196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916218a7a75a3866a9d3d0da9334653c" id="r_a916218a7a75a3866a9d3d0da9334653c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a916218a7a75a3866a9d3d0da9334653c">operator str_piece</a> () const noexcept</td></tr>
<tr class="memdesc:a916218a7a75a3866a9d3d0da9334653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert itself to a "string chunk" that includes the entire string.  <br /></td></tr>
<tr class="separator:a916218a7a75a3866a9d3d0da9334653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d19b3fba03bfd481d2a3b3def766af" id="r_a53d19b3fba03bfd481d2a3b3def766af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a53d19b3fba03bfd481d2a3b3def766af">to_str</a> () const noexcept</td></tr>
<tr class="memdesc:a53d19b3fba03bfd481d2a3b3def766af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert itself to a "string chunk" that includes the entire string.  <br /></td></tr>
<tr class="separator:a53d19b3fba03bfd481d2a3b3def766af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8f275b33545d2491850f49ba3b7876" id="r_ace8f275b33545d2491850f49ba3b7876"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ace8f275b33545d2491850f49ba3b7876">operator()</a> (ptrdiff_t from, ptrdiff_t len=0) const noexcept</td></tr>
<tr class="memdesc:ace8f275b33545d2491850f49ba3b7876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string as "str_src".  <br /></td></tr>
<tr class="separator:ace8f275b33545d2491850f49ba3b7876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507a43e6ebcc51e6409874712abbbd63" id="r_a507a43e6ebcc51e6409874712abbbd63"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a507a43e6ebcc51e6409874712abbbd63">mid</a> (size_t from, size_t len=-1) const noexcept</td></tr>
<tr class="memdesc:a507a43e6ebcc51e6409874712abbbd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string as "string chunk".  <br /></td></tr>
<tr class="separator:a507a43e6ebcc51e6409874712abbbd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5659e7fb47dfb6bd6736a1b454ffde92" id="r_a5659e7fb47dfb6bd6736a1b454ffde92"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a5659e7fb47dfb6bd6736a1b454ffde92">from_to</a> (size_t from, size_t to) const noexcept</td></tr>
<tr class="memdesc:a5659e7fb47dfb6bd6736a1b454ffde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substring <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a> from position from to position to (not including it).  <br /></td></tr>
<tr class="separator:a5659e7fb47dfb6bd6736a1b454ffde92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a3ed434bc8ecc755076da742f8e5b" id="r_a992a3ed434bc8ecc755076da742f8e5b"><td class="memItemLeft" align="right" valign="top"><a id="a992a3ed434bc8ecc755076da742f8e5b" name="a992a3ed434bc8ecc755076da742f8e5b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!</b> () const noexcept</td></tr>
<tr class="memdesc:a992a3ed434bc8ecc755076da742f8e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for emptiness. <br /></td></tr>
<tr class="separator:a992a3ed434bc8ecc755076da742f8e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c053de38bf2a0eab39cf1de5b0a21a" id="r_ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="memItemLeft" align="right" valign="top">constexpr K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad2c053de38bf2a0eab39cf1de5b0a21a">at</a> (ptrdiff_t idx) const</td></tr>
<tr class="memdesc:ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at the given position.  <br /></td></tr>
<tr class="separator:ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d9cd0dc24f5d395e838a3ef20d846" id="r_a108d9cd0dc24f5d395e838a3ef20d846"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a108d9cd0dc24f5d395e838a3ef20d846">compare</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> o) const</td></tr>
<tr class="memdesc:a108d9cd0dc24f5d395e838a3ef20d846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character.  <br /></td></tr>
<tr class="separator:a108d9cd0dc24f5d395e838a3ef20d846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d501d16ab38c3efb1427f14ea7f67" id="r_a610d501d16ab38c3efb1427f14ea7f67"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a610d501d16ab38c3efb1427f14ea7f67">strcmp</a> (const K *text) const</td></tr>
<tr class="memdesc:a610d501d16ab38c3efb1427f14ea7f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare with C-string character by character.  <br /></td></tr>
<tr class="separator:a610d501d16ab38c3efb1427f14ea7f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b0cb780c465cb9b6bd925d712ff07" id="r_a3b9b0cb780c465cb9b6bd925d712ff07"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a3b9b0cb780c465cb9b6bd925d712ff07">equal</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other) const noexcept</td></tr>
<tr class="memdesc:a3b9b0cb780c465cb9b6bd925d712ff07"><td class="mdescLeft">&#160;</td><td class="mdescRight">String comparison for equality.  <br /></td></tr>
<tr class="separator:a3b9b0cb780c465cb9b6bd925d712ff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddd0a1f9b25247465fb55c79b58826d" id="r_a1ddd0a1f9b25247465fb55c79b58826d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a1ddd0a1f9b25247465fb55c79b58826d">operator==</a> (const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a1ddd0a1f9b25247465fb55c79b58826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator comparing strings for equality.  <br /></td></tr>
<tr class="separator:a1ddd0a1f9b25247465fb55c79b58826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19dc728f9d7edafbd85a52e70b46376" id="r_ac19dc728f9d7edafbd85a52e70b46376"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac19dc728f9d7edafbd85a52e70b46376">operator==</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ac19dc728f9d7edafbd85a52e70b46376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for comparing a string and a string literal for equality.  <br /></td></tr>
<tr class="separator:ac19dc728f9d7edafbd85a52e70b46376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34637c1f071ac6e6faa0237a092cc61" id="r_ac34637c1f071ac6e6faa0237a092cc61"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac34637c1f071ac6e6faa0237a092cc61">operator&lt;=&gt;</a> (const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ac34637c1f071ac6e6faa0237a092cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">String comparison operator.  <br /></td></tr>
<tr class="separator:ac34637c1f071ac6e6faa0237a092cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63f315c4a97ee6ad1e2b045b9f5f9e0" id="r_ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad63f315c4a97ee6ad1e2b045b9f5f9e0">operator&lt;=&gt;</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator between a string and a string literal.  <br /></td></tr>
<tr class="separator:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5e10ff025504ee5d60e8c77f439003" id="r_a0e5e10ff025504ee5d60e8c77f439003"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0e5e10ff025504ee5d60e8c77f439003">compare_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a0e5e10ff025504ee5d60e8c77f439003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character and not case sensitive ASCII characters.  <br /></td></tr>
<tr class="separator:a0e5e10ff025504ee5d60e8c77f439003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9fca49d189fd0d760ffe8aed1485f1" id="r_afa9fca49d189fd0d760ffe8aed1485f1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#afa9fca49d189fd0d760ffe8aed1485f1">equal_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:afa9fca49d189fd0d760ffe8aed1485f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is equal to another string, character-by-character-insensitive, of ASCII characters.  <br /></td></tr>
<tr class="separator:afa9fca49d189fd0d760ffe8aed1485f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ede528e694988f26555e91cf9a1ca2" id="r_a44ede528e694988f26555e91cf9a1ca2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a44ede528e694988f26555e91cf9a1ca2">less_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a44ede528e694988f26555e91cf9a1ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is smaller than another string, character-by-character-insensitive, ASCII characters.  <br /></td></tr>
<tr class="separator:a44ede528e694988f26555e91cf9a1ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38e5cc7893a20e69cdf03d88232b49c" id="r_ab38e5cc7893a20e69cdf03d88232b49c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab38e5cc7893a20e69cdf03d88232b49c">find</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ab38e5cc7893a20e69cdf03d88232b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:ab38e5cc7893a20e69cdf03d88232b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129d72cc64be6029f10bbe1f8385f3ea" id="r_a129d72cc64be6029f10bbe1f8385f3ea"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a129d72cc64be6029f10bbe1f8385f3ea">find</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a129d72cc64be6029f10bbe1f8385f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a character in this string.  <br /></td></tr>
<tr class="separator:a129d72cc64be6029f10bbe1f8385f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab0482ea5f02bc0c3097bed6c9a5fa" id="r_a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a40ab0482ea5f02bc0c3097bed6c9a5fa">find_or_throw</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, Args &amp;&amp;... args) const noexcept</td></tr>
<tr class="memdesc:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string or throw an exception.  <br /></td></tr>
<tr class="separator:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcde5878d3d7fd5138d38ff2f1df4d2" id="r_a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a8bcde5878d3d7fd5138d38ff2f1df4d2">find_end</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029fd5412ed114bfefbdddba2c50167" id="r_ac029fd5412ed114bfefbdddba2c50167"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac029fd5412ed114bfefbdddba2c50167">find_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac029fd5412ed114bfefbdddba2c50167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string or the end of the string.  <br /></td></tr>
<tr class="separator:ac029fd5412ed114bfefbdddba2c50167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762c55d09b34ba2b7b5f9f10783da662" id="r_a762c55d09b34ba2b7b5f9f10783da662"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a762c55d09b34ba2b7b5f9f10783da662">find_or_all</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a762c55d09b34ba2b7b5f9f10783da662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a character in this string or the end of a string.  <br /></td></tr>
<tr class="separator:a762c55d09b34ba2b7b5f9f10783da662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c56c3345019c8d5dc20717092d52101" id="r_a2c56c3345019c8d5dc20717092d52101"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a2c56c3345019c8d5dc20717092d52101">find_end_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a2c56c3345019c8d5dc20717092d52101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the first occurrence of a substring in this string, or the end of a string.  <br /></td></tr>
<tr class="separator:a2c56c3345019c8d5dc20717092d52101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a2c0b10e857c245f67a2abd7c1a2f0" id="r_a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a72a2c0b10e857c245f67a2abd7c1a2f0">find_last</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the last occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0564461ab81bfbb6c5bd8b4c7e5a496e" id="r_a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0564461ab81bfbb6c5bd8b4c7e5a496e">find_last</a> (K s, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character in this string.  <br /></td></tr>
<tr class="separator:a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab67ba06c8637f93984e45cf349c3eb8" id="r_aab67ba06c8637f93984e45cf349c3eb8"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aab67ba06c8637f93984e45cf349c3eb8">find_end_of_last</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:aab67ba06c8637f93984e45cf349c3eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the last occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:aab67ba06c8637f93984e45cf349c3eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5bdd0e7ab4f7e64e1e776f4dabe11c" id="r_a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6a5bdd0e7ab4f7e64e1e776f4dabe11c">find_last_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the last occurrence of a substring in this string or the end of the string.  <br /></td></tr>
<tr class="separator:a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281c63da2d81ef8aac65a2dad77eb93" id="r_ae281c63da2d81ef8aac65a2dad77eb93"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae281c63da2d81ef8aac65a2dad77eb93">find_end_of_last_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:ae281c63da2d81ef8aac65a2dad77eb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the last occurrence of a substring in this string, or the end of a string.  <br /></td></tr>
<tr class="separator:ae281c63da2d81ef8aac65a2dad77eb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d712294186e2e181910677ba9c3ca7" id="r_ac4d712294186e2e181910677ba9c3ca7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac4d712294186e2e181910677ba9c3ca7">contains</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac4d712294186e2e181910677ba9c3ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string contains the specified substring.  <br /></td></tr>
<tr class="separator:ac4d712294186e2e181910677ba9c3ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8185ccf8fc2297b628cce3c83b6a0b4c" id="r_a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a8185ccf8fc2297b628cce3c83b6a0b4c">for_all_finded</a> (const Op &amp;op, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor on all found occurrences of a substring in this string.  <br /></td></tr>
<tr class="separator:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d568443f3ed5752279098b9a488655" id="r_aa6d568443f3ed5752279098b9a488655"><td class="memItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa6d568443f3ed5752279098b9a488655">find_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:aa6d568443f3ed5752279098b9a488655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all occurrences of a substring in this string.  <br /></td></tr>
<tr class="separator:aa6d568443f3ed5752279098b9a488655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bf839edef0abbd43c3f3654e8e700" id="r_a643bf839edef0abbd43c3f3654e8e700"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a643bf839edef0abbd43c3f3654e8e700">find_first_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a643bf839edef0abbd43c3f3654e8e700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:a643bf839edef0abbd43c3f3654e8e700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5ad9c702f21003a272469cb1edcbf3" id="r_aad5ad9c702f21003a272469cb1edcbf3"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aad5ad9c702f21003a272469cb1edcbf3">find_first_of_idx</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:aad5ad9c702f21003a272469cb1edcbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:aad5ad9c702f21003a272469cb1edcbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff5e918afcc8e1fba9a3ec19c47897" id="r_a63ff5e918afcc8e1fba9a3ec19c47897"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a63ff5e918afcc8e1fba9a3ec19c47897">find_first_not_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a63ff5e918afcc8e1fba9a3ec19c47897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character not from the given character set.  <br /></td></tr>
<tr class="separator:a63ff5e918afcc8e1fba9a3ec19c47897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73806fa93c9ec619ba93d479d413ea0f" id="r_a73806fa93c9ec619ba93d479d413ea0f"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a73806fa93c9ec619ba93d479d413ea0f">find_last_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:a73806fa93c9ec619ba93d479d413ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:a73806fa93c9ec619ba93d479d413ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab630d62252bf1210f573a8c7222942c8" id="r_ab630d62252bf1210f573a8c7222942c8"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab630d62252bf1210f573a8c7222942c8">find_last_of_idx</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:ab630d62252bf1210f573a8c7222942c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:ab630d62252bf1210f573a8c7222942c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775a7c8e218ab3223f0248f225076b7c" id="r_a775a7c8e218ab3223f0248f225076b7c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a775a7c8e218ab3223f0248f225076b7c">find_last_not_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:a775a7c8e218ab3223f0248f225076b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character not from the given character set.  <br /></td></tr>
<tr class="separator:a775a7c8e218ab3223f0248f225076b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512eaf3c2c8736f3021a5bbe60823866" id="r_a512eaf3c2c8736f3021a5bbe60823866"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a512eaf3c2c8736f3021a5bbe60823866">substr</a> (ptrdiff_t from, ptrdiff_t len=0) const</td></tr>
<tr class="memdesc:a512eaf3c2c8736f3021a5bbe60823866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a substring. Works similarly to operator(), only the result is the same type as the method applied to.  <br /></td></tr>
<tr class="separator:a512eaf3c2c8736f3021a5bbe60823866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77c31da012cf5cc23e0a60c1888cec2" id="r_aa77c31da012cf5cc23e0a60c1888cec2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa77c31da012cf5cc23e0a60c1888cec2">str_mid</a> (size_t from, size_t len=-1) const</td></tr>
<tr class="memdesc:aa77c31da012cf5cc23e0a60c1888cec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string with an object of the same type to which the method is applied, similar to mid.  <br /></td></tr>
<tr class="separator:aa77c31da012cf5cc23e0a60c1888cec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4213df62c3208dd26ae540122dcfa45d" id="r_a4213df62c3208dd26ae540122dcfa45d"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a4213df62c3208dd26ae540122dcfa45d">as_int</a> () const noexcept</td></tr>
<tr class="memdesc:a4213df62c3208dd26ae540122dcfa45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number of the given type.  <br /></td></tr>
<tr class="separator:a4213df62c3208dd26ae540122dcfa45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa40ca4ad70df9ec0941599b88c443dc" id="r_afa40ca4ad70df9ec0941599b88c443dc"><td class="memItemLeft" align="right" valign="top">constexpr convert_result&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#afa40ca4ad70df9ec0941599b88c443dc">to_int</a> () const noexcept</td></tr>
<tr class="memdesc:afa40ca4ad70df9ec0941599b88c443dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number of the given type.  <br /></td></tr>
<tr class="separator:afa40ca4ad70df9ec0941599b88c443dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037d07ad0ee024d983927cec3ee81908" id="r_a037d07ad0ee024d983927cec3ee81908"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a037d07ad0ee024d983927cec3ee81908">to_double_hex</a> () const noexcept</td></tr>
<tr class="memdesc:a037d07ad0ee024d983927cec3ee81908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string in hex form to double.  <br /></td></tr>
<tr class="separator:a037d07ad0ee024d983927cec3ee81908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffb295777b82a1475a4fc0d9754481b" id="r_adffb295777b82a1475a4fc0d9754481b"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#adffb295777b82a1475a4fc0d9754481b">splitf</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter, const Op &amp;beforeFunc, size_t offset=0) const</td></tr>
<tr class="memdesc:adffb295777b82a1475a4fc0d9754481b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into parts at a given delimiter, possibly applying a functor to each substring.  <br /></td></tr>
<tr class="separator:adffb295777b82a1475a4fc0d9754481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad7e9416ed3abc8689034463f497e6b" id="r_a4ad7e9416ed3abc8689034463f497e6b"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a4ad7e9416ed3abc8689034463f497e6b">split</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter, size_t offset=0) const</td></tr>
<tr class="memdesc:a4ad7e9416ed3abc8689034463f497e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into substrings using a given delimiter.  <br /></td></tr>
<tr class="separator:a4ad7e9416ed3abc8689034463f497e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2febfef44dabdf863a74db2049410e9f" id="r_a2febfef44dabdf863a74db2049410e9f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a2febfef44dabdf863a74db2049410e9f">starts_with</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a2febfef44dabdf863a74db2049410e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string begins with the given substring.  <br /></td></tr>
<tr class="separator:a2febfef44dabdf863a74db2049410e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9409e48b2f182546b7f7186af2477e" id="r_a6d9409e48b2f182546b7f7186af2477e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6d9409e48b2f182546b7f7186af2477e">starts_with_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a6d9409e48b2f182546b7f7186af2477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string begins with the given substring in a case-insensitive ASCII character.  <br /></td></tr>
<tr class="separator:a6d9409e48b2f182546b7f7186af2477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37c68155961c5c7b1609aa1b873b8d3" id="r_ae37c68155961c5c7b1609aa1b873b8d3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae37c68155961c5c7b1609aa1b873b8d3">prefix_in</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:ae37c68155961c5c7b1609aa1b873b8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this string is the beginning of another string.  <br /></td></tr>
<tr class="separator:ae37c68155961c5c7b1609aa1b873b8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15504449e8d2a8f77832046b559ae0a8" id="r_a15504449e8d2a8f77832046b559ae0a8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a15504449e8d2a8f77832046b559ae0a8">ends_with</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a15504449e8d2a8f77832046b559ae0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring.  <br /></td></tr>
<tr class="separator:a15504449e8d2a8f77832046b559ae0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63742e2c0e55c85b0569f6a0004e5418" id="r_a63742e2c0e55c85b0569f6a0004e5418"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a63742e2c0e55c85b0569f6a0004e5418">ends_with_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a63742e2c0e55c85b0569f6a0004e5418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring in a case-insensitive ASCII character.  <br /></td></tr>
<tr class="separator:a63742e2c0e55c85b0569f6a0004e5418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeefcf45750a8260d5a57b3056a1521f" id="r_aaeefcf45750a8260d5a57b3056a1521f"><td class="memItemLeft" align="right" valign="top"><a id="aaeefcf45750a8260d5a57b3056a1521f" name="aaeefcf45750a8260d5a57b3056a1521f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ascii</b> () const noexcept</td></tr>
<tr class="memdesc:aaeefcf45750a8260d5a57b3056a1521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string contains only ASCII characters. <br /></td></tr>
<tr class="separator:aaeefcf45750a8260d5a57b3056a1521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517129dd2774440cd48c401b65bcf066" id="r_a517129dd2774440cd48c401b65bcf066"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a517129dd2774440cd48c401b65bcf066">upperred_only_ascii</a> () const</td></tr>
<tr class="memdesc:a517129dd2774440cd48c401b65bcf066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in uppercase ASCII characters.  <br /></td></tr>
<tr class="separator:a517129dd2774440cd48c401b65bcf066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f36df5ff2422e43919e74d965f24a4" id="r_ad2f36df5ff2422e43919e74d965f24a4"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad2f36df5ff2422e43919e74d965f24a4">lowered_only_ascii</a> () const</td></tr>
<tr class="memdesc:ad2f36df5ff2422e43919e74d965f24a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in lowercase ASCII characters.  <br /></td></tr>
<tr class="separator:ad2f36df5ff2422e43919e74d965f24a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606b0373189a0fb89bce3801e972e46a" id="r_a606b0373189a0fb89bce3801e972e46a"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a606b0373189a0fb89bce3801e972e46a">replaced</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> repl, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a606b0373189a0fb89bce3801e972e46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string with occurrences of substrings replaced.  <br /></td></tr>
<tr class="separator:a606b0373189a0fb89bce3801e972e46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bded9dcb3da163cf73d690dd63a73d4" id="r_a9bded9dcb3da163cf73d690dd63a73d4"><td class="memItemLeft" align="right" valign="top">constexpr R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9bded9dcb3da163cf73d690dd63a73d4">trimmed</a> () const</td></tr>
<tr class="memdesc:a9bded9dcb3da163cf73d690dd63a73d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the left and right.  <br /></td></tr>
<tr class="separator:a9bded9dcb3da163cf73d690dd63a73d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9958a7ba764ec2ee03fd5f205e3bcd" id="r_a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9b9958a7ba764ec2ee03fd5f205e3bcd">trimmed</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the left and right.  <br /></td></tr>
<tr class="separator:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e8b3bad27529f5033fee8985dbec7d" id="r_a16e8b3bad27529f5033fee8985dbec7d"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a16e8b3bad27529f5033fee8985dbec7d">trimmed</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a16e8b3bad27529f5033fee8985dbec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed, left and right.  <br /></td></tr>
<tr class="separator:a16e8b3bad27529f5033fee8985dbec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d2652007aef40826102fb153134c4d" id="r_a25d2652007aef40826102fb153134c4d"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a25d2652007aef40826102fb153134c4d">trimmed_left</a> () const</td></tr>
<tr class="memdesc:a25d2652007aef40826102fb153134c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the left.  <br /></td></tr>
<tr class="separator:a25d2652007aef40826102fb153134c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7910e7f7cb59cad7452f79ee8f1921a" id="r_ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab7910e7f7cb59cad7452f79ee8f1921a">trimmed_left</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the left.  <br /></td></tr>
<tr class="separator:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a1d3727d030ed34c789a1fd45a8038" id="r_a17a1d3727d030ed34c789a1fd45a8038"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a17a1d3727d030ed34c789a1fd45a8038">trimmed_left</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a17a1d3727d030ed34c789a1fd45a8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed from the left.  <br /></td></tr>
<tr class="separator:a17a1d3727d030ed34c789a1fd45a8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3af5eab221e4645e6e91b7b1a6e7d2" id="r_a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0b3af5eab221e4645e6e91b7b1a6e7d2">trimmed_right</a> () const</td></tr>
<tr class="memdesc:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the right.  <br /></td></tr>
<tr class="separator:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82f1096d596015340377b58704030cf" id="r_ac82f1096d596015340377b58704030cf"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac82f1096d596015340377b58704030cf">trimmed_right</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ac82f1096d596015340377b58704030cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the right.  <br /></td></tr>
<tr class="separator:ac82f1096d596015340377b58704030cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a49ba436dd8d11037216dc97efcd4c" id="r_aa5a49ba436dd8d11037216dc97efcd4c"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa5a49ba436dd8d11037216dc97efcd4c">trimmed_right</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:aa5a49ba436dd8d11037216dc97efcd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed to the right.  <br /></td></tr>
<tr class="separator:aa5a49ba436dd8d11037216dc97efcd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab950f20c494e2c60b22dfe95e410ec25" id="r_ab950f20c494e2c60b22dfe95e410ec25"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab950f20c494e2c60b22dfe95e410ec25">trimmed_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab950f20c494e2c60b22dfe95e410ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, left and right.  <br /></td></tr>
<tr class="separator:ab950f20c494e2c60b22dfe95e410ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2541095cb5e5a262b8e20c4dc8428b" id="r_a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6c2541095cb5e5a262b8e20c4dc8428b">trimmed_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, left and right.  <br /></td></tr>
<tr class="separator:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e7c2822c67cc2ea9a0b8c8ed9e0280" id="r_ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae0e7c2822c67cc2ea9a0b8c8ed9e0280">trimmed_left_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, left.  <br /></td></tr>
<tr class="separator:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b80529d46935202969c279de481cda" id="r_ae9b80529d46935202969c279de481cda"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae9b80529d46935202969c279de481cda">trimmed_left_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:ae9b80529d46935202969c279de481cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, left.  <br /></td></tr>
<tr class="separator:ae9b80529d46935202969c279de481cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41853e3d4d2579fe7557873592e7302" id="r_ad41853e3d4d2579fe7557873592e7302"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad41853e3d4d2579fe7557873592e7302">trimmed_right_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ad41853e3d4d2579fe7557873592e7302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, right.  <br /></td></tr>
<tr class="separator:ad41853e3d4d2579fe7557873592e7302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21bff9dca83968de291faa2b6d59fa8" id="r_ac21bff9dca83968de291faa2b6d59fa8"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac21bff9dca83968de291faa2b6d59fa8">trimmed_right_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:ac21bff9dca83968de291faa2b6d59fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, right.  <br /></td></tr>
<tr class="separator:ac21bff9dca83968de291faa2b6d59fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6c202d1c1723297d46a45d82c5808" id="r_ab3f6c202d1c1723297d46a45d82c5808"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab3f6c202d1c1723297d46a45d82c5808">splitter</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter) const</td></tr>
<tr class="memdesc:ab3f6c202d1c1723297d46a45d82c5808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <code>Splitter</code> object by the given splitter, which allows sequential get substrings using the <code>next()</code> method while <code>is_done()</code> is false.  <br /></td></tr>
<tr class="separator:ab3f6c202d1c1723297d46a45d82c5808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb440524f81da0e00cfa303cb4fab6" id="r_a32cb440524f81da0e00cfa303cb4fab6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a32cb440524f81da0e00cfa303cb4fab6">operator K*</a> () noexcept</td></tr>
<tr class="memdesc:a32cb440524f81da0e00cfa303cb4fab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the string buffer.  <br /></td></tr>
<tr class="separator:a32cb440524f81da0e00cfa303cb4fab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab697bf9b655f0ed7762ee830efb25b18" id="r_ab697bf9b655f0ed7762ee830efb25b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ab697bf9b655f0ed7762ee830efb25b18">trim</a> ()</td></tr>
<tr class="memdesc:ab697bf9b655f0ed7762ee830efb25b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove whitespace from the beginning and end of a line.  <br /></td></tr>
<tr class="separator:ab697bf9b655f0ed7762ee830efb25b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25c5f127c99392c53470f0a9919b504" id="r_af25c5f127c99392c53470f0a9919b504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#af25c5f127c99392c53470f0a9919b504">trim</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:af25c5f127c99392c53470f0a9919b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in a string literal at the beginning and end of the line.  <br /></td></tr>
<tr class="separator:af25c5f127c99392c53470f0a9919b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ae0d5f1aef083fc2c84274cd794c74" id="r_a14ae0d5f1aef083fc2c84274cd794c74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a14ae0d5f1aef083fc2c84274cd794c74">trim</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a14ae0d5f1aef083fc2c84274cd794c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in the passed string at the beginning and end of the line.  <br /></td></tr>
<tr class="separator:a14ae0d5f1aef083fc2c84274cd794c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244334bd105c03fa510804b31707996f" id="r_a244334bd105c03fa510804b31707996f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a244334bd105c03fa510804b31707996f">trim_left</a> ()</td></tr>
<tr class="memdesc:a244334bd105c03fa510804b31707996f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove whitespace at the beginning of a line.  <br /></td></tr>
<tr class="separator:a244334bd105c03fa510804b31707996f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b013501c10698abf323333d17ab2ac" id="r_a65b013501c10698abf323333d17ab2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a65b013501c10698abf323333d17ab2ac">trim_left</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a65b013501c10698abf323333d17ab2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in a string literal at the beginning of the line.  <br /></td></tr>
<tr class="separator:a65b013501c10698abf323333d17ab2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26d84497e19b7bbfd83da9cc593310" id="r_a2e26d84497e19b7bbfd83da9cc593310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a2e26d84497e19b7bbfd83da9cc593310">trim_left</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a2e26d84497e19b7bbfd83da9cc593310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in the passed string at the beginning of the line.  <br /></td></tr>
<tr class="separator:a2e26d84497e19b7bbfd83da9cc593310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8daf67d09761a0834881d00562596f" id="r_a8a8daf67d09761a0834881d00562596f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a8a8daf67d09761a0834881d00562596f">trim_right</a> ()</td></tr>
<tr class="memdesc:a8a8daf67d09761a0834881d00562596f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove whitespace from the end of a line.  <br /></td></tr>
<tr class="separator:a8a8daf67d09761a0834881d00562596f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73083ad3987d977364c90a9a80a1509f" id="r_a73083ad3987d977364c90a9a80a1509f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a73083ad3987d977364c90a9a80a1509f">trim_right</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a73083ad3987d977364c90a9a80a1509f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in a string literal at the end of the line.  <br /></td></tr>
<tr class="separator:a73083ad3987d977364c90a9a80a1509f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c100b87423b8c6261c8c2d16cd82194" id="r_a8c100b87423b8c6261c8c2d16cd82194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a8c100b87423b8c6261c8c2d16cd82194">trim_right</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a8c100b87423b8c6261c8c2d16cd82194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in the passed string from the end of the string.  <br /></td></tr>
<tr class="separator:a8c100b87423b8c6261c8c2d16cd82194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3240c4342cc4fa0de4126d1446501647" id="r_a3240c4342cc4fa0de4126d1446501647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a3240c4342cc4fa0de4126d1446501647">trim_with_spaces</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a3240c4342cc4fa0de4126d1446501647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in a string literal, as well as whitespace, at the beginning and end of the string.  <br /></td></tr>
<tr class="separator:a3240c4342cc4fa0de4126d1446501647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8bfc1561a193de117800effb3bbc7d" id="r_a8e8bfc1561a193de117800effb3bbc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a8e8bfc1561a193de117800effb3bbc7d">trim_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a8e8bfc1561a193de117800effb3bbc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in the passed string, as well as whitespace characters, at the beginning and end of the string.  <br /></td></tr>
<tr class="separator:a8e8bfc1561a193de117800effb3bbc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f668bb7ec9de3acf40727167787e630" id="r_a5f668bb7ec9de3acf40727167787e630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a5f668bb7ec9de3acf40727167787e630">trim_left_with_spaces</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a5f668bb7ec9de3acf40727167787e630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in a string literal, as well as whitespace, at the beginning of a line.  <br /></td></tr>
<tr class="separator:a5f668bb7ec9de3acf40727167787e630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff45375785f56489e1e6d8f9d978120" id="r_a7ff45375785f56489e1e6d8f9d978120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a7ff45375785f56489e1e6d8f9d978120">trim_left_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a7ff45375785f56489e1e6d8f9d978120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in the passed string, as well as whitespace, at the beginning of the string.  <br /></td></tr>
<tr class="separator:a7ff45375785f56489e1e6d8f9d978120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c59b83d60ff726a3ec9a9aeb1ae404b" id="r_a2c59b83d60ff726a3ec9a9aeb1ae404b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a2c59b83d60ff726a3ec9a9aeb1ae404b">trim_right_with_wpaces</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a2c59b83d60ff726a3ec9a9aeb1ae404b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in a string literal, as well as whitespace, at the end of a string.  <br /></td></tr>
<tr class="separator:a2c59b83d60ff726a3ec9a9aeb1ae404b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73428dd849aa12f674ece721e067ccb9" id="r_a73428dd849aa12f674ece721e067ccb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a73428dd849aa12f674ece721e067ccb9">trim_right_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a73428dd849aa12f674ece721e067ccb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove characters included in the passed string, as well as whitespace at the end of the string.  <br /></td></tr>
<tr class="separator:a73428dd849aa12f674ece721e067ccb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7b47cfc00189c51a5683fd34095192" id="r_a1c7b47cfc00189c51a5683fd34095192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a1c7b47cfc00189c51a5683fd34095192">upper_only_ascii</a> ()</td></tr>
<tr class="memdesc:a1c7b47cfc00189c51a5683fd34095192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ASCII characters to uppercase.  <br /></td></tr>
<tr class="separator:a1c7b47cfc00189c51a5683fd34095192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f5a8e01bd18d94b873390bdd5eee8d" id="r_a21f5a8e01bd18d94b873390bdd5eee8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a21f5a8e01bd18d94b873390bdd5eee8d">lower_only_ascii</a> ()</td></tr>
<tr class="memdesc:a21f5a8e01bd18d94b873390bdd5eee8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ASCII characters to lowercase.  <br /></td></tr>
<tr class="separator:a21f5a8e01bd18d94b873390bdd5eee8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b975226e92b0e57796dd14fed5248f" id="r_ad1b975226e92b0e57796dd14fed5248f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ad1b975226e92b0e57796dd14fed5248f">upper</a> ()</td></tr>
<tr class="memdesc:ad1b975226e92b0e57796dd14fed5248f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert first plane characters (&lt;0xFFFF) to uppercase Unicode.  <br /></td></tr>
<tr class="separator:ad1b975226e92b0e57796dd14fed5248f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c4239efb3b35bfcb99b61feff08156" id="r_ac0c4239efb3b35bfcb99b61feff08156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ac0c4239efb3b35bfcb99b61feff08156">lower</a> ()</td></tr>
<tr class="memdesc:ac0c4239efb3b35bfcb99b61feff08156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert first plane characters (&lt;0xFFFF) to lowercase Unicode.  <br /></td></tr>
<tr class="separator:ac0c4239efb3b35bfcb99b61feff08156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb338bd949c276a8bd4b9bbc8f9ef5a" id="r_a8bb338bd949c276a8bd4b9bbc8f9ef5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a8bb338bd949c276a8bd4b9bbc8f9ef5a">append</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a8bb338bd949c276a8bd4b9bbc8f9ef5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add another line to the end of the line.  <br /></td></tr>
<tr class="separator:a8bb338bd949c276a8bd4b9bbc8f9ef5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0275b9ec5edad56807286a9eabd613ff" id="r_a0275b9ec5edad56807286a9eabd613ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a0275b9ec5edad56807286a9eabd613ff">append</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:a0275b9ec5edad56807286a9eabd613ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a string expression to the end of the line.  <br /></td></tr>
<tr class="separator:a0275b9ec5edad56807286a9eabd613ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885c6a5a9ecf6417993824dbb4425af6" id="r_a885c6a5a9ecf6417993824dbb4425af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a885c6a5a9ecf6417993824dbb4425af6">operator+=</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a885c6a5a9ecf6417993824dbb4425af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add another line to the end of the line.  <br /></td></tr>
<tr class="separator:a885c6a5a9ecf6417993824dbb4425af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5514cee68803e4a0a18e648cb5cfc0" id="r_afa5514cee68803e4a0a18e648cb5cfc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#afa5514cee68803e4a0a18e648cb5cfc0">operator+=</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:afa5514cee68803e4a0a18e648cb5cfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a string expression to the end of the line.  <br /></td></tr>
<tr class="separator:afa5514cee68803e4a0a18e648cb5cfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740d3b2e75a7ad8c08a8363cbfa9b4df" id="r_a740d3b2e75a7ad8c08a8363cbfa9b4df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a740d3b2e75a7ad8c08a8363cbfa9b4df">append_in</a> (size_t pos, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a740d3b2e75a7ad8c08a8363cbfa9b4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add another line starting at the given position.  <br /></td></tr>
<tr class="separator:a740d3b2e75a7ad8c08a8363cbfa9b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66589c8ea0f96cc3dd33ca9bba3a65e" id="r_ae66589c8ea0f96cc3dd33ca9bba3a65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ae66589c8ea0f96cc3dd33ca9bba3a65e">append_in</a> (size_t pos, const A &amp;expr)</td></tr>
<tr class="memdesc:ae66589c8ea0f96cc3dd33ca9bba3a65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a string expression starting at the given position.  <br /></td></tr>
<tr class="separator:ae66589c8ea0f96cc3dd33ca9bba3a65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a03860f5d616ab4850daa1778e13f57" id="r_a5a03860f5d616ab4850daa1778e13f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a5a03860f5d616ab4850daa1778e13f57">change</a> (size_t from, size_t len, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a5a03860f5d616ab4850daa1778e13f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a piece of string with another string.  <br /></td></tr>
<tr class="separator:a5a03860f5d616ab4850daa1778e13f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537880538e549f94a3ce137d7cf33064" id="r_a537880538e549f94a3ce137d7cf33064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a537880538e549f94a3ce137d7cf33064">change</a> (size_t from, size_t len, const A &amp;expr)</td></tr>
<tr class="memdesc:a537880538e549f94a3ce137d7cf33064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a piece of string with a string expression.  <br /></td></tr>
<tr class="separator:a537880538e549f94a3ce137d7cf33064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a87ca9286d27c944b0453df89e7f92" id="r_a81a87ca9286d27c944b0453df89e7f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a81a87ca9286d27c944b0453df89e7f92">insert</a> (size_t to, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a81a87ca9286d27c944b0453df89e7f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a line at the specified position.  <br /></td></tr>
<tr class="separator:a81a87ca9286d27c944b0453df89e7f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01abc4c1daa39bb99451be642dc86f48" id="r_a01abc4c1daa39bb99451be642dc86f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a01abc4c1daa39bb99451be642dc86f48">insert</a> (size_t to, const A &amp;expr)</td></tr>
<tr class="memdesc:a01abc4c1daa39bb99451be642dc86f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a string expression at the specified position.  <br /></td></tr>
<tr class="separator:a01abc4c1daa39bb99451be642dc86f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb2a4a250dc0fe4c7c71ecd51745259" id="r_a5eb2a4a250dc0fe4c7c71ecd51745259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a5eb2a4a250dc0fe4c7c71ecd51745259">remove</a> (size_t from, size_t len)</td></tr>
<tr class="memdesc:a5eb2a4a250dc0fe4c7c71ecd51745259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove part of a line.  <br /></td></tr>
<tr class="separator:a5eb2a4a250dc0fe4c7c71ecd51745259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c3fa40f6a3f82eb83e0b7c61f1a0fd" id="r_a37c3fa40f6a3f82eb83e0b7c61f1a0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a37c3fa40f6a3f82eb83e0b7c61f1a0fd">prepend</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a37c3fa40f6a3f82eb83e0b7c61f1a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add another line to the beginning of the line.  <br /></td></tr>
<tr class="separator:a37c3fa40f6a3f82eb83e0b7c61f1a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f039d8eb7f384b96ceb0d7f55cf7c" id="r_aab2f039d8eb7f384b96ceb0d7f55cf7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#aab2f039d8eb7f384b96ceb0d7f55cf7c">prepend</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:aab2f039d8eb7f384b96ceb0d7f55cf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a string expression to the beginning of a line.  <br /></td></tr>
<tr class="separator:aab2f039d8eb7f384b96ceb0d7f55cf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ee55594becb6b2c2b98df722cc7a33" id="r_ac0ee55594becb6b2c2b98df722cc7a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ac0ee55594becb6b2c2b98df722cc7a33">replace</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> repl, size_t offset=0, size_t maxCount=0)</td></tr>
<tr class="memdesc:ac0ee55594becb6b2c2b98df722cc7a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace occurrences of a substring with another string.  <br /></td></tr>
<tr class="separator:ac0ee55594becb6b2c2b98df722cc7a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86b3a4c468f51e3ab3f7ba9e8786f9f" id="r_ad86b3a4c468f51e3ab3f7ba9e8786f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ad86b3a4c468f51e3ab3f7ba9e8786f9f">replace_from</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> repl, size_t offset=0, size_t maxCount=0)</td></tr>
<tr class="memdesc:ad86b3a4c468f51e3ab3f7ba9e8786f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the source string, replacing occurrences of substrings with another string.  <br /></td></tr>
<tr class="separator:ad86b3a4c468f51e3ab3f7ba9e8786f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53aa57efa783f3d9484a4c9b09bd4f70" id="r_a53aa57efa783f3d9484a4c9b09bd4f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a53aa57efa783f3d9484a4c9b09bd4f70">fill</a> (size_t from, const Op &amp;fillFunction)</td></tr>
<tr class="memdesc:a53aa57efa783f3d9484a4c9b09bd4f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a string buffer using a functor.  <br /></td></tr>
<tr class="separator:a53aa57efa783f3d9484a4c9b09bd4f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1cad4ba4af2bdd831580151cb32962" id="r_a4a1cad4ba4af2bdd831580151cb32962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a4a1cad4ba4af2bdd831580151cb32962">operator&lt;&lt;</a> (const Op &amp;fillFunction)</td></tr>
<tr class="memdesc:a4a1cad4ba4af2bdd831580151cb32962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a string with the fill method from position zero.  <br /></td></tr>
<tr class="separator:a4a1cad4ba4af2bdd831580151cb32962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5d59fd9e97d25cc5a9940c19ab796c" id="r_a0a5d59fd9e97d25cc5a9940c19ab796c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a0a5d59fd9e97d25cc5a9940c19ab796c">operator&lt;&lt;</a> (const Op &amp;fillFunction)</td></tr>
<tr class="memdesc:a0a5d59fd9e97d25cc5a9940c19ab796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the passed functor, passing a reference to itself.  <br /></td></tr>
<tr class="separator:a0a5d59fd9e97d25cc5a9940c19ab796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b1fdf213da8dc5cdaf6211904ee690" id="r_a01b1fdf213da8dc5cdaf6211904ee690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a01b1fdf213da8dc5cdaf6211904ee690">operator&lt;&lt;=</a> (const Op &amp;fillFunction)</td></tr>
<tr class="memdesc:a01b1fdf213da8dc5cdaf6211904ee690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a string with the fill method after the end of the string.  <br /></td></tr>
<tr class="separator:a01b1fdf213da8dc5cdaf6211904ee690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875205d5df5bc2d8b825ba8edd79b22a" id="r_a875205d5df5bc2d8b825ba8edd79b22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a875205d5df5bc2d8b825ba8edd79b22a">printf_from</a> (size_t from, const K *<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a875205d5df5bc2d8b825ba8edd79b22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends sprintf formatted output starting at the specified position.  <br /></td></tr>
<tr class="separator:a875205d5df5bc2d8b825ba8edd79b22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4c37cfab5e6a48dd47c8e7754e6530" id="r_a3f4c37cfab5e6a48dd47c8e7754e6530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a3f4c37cfab5e6a48dd47c8e7754e6530">printf</a> (const K *<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3f4c37cfab5e6a48dd47c8e7754e6530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string using sprintf.  <br /></td></tr>
<tr class="separator:a3f4c37cfab5e6a48dd47c8e7754e6530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256725807b06cfe2009cf378c4a687f5" id="r_a256725807b06cfe2009cf378c4a687f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a256725807b06cfe2009cf378c4a687f5">append_printf</a> (const K *<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a256725807b06cfe2009cf378c4a687f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends sprintf formatted output to the end of the line.  <br /></td></tr>
<tr class="separator:a256725807b06cfe2009cf378c4a687f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ca9bf60dd607b6b8721ec84abba5d5" id="r_ae8ca9bf60dd607b6b8721ec84abba5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ae8ca9bf60dd607b6b8721ec84abba5d5">format_from</a> (size_t from, const FmtString&lt; fmt_type, T... &gt; &amp;<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae8ca9bf60dd607b6b8721ec84abba5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends std::format-formatted output starting at the specified position.  <br /></td></tr>
<tr class="separator:ae8ca9bf60dd607b6b8721ec84abba5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf2545d9002b51989700a64d7aaff0e" id="r_a7cf2545d9002b51989700a64d7aaff0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a7cf2545d9002b51989700a64d7aaff0e">vformat_from</a> (size_t from, size_t max_write, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7cf2545d9002b51989700a64d7aaff0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends std::vformat formatted output starting at the specified position.  <br /></td></tr>
<tr class="separator:a7cf2545d9002b51989700a64d7aaff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfceeaa8961165845fa25fc652e31b0" id="r_a3bfceeaa8961165845fa25fc652e31b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a> (const FmtString&lt; fmt_type, T... &gt; &amp;pattern, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3bfceeaa8961165845fa25fc652e31b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string using std::format.  <br /></td></tr>
<tr class="separator:a3bfceeaa8961165845fa25fc652e31b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39acae07e8fa0b0f40721cf7b7aa9129" id="r_a39acae07e8fa0b0f40721cf7b7aa9129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a39acae07e8fa0b0f40721cf7b7aa9129">append_formatted</a> (const FmtString&lt; fmt_type, T... &gt; &amp;<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a39acae07e8fa0b0f40721cf7b7aa9129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends std::format-formatted output to the end of the line.  <br /></td></tr>
<tr class="separator:a39acae07e8fa0b0f40721cf7b7aa9129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ab4a1d48cbf3b7c3474a4bf28569c" id="r_a4c0ab4a1d48cbf3b7c3474a4bf28569c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a4c0ab4a1d48cbf3b7c3474a4bf28569c">vformat</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4c0ab4a1d48cbf3b7c3474a4bf28569c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string using std::vformat.  <br /></td></tr>
<tr class="separator:a4c0ab4a1d48cbf3b7c3474a4bf28569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3c063949d1d48ca056085eef1dccc3" id="r_adc3c063949d1d48ca056085eef1dccc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#adc3c063949d1d48ca056085eef1dccc3">append_vformatted</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:adc3c063949d1d48ca056085eef1dccc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends std::vformat-formatted output to the end of the line.  <br /></td></tr>
<tr class="separator:adc3c063949d1d48ca056085eef1dccc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85893478637a79c79321e5c15cab9763" id="r_a85893478637a79c79321e5c15cab9763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a85893478637a79c79321e5c15cab9763">vformat_n</a> (size_t max_write, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a85893478637a79c79321e5c15cab9763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string using std::vformat up to the specified size.  <br /></td></tr>
<tr class="separator:a85893478637a79c79321e5c15cab9763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d3c0afd02f09b0f9d32f2a7f52522a" id="r_a48d3c0afd02f09b0f9d32f2a7f52522a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a48d3c0afd02f09b0f9d32f2a7f52522a">append_vformatted_n</a> (size_t max_write, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48d3c0afd02f09b0f9d32f2a7f52522a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends std::vformat-formatted output to the end of the line, writing no more than the specified number of characters.  <br /></td></tr>
<tr class="separator:a48d3c0afd02f09b0f9d32f2a7f52522a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a9104a71b1593fea01f6eff162fec4" id="r_a43a9104a71b1593fea01f6eff162fec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a43a9104a71b1593fea01f6eff162fec4">with</a> (const Op &amp;fillFunction, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a43a9104a71b1593fea01f6eff162fec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor with a string and passed arguments.  <br /></td></tr>
<tr class="separator:a43a9104a71b1593fea01f6eff162fec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93a700258bc7492e53ceb2acf414315" id="r_af93a700258bc7492e53ceb2acf414315"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#af93a700258bc7492e53ceb2acf414315">operator const K *</a> () const noexcept</td></tr>
<tr class="memdesc:af93a700258bc7492e53ceb2acf414315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to a null-terminated C string.  <br /></td></tr>
<tr class="separator:af93a700258bc7492e53ceb2acf414315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed242dbe057042c9f72f9514aaf861ee" id="r_aed242dbe057042c9f72f9514aaf861ee"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#aed242dbe057042c9f72f9514aaf861ee">to_nts</a> (size_t from=0) const</td></tr>
<tr class="memdesc:aed242dbe057042c9f72f9514aaf861ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a> starting at the given character.  <br /></td></tr>
<tr class="separator:aed242dbe057042c9f72f9514aaf861ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcae77eab91707d4b3fa578dde83d34a" id="r_abcae77eab91707d4b3fa578dde83d34a"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#abcae77eab91707d4b3fa578dde83d34a">operator s_str_nt</a> () const</td></tr>
<tr class="memdesc:abcae77eab91707d4b3fa578dde83d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>.  <br /></td></tr>
<tr class="separator:abcae77eab91707d4b3fa578dde83d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476d90d2e02d4e72e99f4b4e40f3fec" id="r_ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="memItemLeft" align="right" valign="top">constexpr const K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1null__terminated.html#ac476d90d2e02d4e72e99f4b4e40f3fec">c_str</a> () const</td></tr>
<tr class="memdesc:ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a constant character buffer of a string.  <br /></td></tr>
<tr class="separator:ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9b002a3618bbfcebc945cef197a397a1" id="r_a9b002a3618bbfcebc945cef197a397a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">join</a> (const T &amp;strings, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> delimiter, bool tail=false, bool skip_empty=false, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9b002a3618bbfcebc945cef197a397a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate strings from the container into one string.  <br /></td></tr>
<tr class="separator:a9b002a3618bbfcebc945cef197a397a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb647956eba06372b0cef5328a0bc91" id="r_a6cb647956eba06372b0cef5328a0bc91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a6cb647956eba06372b0cef5328a0bc91">upperred_only_ascii_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6cb647956eba06372b0cef5328a0bc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string copy of the passed in uppercase ASCII characters.  <br /></td></tr>
<tr class="separator:a6cb647956eba06372b0cef5328a0bc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c800534b214e4473b6f59c3d761dc4" id="r_a95c800534b214e4473b6f59c3d761dc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a95c800534b214e4473b6f59c3d761dc4">lowered_only_ascii_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a95c800534b214e4473b6f59c3d761dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the passed string in lowercase ASCII characters.  <br /></td></tr>
<tr class="separator:a95c800534b214e4473b6f59c3d761dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c53f8d59e980315bc0d44b5cf6b1e6d" id="r_a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a3c53f8d59e980315bc0d44b5cf6b1e6d">upperred_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the passed string in uppercase Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7946e4e405f908fd85c896bd75f67d72" id="r_a7946e4e405f908fd85c896bd75f67d72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a7946e4e405f908fd85c896bd75f67d72">lowered_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7946e4e405f908fd85c896bd75f67d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the passed string in lowercase Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a7946e4e405f908fd85c896bd75f67d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdcc9ae62c73be2c37e4a40c3366ded" id="r_aafdcc9ae62c73be2c37e4a40c3366ded"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#aafdcc9ae62c73be2c37e4a40c3366ded">replaced_from</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aafdcc9ae62c73be2c37e4a40c3366ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the passed string with substrings replaced.  <br /></td></tr>
<tr class="separator:aafdcc9ae62c73be2c37e4a40c3366ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a458697f089f5d3f2aba985e0c707a577" id="r_a458697f089f5d3f2aba985e0c707a577"><td class="memItemLeft" align="right" valign="top"><a id="a458697f089f5d3f2aba985e0c707a577" name="a458697f089f5d3f2aba985e0c707a577"></a>
constexpr allocator_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>allocator</b> ()</td></tr>
<tr class="memdesc:a458697f089f5d3f2aba985e0c707a577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the allocator. <br /></td></tr>
<tr class="separator:a458697f089f5d3f2aba985e0c707a577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4116dbd55a53014cef88f4f571cb0c64" id="r_a4116dbd55a53014cef88f4f571cb0c64"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a4116dbd55a53014cef88f4f571cb0c64">init_from_str_other</a> (<a class="el" href="structsimstr_1_1simple__str.html">s_str</a> other)</td></tr>
<tr class="memdesc:a4116dbd55a53014cef88f4f571cb0c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization from another string object.  <br /></td></tr>
<tr class="separator:a4116dbd55a53014cef88f4f571cb0c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e0afaaca95e435c77ecc4ab3f26b8d" id="r_a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a92e0afaaca95e435c77ecc4ab3f26b8d">init_str_repeat</a> (size_t repeat, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern)</td></tr>
<tr class="memdesc:a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">String repetition initialization.  <br /></td></tr>
<tr class="separator:a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d5032575e4c90cdb9a8bcd0aa8c735" id="r_a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a47d5032575e4c90cdb9a8bcd0aa8c735">init_symb_repeat</a> (size_t count, K pad)</td></tr>
<tr class="memdesc:a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character repetition initialization.  <br /></td></tr>
<tr class="separator:a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6ca99606646e8a2fb07f5808dae999" id="r_a5d6ca99606646e8a2fb07f5808dae999"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a5d6ca99606646e8a2fb07f5808dae999">init_str_expr</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:a5d6ca99606646e8a2fb07f5808dae999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization from a string expression.  <br /></td></tr>
<tr class="separator:a5d6ca99606646e8a2fb07f5808dae999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1090a808b0e761a7ecff753d80faebba" id="r_a1090a808b0e761a7ecff753d80faebba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a1090a808b0e761a7ecff753d80faebba">init_replaced</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0)</td></tr>
<tr class="memdesc:a1090a808b0e761a7ecff753d80faebba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization from string source with replacement.  <br /></td></tr>
<tr class="separator:a1090a808b0e761a7ecff753d80faebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt;<br />
class simstr::lstring&lt; K, N, forShared, Allocator &gt;</div><p>The mutable, owning string class. Contains an internal buffer for text of a given size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- symbol type. </td></tr>
    <tr><td class="paramname">N</td><td>- the size of the internal string buffer is at least N. </td></tr>
    <tr><td class="paramname">forShared</td><td>- allocate an external buffer in a format compatible with sstring. </td></tr>
    <tr><td class="paramname">Allocator</td><td>- allocator type.</td></tr>
  </table>
  </dd>
</dl>
<p>"Local" string. Stores a pointer to characters and the length of the string, followed by either the data itself up to N characters + zero, or if the data is longer than N, then the size of the allocated buffer. At the same time, if you plan to later move the result to sstring, then for a dynamic buffer +n bytes are allocated so as not to copy the data later. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2be8d42ca8175c4b1a92e27b980909a0" name="a2be8d42ca8175c4b1a92e27b980909a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be8d42ca8175c4b1a92e27b980909a0">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : size_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2be8d42ca8175c4b1a92e27b980909a0ae0156729d0c9b54b6917deaf5b6c30c0" name="a2be8d42ca8175c4b1a92e27b980909a0ae0156729d0c9b54b6917deaf5b6c30c0"></a>LocalCapacity&#160;</td><td class="fielddoc"><p>Size of internal buffer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdd649b8fc867ee9b324691920680575" name="afdd649b8fc867ee9b324691920680575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd649b8fc867ee9b324691920680575">&#9670;&#160;</a></span>lstring() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (std::is_constructible_v&lt;allocator_t, Args...&gt; &amp;&amp; sizeof...(Args) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e5503d97a198725d593e3518d159d3e" name="a5e5503d97a198725d593e3518d159d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5503d97a198725d593e3518d159d3e">&#9670;&#160;</a></span>lstring() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor from another string object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string object, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70a16988e9dffa98991caca6d5a9d99b" name="a70a16988e9dffa98991caca6d5a9d99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a16988e9dffa98991caca6d5a9d99b">&#9670;&#160;</a></span>lstring() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>repeat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String repetition constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeat</td><td>- number of repetitions. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the line to be repeated. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8fcf7732a4c93309d5ba65e131e8e94" name="ac8fcf7732a4c93309d5ba65e131e8e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fcf7732a4c93309d5ba65e131e8e94">&#9670;&#160;</a></span>lstring() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>pad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Character repetition constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- number of repetitions. </td></tr>
    <tr><td class="paramname">pad</td><td>- the character to be repeated. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb0896628d4b9c09f66c524431218d07" name="acb0896628d4b9c09f66c524431218d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0896628d4b9c09f66c524431218d07">&#9670;&#160;</a></span>lstring() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const StrExprForType&lt; K &gt; auto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>The constructor queries the string expression <code><a class="el" href="#a4e9a64c776ee14ef49bb01e84eb87889" title="String length.">length()</a></code>, allocates memory of the required size, and calls the <code><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place()</a></code> method to allocate result in buffer. </p>

</div>
</div>
<a id="a6ce0cd4e01e1fa526be905447e5913ea" name="a6ce0cd4e01e1fa526be905447e5913ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce0cd4e01e1fa526be905447e5913ea">&#9670;&#160;</a></span>lstring() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;StrType&lt; K &gt; From, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from string source with replacement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- the string object from which the source string is taken. </td></tr>
    <tr><td class="paramname">pattern</td><td>- substring to be replaced. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to be replaced with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position for searching substrings. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71b7f519594ae1b6a50b4b977cdd7969" name="a71b7f519594ae1b6a50b4b977cdd7969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b7f519594ae1b6a50b4b977cdd7969">&#9670;&#160;</a></span>lstring() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from another string of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71b8a2a5ca5a73407148cf67efac0e69" name="a71b8a2a5ca5a73407148cf67efac0e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b8a2a5ca5a73407148cf67efac0e69">&#9670;&#160;</a></span>lstring() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (sizeof...(Args) &gt; 0 &amp;&amp; std::is_convertible_v&lt;allocator_t, Args...&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy from another string of the same type, but with a different allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a233aaa30d88d5c157f6f4a4dec31f499" name="a233aaa30d88d5c157f6f4a4dec31f499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233aaa30d88d5c157f6f4a4dec31f499">&#9670;&#160;</a></span>lstring() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t I = const_lit_for&lt;K, T&gt;::Count, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String literal constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- string literal. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameter for initialization allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae595139d39bbb592c5e83139bef914cc" name="ae595139d39bbb592c5e83139bef914cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae595139d39bbb592c5e83139bef914cc">&#9670;&#160;</a></span>lstring() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for moving from a string of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8590b10bbfc4eb95a53a575bff2221f" name="ab8590b10bbfc4eb95a53a575bff2221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8590b10bbfc4eb95a53a575bff2221f">&#9670;&#160;</a></span>lstring() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename Op, typename... Args&gt; <br />
requires (std::is_constructible_v&lt;Allocator, Args...&gt; &amp;&amp; (std::is_invocable_v&lt;Op, <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&amp;&gt; || std::is_invocable_v&lt;Op, K*, size_t&gt;))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A fill constructor using a functor (see <a class="el" href="classsimstr_1_1str__mutable.html#a53aa57efa783f3d9484a4c9b09bd4f70" title="Fill a string buffer using a functor.">str_mutable::fill</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>- filling functions. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0275b9ec5edad56807286a9eabd613ff" name="a0275b9ec5edad56807286a9eabd613ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0275b9ec5edad56807286a9eabd613ff">&#9670;&#160;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a string expression to the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a8bb338bd949c276a8bd4b9bbc8f9ef5a" name="a8bb338bd949c276a8bd4b9bbc8f9ef5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb338bd949c276a8bd4b9bbc8f9ef5a">&#9670;&#160;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add another line to the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a39acae07e8fa0b0f40721cf7b7aa9129" name="a39acae07e8fa0b0f40721cf7b7aa9129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39acae07e8fa0b0f40721cf7b7aa9129">&#9670;&#160;</a></span>append_formatted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_formatted </td>
          <td>(</td>
          <td class="paramtype">const FmtString&lt; fmt_type, T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends std::format-formatted output to the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- format string, constant. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for std::format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="ae66589c8ea0f96cc3dd33ca9bba3a65e" name="ae66589c8ea0f96cc3dd33ca9bba3a65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66589c8ea0f96cc3dd33ca9bba3a65e">&#9670;&#160;</a></span>append_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_in </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a string expression starting at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- the position from which to add. First, the string is shortened to the specified value size, and then a string expression is added. </td></tr>
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>If the string is longer than <code>pos</code>, then it is shortened to this size, and then <code>expr</code> is added. </p>

</div>
</div>
<a id="a740d3b2e75a7ad8c08a8363cbfa9b4df" name="a740d3b2e75a7ad8c08a8363cbfa9b4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740d3b2e75a7ad8c08a8363cbfa9b4df">&#9670;&#160;</a></span>append_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_in </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add another line starting at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- the position from which to add. First, the string is shortened to the specified value size, and then another line is added. </td></tr>
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>If the string is longer than <code>pos</code>, then it is shortened to this size, and then <code>other</code> is added. </p>

</div>
</div>
<a id="a256725807b06cfe2009cf378c4a687f5" name="a256725807b06cfe2009cf378c4a687f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256725807b06cfe2009cf378c4a687f5">&#9670;&#160;</a></span>append_printf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_printf </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends sprintf formatted output to the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for sprintf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the row buffer size if necessary. </p>

</div>
</div>
<a id="adc3c063949d1d48ca056085eef1dccc3" name="adc3c063949d1d48ca056085eef1dccc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3c063949d1d48ca056085eef1dccc3">&#9670;&#160;</a></span>append_vformatted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_vformatted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends std::vformat-formatted output to the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- format string. </td></tr>
    <tr><td class="paramname">...</td><td>- arguments for std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="a48d3c0afd02f09b0f9d32f2a7f52522a" name="a48d3c0afd02f09b0f9d32f2a7f52522a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d3c0afd02f09b0f9d32f2a7f52522a">&#9670;&#160;</a></span>append_vformatted_n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_vformatted_n </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends std::vformat-formatted output to the end of the line, writing no more than the specified number of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_write</td><td>- the maximum number of characters to write. </td></tr>
    <tr><td class="paramname">format</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="a4213df62c3208dd26ae540122dcfa45d" name="a4213df62c3208dd26ae540122dcfa45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4213df62c3208dd26ae540122dcfa45d">&#9670;&#160;</a></span>as_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::as_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a number of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- the desired number type. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- check for overflow. </td></tr>
    <tr><td class="paramname">Base</td><td>- the base of the number, from -1 to 36, except 1.<ul>
<li>If 0: then tries to determine the base by the prefix 0[xX] as 16, 0 as 8, otherwise 10.</li>
<li>If -1: then tries to determine the base by prefixes:<ul>
<li>0 or 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
</ul>
</li>
<li>in other cases 10. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- skip whitespace characters at the beginning of the line. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- whether the '+' sign is allowed before a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - a number, the result of the transformation, how much it turned out, or 0 if it overflows. </dd></dl>

</div>
</div>
<a id="af860598fca0df848662d7d8578a8f6da" name="af860598fca0df848662d7d8578a8f6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af860598fca0df848662d7d8578a8f6da">&#9670;&#160;</a></span>as_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- the variable into which the result is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17421202713ebd4d62ddf175023f535" name="ac17421202713ebd4d62ddf175023f535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17421202713ebd4d62ddf175023f535">&#9670;&#160;</a></span>as_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to an integer. </p>
<p>Since <code>as_number(double&amp; t)</code> overrides the visibility of <code>as_number</code> from the base class, will have to add it again. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- number type, inferred from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- the variable into which the result is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c053de38bf2a0eab39cf1de5b0a21a" name="ad2c053de38bf2a0eab39cf1de5b0a21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c053de38bf2a0eab39cf1de5b0a21a">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::at </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the character at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- symbol index. For negative values, it is counted from the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>K - character.</dd></dl>
<p>Does not check for line boundaries. </p>

</div>
</div>
<a id="ac476d90d2e02d4e72e99f4b4e40f3fec" name="ac476d90d2e02d4e72e99f4b4e40f3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac476d90d2e02d4e72e99f4b4e40f3fec">&#9670;&#160;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename Impl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const K * simstr::null_terminated&lt; K, Impl &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a constant character buffer of a string. </p>
<dl class="section return"><dt>Returns</dt><dd>const K* - pointer to a constant string character buffer </dd></dl>

</div>
</div>
<a id="a537880538e549f94a3ce137d7cf33064" name="a537880538e549f94a3ce137d7cf33064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537880538e549f94a3ce137d7cf33064">&#9670;&#160;</a></span>change() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::change </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a piece of string with a string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position for replacement. </td></tr>
    <tr><td class="paramname">len</td><td>- length of the part to be replaced. </td></tr>
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a5a03860f5d616ab4850daa1778e13f57" name="a5a03860f5d616ab4850daa1778e13f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a03860f5d616ab4850daa1778e13f57">&#9670;&#160;</a></span>change() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::change </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a piece of string with another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position for replacement. </td></tr>
    <tr><td class="paramname">len</td><td>- length of the part to be replaced. </td></tr>
    <tr><td class="paramname">other</td><td>- the string this part is changed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a108d9cd0dc24f5d395e838a3ef20d846" name="a108d9cd0dc24f5d395e838a3ef20d846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d9cd0dc24f5d395e838a3ef20d846">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a0e5e10ff025504ee5d60e8c77f439003" name="a0e5e10ff025504ee5d60e8c77f439003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5e10ff025504ee5d60e8c77f439003">&#9670;&#160;</a></span>compare_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::compare_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character and not case sensitive ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a400250ea87cc59daa152dc9ddb57491f" name="a400250ea87cc59daa152dc9ddb57491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400250ea87cc59daa152dc9ddb57491f">&#9670;&#160;</a></span>compare_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::compare_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character without taking into account the case of Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="ac4d712294186e2e181910677ba9c3ca7" name="ac4d712294186e2e181910677ba9c3ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d712294186e2e181910677ba9c3ca7">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string contains the specified substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a id="a3c2498615b426546b65e9b6c4f973264" name="a3c2498615b426546b65e9b6c4f973264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2498615b426546b65e9b6c4f973264">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string to the specified buffer. </p>
<p>The method adds <code>\0</code> after the copied characters. Does not exceed buffer boundaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to buffer </td></tr>
    <tr><td class="paramname">bufSize</td><td>- buffer size in characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15504449e8d2a8f77832046b559ae0a8" name="a15504449e8d2a8f77832046b559ae0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15504449e8d2a8f77832046b559ae0a8">&#9670;&#160;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63742e2c0e55c85b0569f6a0004e5418" name="a63742e2c0e55c85b0569f6a0004e5418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63742e2c0e55c85b0569f6a0004e5418">&#9670;&#160;</a></span>ends_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::ends_with_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring in a case-insensitive ASCII character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a535d655a6702861b788830a1d266e48f" name="a535d655a6702861b788830a1d266e48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535d655a6702861b788830a1d266e48f">&#9670;&#160;</a></span>ends_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::ends_with_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b9b0cb780c465cb9b6bd925d712ff07" name="a3b9b0cb780c465cb9b6bd925d712ff07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9b0cb780c465cb9b6bd925d712ff07">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String comparison for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="afa9fca49d189fd0d760ffe8aed1485f1" name="afa9fca49d189fd0d760ffe8aed1485f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9fca49d189fd0d760ffe8aed1485f1">&#9670;&#160;</a></span>equal_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::equal_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is equal to another string, character-by-character-insensitive, of ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="adbf0990c46a280cd363da46bef12e02f" name="adbf0990c46a280cd363da46bef12e02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf0990c46a280cd363da46bef12e02f">&#9670;&#160;</a></span>equal_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::equal_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is equal to another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a53aa57efa783f3d9484a4c9b09bd4f70" name="a53aa57efa783f3d9484a4c9b09bd4f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53aa57efa783f3d9484a4c9b09bd4f70">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a string buffer using a functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position to fill. </td></tr>
    <tr><td class="paramname">fillFunction</td><td>- size_t(K*, size_t) functor that receives the address of the string buffer and its capacity, returning the required string size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>The function calls the functor, passing it the address of the string buffer and its capacity. The functor can modify the buffer within the allocated capacity, and must return the size of the resulting string. As long as the returned size is larger than capacity (i.e. the string cannot fit into the buffer), memory of at least the returned size is allocated and the functor is called again. Until the returned size fits into the string buffer. This size becomes the length of the line. </p>

</div>
</div>
<a id="a129d72cc64be6029f10bbe1f8385f3ea" name="a129d72cc64be6029f10bbe1f8385f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129d72cc64be6029f10bbe1f8385f3ea">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ab38e5cc7893a20e69cdf03d88232b49c" name="ab38e5cc7893a20e69cdf03d88232b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38e5cc7893a20e69cdf03d88232b49c">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="aa6d568443f3ed5752279098b9a488655" name="aa6d568443f3ed5752279098b9a488655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d568443f3ed5752279098b9a488655">&#9670;&#160;</a></span>find_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all occurrences of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- the maximum number of occurrences to be processed, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;size_t&gt; - a vector with the positions of the beginnings of the found occurrences. </dd></dl>

</div>
</div>
<a id="a8bcde5878d3d7fd5138d38ff2f1df4d2" name="a8bcde5878d3d7fd5138d38ff2f1df4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcde5878d3d7fd5138d38ff2f1df4d2">&#9670;&#160;</a></span>find_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="aab67ba06c8637f93984e45cf349c3eb8" name="aab67ba06c8637f93984e45cf349c3eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab67ba06c8637f93984e45cf349c3eb8">&#9670;&#160;</a></span>find_end_of_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_end_of_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the last occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the last occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ae281c63da2d81ef8aac65a2dad77eb93" name="ae281c63da2d81ef8aac65a2dad77eb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae281c63da2d81ef8aac65a2dad77eb93">&#9670;&#160;</a></span>find_end_of_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_end_of_last_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the last occurrence of a substring in this string, or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the last occurrence of the substring, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a2c56c3345019c8d5dc20717092d52101" name="a2c56c3345019c8d5dc20717092d52101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c56c3345019c8d5dc20717092d52101">&#9670;&#160;</a></span>find_end_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_end_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the first occurrence of a substring in this string, or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the occurrence of the substring, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a63ff5e918afcc8e1fba9a3ec19c47897" name="a63ff5e918afcc8e1fba9a3ec19c47897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff5e918afcc8e1fba9a3ec19c47897">&#9670;&#160;</a></span>find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character not from the given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the character set. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a643bf839edef0abbd43c3f3654e8e700" name="a643bf839edef0abbd43c3f3654e8e700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bf839edef0abbd43c3f3654e8e700">&#9670;&#160;</a></span>find_first_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="aad5ad9c702f21003a272469cb1edcbf3" name="aad5ad9c702f21003a272469cb1edcbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5ad9c702f21003a272469cb1edcbf3">&#9670;&#160;</a></span>find_first_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_first_of_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t, size_t&gt; - a pair from the position of the found occurrence and the number of the found character in the set, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a0564461ab81bfbb6c5bd8b4c7e5a496e" name="a0564461ab81bfbb6c5bd8b4c7e5a496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0564461ab81bfbb6c5bd8b4c7e5a496e">&#9670;&#160;</a></span>find_last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a72a2c0b10e857c245f67a2abd7c1a2f0" name="a72a2c0b10e857c245f67a2abd7c1a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a2c0b10e857c245f67a2abd7c1a2f0">&#9670;&#160;</a></span>find_last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the last occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a775a7c8e218ab3223f0248f225076b7c" name="a775a7c8e218ab3223f0248f225076b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775a7c8e218ab3223f0248f225076b7c">&#9670;&#160;</a></span>find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character not from the given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the character set. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a73806fa93c9ec619ba93d479d413ea0f" name="a73806fa93c9ec619ba93d479d413ea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73806fa93c9ec619ba93d479d413ea0f">&#9670;&#160;</a></span>find_last_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ab630d62252bf1210f573a8c7222942c8" name="ab630d62252bf1210f573a8c7222942c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab630d62252bf1210f573a8c7222942c8">&#9670;&#160;</a></span>find_last_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last_of_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t, size_t&gt; - a pair from the position of the found occurrence and the number of the found character in the set, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a6a5bdd0e7ab4f7e64e1e776f4dabe11c" name="a6a5bdd0e7ab4f7e64e1e776f4dabe11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5bdd0e7ab4f7e64e1e776f4dabe11c">&#9670;&#160;</a></span>find_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the last occurrence of a substring in this string or the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position at which the substring begins, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a762c55d09b34ba2b7b5f9f10783da662" name="a762c55d09b34ba2b7b5f9f10783da662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762c55d09b34ba2b7b5f9f10783da662">&#9670;&#160;</a></span>find_or_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a character in this string or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or string length if not found. </dd></dl>

</div>
</div>
<a id="ac029fd5412ed114bfefbdddba2c50167" name="ac029fd5412ed114bfefbdddba2c50167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac029fd5412ed114bfefbdddba2c50167">&#9670;&#160;</a></span>find_or_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string or the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position at which the substring begins, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a40ab0482ea5f02bc0c3097bed6c9a5fa" name="a40ab0482ea5f02bc0c3097bed6c9a5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab0482ea5f02bc0c3097bed6c9a5fa">&#9670;&#160;</a></span>find_or_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_or_throw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string or throw an exception. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exc</td><td>- exception type. </td></tr>
    <tr><td class="paramname">Args...</td><td>- types of parameters for constructing an exception, inferred from the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
    <tr><td class="paramname">args</td><td>- arguments for the exception constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the substring occurrence, or throws an Exc exception if not found. </dd></dl>

</div>
</div>
<a id="a8185ccf8fc2297b628cce3c83b6a0b4c" name="a8185ccf8fc2297b628cce3c83b6a0b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8185ccf8fc2297b628cce3c83b6a0b4c">&#9670;&#160;</a></span>for_all_finded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::for_all_finded </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor on all found occurrences of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is a functor that takes a string. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- the maximum number of occurrences to be processed, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bfceeaa8961165845fa25fc652e31b0" name="a3bfceeaa8961165845fa25fc652e31b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfceeaa8961165845fa25fc652e31b0">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::format </td>
          <td>(</td>
          <td class="paramtype">const FmtString&lt; fmt_type, T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a string using std::format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- format string, constant. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for std::format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="ae8ca9bf60dd607b6b8721ec84abba5d5" name="ae8ca9bf60dd607b6b8721ec84abba5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ca9bf60dd607b6b8721ec84abba5d5">&#9670;&#160;</a></span>format_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::format_from </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FmtString&lt; fmt_type, T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends std::format-formatted output starting at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position of adding. </td></tr>
    <tr><td class="paramname">format</td><td>- format string, constant. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for std::format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="a5659e7fb47dfb6bd6736a1b454ffde92" name="a5659e7fb47dfb6bd6736a1b454ffde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5659e7fb47dfb6bd6736a1b454ffde92">&#9670;&#160;</a></span>from_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::from_to </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the substring <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a> from position from to position to (not including it). </p>
<p>For performance reasons, the method does not check for line boundaries in any way, use in scenarios when you know for sure that these are positions inside the line and to &gt;= from. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position. </td></tr>
    <tr><td class="paramname">to</td><td>- final position (not included in the result). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a4116dbd55a53014cef88f4f571cb0c64" name="a4116dbd55a53014cef88f4f571cb0c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4116dbd55a53014cef88f4f571cb0c64">&#9670;&#160;</a></span>init_from_str_other()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_from_str_other </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization from another string object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string object, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1090a808b0e761a7ecff753d80faebba" name="a1090a808b0e761a7ecff753d80faebba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1090a808b0e761a7ecff753d80faebba">&#9670;&#160;</a></span>init_replaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_replaced </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization from string source with replacement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- the string object from which the source string is taken. </td></tr>
    <tr><td class="paramname">pattern</td><td>- substring to be replaced. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to be replaced with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position for searching substrings. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d6ca99606646e8a2fb07f5808dae999" name="a5d6ca99606646e8a2fb07f5808dae999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6ca99606646e8a2fb07f5808dae999">&#9670;&#160;</a></span>init_str_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_str_expr </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization from a string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- string expression.</td></tr>
  </table>
  </dd>
</dl>
<p>Queries the string expression <code><a class="el" href="#a4e9a64c776ee14ef49bb01e84eb87889" title="String length.">length()</a></code>, allocates memory of the required size, and calls the <code><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place()</a></code> method to allocate result in buffer. </p>

</div>
</div>
<a id="a92e0afaaca95e435c77ecc4ab3f26b8d" name="a92e0afaaca95e435c77ecc4ab3f26b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e0afaaca95e435c77ecc4ab3f26b8d">&#9670;&#160;</a></span>init_str_repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_str_repeat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>repeat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String repetition initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeat</td><td>- number of repetitions. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the line to be repeated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d5032575e4c90cdb9a8bcd0aa8c735" name="a47d5032575e4c90cdb9a8bcd0aa8c735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d5032575e4c90cdb9a8bcd0aa8c735">&#9670;&#160;</a></span>init_symb_repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_symb_repeat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>pad</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Character repetition initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- number of repetitions. </td></tr>
    <tr><td class="paramname">pad</td><td>- the character to be repeated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01abc4c1daa39bb99451be642dc86f48" name="a01abc4c1daa39bb99451be642dc86f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01abc4c1daa39bb99451be642dc86f48">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a string expression at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>- insertion position. </td></tr>
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a81a87ca9286d27c944b0453df89e7f92" name="a81a87ca9286d27c944b0453df89e7f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a87ca9286d27c944b0453df89e7f92">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a line at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>- insertion position. </td></tr>
    <tr><td class="paramname">other</td><td>- the string to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a9b002a3618bbfcebc945cef197a397a1" name="a9b002a3618bbfcebc945cef197a397a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b002a3618bbfcebc945cef197a397a1">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>strings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_empty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate strings from the container into one string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>- container with strings. </td></tr>
    <tr><td class="paramname">delimiter</td><td>- delimiter added between lines. </td></tr>
    <tr><td class="paramname">tail</td><td>- add a separator after the last line. </td></tr>
    <tr><td class="paramname">skip_empty</td><td>- skip empty lines without adding a separator. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>The function is used to merge a container of strings into one delimited string. </p><div class="fragment"><div class="line">std::vector&lt;ssa&gt; strings = get_strings();</div>
<div class="line">ssa delim = get_current_delimiter();</div>
<div class="line"><span class="keyword">auto</span> line = <a class="code hl_function" href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">lstringa&lt;200&gt;::join</a>(strings, delimiter);</div>
<div class="ttc" id="aclasssimstr_1_1str__storable_html_a9b002a3618bbfcebc945cef197a397a1"><div class="ttname"><a href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">simstr::lstring&lt; u8s, N &gt;::join</a></div><div class="ttdeci">static my_type join(const T &amp;strings, s_str delimiter, bool tail=false, bool skip_empty=false, Args &amp;&amp;... args)</div><div class="ttdef"><b>Definition</b> sstring.h:1199</div></div>
</div><!-- fragment --><p> It is worth noting that if the separator is known in advance, it is better to use the string expression <code>e_join</code>. </p><div class="fragment"><div class="line">std::vector&lt;ssa&gt; strings = get_strings();</div>
<div class="line">lstringa&lt;200&gt; line{<a class="code hl_function" href="group___str_exprs.html#gafd2e6b8a52bfe20c0b86d25f9f78cb52">e_join</a>(strings, <span class="stringliteral">&quot;/&quot;</span>)};</div>
<div class="ttc" id="agroup___str_exprs_html_gafd2e6b8a52bfe20c0b86d25f9f78cb52"><div class="ttname"><a href="group___str_exprs.html#gafd2e6b8a52bfe20c0b86d25f9f78cb52">simstr::e_join</a></div><div class="ttdeci">constexpr auto e_join(const T &amp;s, L &amp;&amp;d)</div><div class="ttdoc">Get a string expression concatenating the strings in the container into a single string with the give...</div><div class="ttdef"><b>Definition</b> strexpr.h:2688</div></div>
</div><!-- fragment --><p> In this case, the compiler can better optimize the string merging code. </p>

</div>
</div>
<a id="a44ede528e694988f26555e91cf9a1ca2" name="a44ede528e694988f26555e91cf9a1ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ede528e694988f26555e91cf9a1ca2">&#9670;&#160;</a></span>less_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::less_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is smaller than another string, character-by-character-insensitive, ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the string is smaller. </dd></dl>

</div>
</div>
<a id="a4e79e99462478b57d62873f7942ff2b6" name="a4e79e99462478b57d62873f7942ff2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79e99462478b57d62873f7942ff2b6">&#9670;&#160;</a></span>less_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::less_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is smaller than another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the string is smaller. </dd></dl>

</div>
</div>
<a id="ac0c4239efb3b35bfcb99b61feff08156" name="ac0c4239efb3b35bfcb99b61feff08156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c4239efb3b35bfcb99b61feff08156">&#9670;&#160;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert first plane characters (&lt;0xFFFF) to lowercase Unicode. </p>
<p>Case is changed by simplified tables, where one code_point is always changed to one code_point (but for UTF-8 it is possible that the length in code units will change). </p><dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a21f5a8e01bd18d94b873390bdd5eee8d" name="a21f5a8e01bd18d94b873390bdd5eee8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f5a8e01bd18d94b873390bdd5eee8d">&#9670;&#160;</a></span>lower_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::lower_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert ASCII characters to lowercase. </p>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a8d51ac2887746e40214eeee7d52460f4" name="a8d51ac2887746e40214eeee7d52460f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d51ac2887746e40214eeee7d52460f4">&#9670;&#160;</a></span>lowered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::lowered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in lowercase Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - lowercase copy of the string. </dd></dl>

</div>
</div>
<a id="a7946e4e405f908fd85c896bd75f67d72" name="a7946e4e405f908fd85c896bd75f67d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7946e4e405f908fd85c896bd75f67d72">&#9670;&#160;</a></span>lowered_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::lowered_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the passed string in lowercase Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>Case is changed by simplified tables, where one code_point is always changed to one code_point (but for UTF-8 it is possible that the length in code units will change). </p>

</div>
</div>
<a id="ad2f36df5ff2422e43919e74d965f24a4" name="ad2f36df5ff2422e43919e74d965f24a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f36df5ff2422e43919e74d965f24a4">&#9670;&#160;</a></span>lowered_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::lowered_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in lowercase ASCII characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - lowercase copy of the string. </dd></dl>

</div>
</div>
<a id="a95c800534b214e4473b6f59c3d761dc4" name="a95c800534b214e4473b6f59c3d761dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c800534b214e4473b6f59c3d761dc4">&#9670;&#160;</a></span>lowered_only_ascii_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::lowered_only_ascii_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the passed string in lowercase ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a507a43e6ebcc51e6409874712abbbd63" name="a507a43e6ebcc51e6409874712abbbd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507a43e6ebcc51e6409874712abbbd63">&#9670;&#160;</a></span>mid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string as "string chunk". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If the string size is exceeded, it will return an empty string. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". When going beyond the line, it will return everything up to the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="af93a700258bc7492e53ceb2acf414315" name="af93a700258bc7492e53ceb2acf414315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93a700258bc7492e53ceb2acf414315">&#9670;&#160;</a></span>operator const K *()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::operator const K * </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator to a null-terminated C string. </p>
<dl class="section return"><dt>Returns</dt><dd>const K* - pointer to the beginning of the line. </dd></dl>

</div>
</div>
<a id="a32cb440524f81da0e00cfa303cb4fab6" name="a32cb440524f81da0e00cfa303cb4fab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cb440524f81da0e00cfa303cb4fab6">&#9670;&#160;</a></span>operator K*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator K* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the string buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>K* - pointer to the string buffer. </dd></dl>

</div>
</div>
<a id="abcae77eab91707d4b3fa578dde83d34a" name="abcae77eab91707d4b3fa578dde83d34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcae77eab91707d4b3fa578dde83d34a">&#9670;&#160;</a></span>operator s_str_nt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::operator <a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </dd></dl>

</div>
</div>
<a id="a9959513e8a072c51620248c4a29f4196" name="a9959513e8a072c51620248c4a29f4196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9959513e8a072c51620248c4a29f4196">&#9670;&#160;</a></span>operator std::basic_string&lt; D, Traits, Allocator &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator std::basic_string&lt; D, Traits, Allocator &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::basic_string. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="ab4c6b4c365f05e609a7b22cbf37b39c6" name="ab4c6b4c365f05e609a7b22cbf37b39c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c6b4c365f05e609a7b22cbf37b39c6">&#9670;&#160;</a></span>operator std::basic_string_view&lt; D, Traits &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator std::basic_string_view&lt; D, Traits &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::basic_string_view. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a916218a7a75a3866a9d3d0da9334653c" name="a916218a7a75a3866a9d3d0da9334653c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916218a7a75a3866a9d3d0da9334653c">&#9670;&#160;</a></span>operator str_piece()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert itself to a "string chunk" that includes the entire string. </p>
<dl class="section return"><dt>Returns</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="ace8f275b33545d2491850f49ba3b7876" name="ace8f275b33545d2491850f49ba3b7876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8f275b33545d2491850f49ba3b7876">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string as "str_src". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>.</dd></dl>
<p>If <code>from</code> is less than zero, then <code>-from</code> characters are counted from the end of the line towards the beginning. If <code>len</code> is less than or equal to zero, then count <code>-len</code> characters from the end of the line</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, 2) == <span class="stringliteral">&quot;56&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5) == <span class="stringliteral">&quot;56789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, -1) == <span class="stringliteral">&quot;5678&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3) == <span class="stringliteral">&quot;789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3, 2) == <span class="stringliteral">&quot;78&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-4, -1) == <span class="stringliteral">&quot;678&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afa5514cee68803e4a0a18e648cb5cfc0" name="afa5514cee68803e4a0a18e648cb5cfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5514cee68803e4a0a18e648cb5cfc0">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a string expression to the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a885c6a5a9ecf6417993824dbb4425af6" name="a885c6a5a9ecf6417993824dbb4425af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885c6a5a9ecf6417993824dbb4425af6">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add another line to the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a4a1cad4ba4af2bdd831580151cb32962" name="a4a1cad4ba4af2bdd831580151cb32962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1cad4ba4af2bdd831580151cb32962">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a string with the fill method from position zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillFunction</td><td>- string filling functor, size_t(K*, size_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a0a5d59fd9e97d25cc5a9940c19ab796c" name="a0a5d59fd9e97d25cc5a9940c19ab796c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5d59fd9e97d25cc5a9940c19ab796c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the passed functor, passing a reference to itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillFunction</td><td>-  void(my_type&amp;). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a01b1fdf213da8dc5cdaf6211904ee690" name="a01b1fdf213da8dc5cdaf6211904ee690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b1fdf213da8dc5cdaf6211904ee690">&#9670;&#160;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a string with the fill method after the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillFunction</td><td>- string filling functor, size_t(K*, size_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="ac34637c1f071ac6e6faa0237a092cc61" name="ac34637c1f071ac6e6faa0237a092cc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34637c1f071ac6e6faa0237a092cc61">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad63f315c4a97ee6ad1e2b045b9f5f9e0" name="ad63f315c4a97ee6ad1e2b045b9f5f9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63f315c4a97ee6ad1e2b045b9f5f9e0">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator between a string and a string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is a string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19f351477923bb3ca090955866e4315" name="ab19f351477923bb3ca090955866e4315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19f351477923bb3ca090955866e4315">&#9670;&#160;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator from a string of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a895f17a8dd5ef18c2ea0120f785d84cb" name="a895f17a8dd5ef18c2ea0120f785d84cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895f17a8dd5ef18c2ea0120f785d84cb">&#9670;&#160;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const StrExprForType&lt; K &gt; auto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String expression appending operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- a string expression materialized into the string buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself.</dd></dl>
<p>If anything in a string expression refers to parts of the same string, then the result is undefined. </p>

</div>
</div>
<a id="a44dda5e47ad2a1aba0861c7b1179a2e0" name="a44dda5e47ad2a1aba0861c7b1179a2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dda5e47ad2a1aba0861c7b1179a2e0">&#9670;&#160;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator by moving from a string of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="ad1dbdd5c648b4b399b4b8c147fc99d43" name="ad1dbdd5c648b4b399b4b8c147fc99d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dbdd5c648b4b399b4b8c147fc99d43">&#9670;&#160;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator from <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a2731727eb853928098f7051a0dca8995" name="a2731727eb853928098f7051a0dca8995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2731727eb853928098f7051a0dca8995">&#9670;&#160;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t S = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String literal assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- string literal, copied to the string buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a1ddd0a1f9b25247465fb55c79b58826d" name="a1ddd0a1f9b25247465fb55c79b58826d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddd0a1f9b25247465fb55c79b58826d">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator comparing strings for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="ac19dc728f9d7edafbd85a52e70b46376" name="ac19dc728f9d7edafbd85a52e70b46376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19dc728f9d7edafbd85a52e70b46376">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for comparing a string and a string literal for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af893677739e0d24418f6acc0a29090cc" name="af893677739e0d24418f6acc0a29090cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af893677739e0d24418f6acc0a29090cc">&#9670;&#160;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::place </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string to the specified buffer. </p>
<p>The method assumes that the size of the allocated buffer is sufficient for the entire line, i.e. <code><a class="el" href="#a4e9a64c776ee14ef49bb01e84eb87889" title="String length.">length()</a></code> was previously requested. Does not add <code>\0</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the character after the end of the symbols placed in the buffer. </dd></dl>

</div>
</div>
<a id="ae37c68155961c5c7b1609aa1b873b8d3" name="ae37c68155961c5c7b1609aa1b873b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37c68155961c5c7b1609aa1b873b8d3">&#9670;&#160;</a></span>prefix_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::prefix_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this string is the beginning of another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab2f039d8eb7f384b96ceb0d7f55cf7c" name="aab2f039d8eb7f384b96ceb0d7f55cf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2f039d8eb7f384b96ceb0d7f55cf7c">&#9670;&#160;</a></span>prepend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a string expression to the beginning of a line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a37c3fa40f6a3f82eb83e0b7c61f1a0fd" name="a37c3fa40f6a3f82eb83e0b7c61f1a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c3fa40f6a3f82eb83e0b7c61f1a0fd">&#9670;&#160;</a></span>prepend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add another line to the beginning of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a3f4c37cfab5e6a48dd47c8e7754e6530" name="a3f4c37cfab5e6a48dd47c8e7754e6530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4c37cfab5e6a48dd47c8e7754e6530">&#9670;&#160;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::printf </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a string using sprintf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for sprintf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="a875205d5df5bc2d8b825ba8edd79b22a" name="a875205d5df5bc2d8b825ba8edd79b22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875205d5df5bc2d8b825ba8edd79b22a">&#9670;&#160;</a></span>printf_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::printf_from </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends sprintf formatted output starting at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position of adding. </td></tr>
    <tr><td class="paramname">format</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for sprintf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="a5eb2a4a250dc0fe4c7c71ecd51745259" name="a5eb2a4a250dc0fe4c7c71ecd51745259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb2a4a250dc0fe4c7c71ecd51745259">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove part of a line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- the position from which to delete. </td></tr>
    <tr><td class="paramname">len</td><td>- length of the part to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="ac0ee55594becb6b2c2b98df722cc7a33" name="ac0ee55594becb6b2c2b98df722cc7a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ee55594becb6b2c2b98df722cc7a33">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace occurrences of a substring with another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">repl</td><td>- replacement string. </td></tr>
    <tr><td class="paramname">offset</td><td>- the starting position for the search. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="ad86b3a4c468f51e3ab3f7ba9e8786f9f" name="ad86b3a4c468f51e3ab3f7ba9e8786f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86b3a4c468f51e3ab3f7ba9e8786f9f">&#9670;&#160;</a></span>replace_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::replace_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the source string, replacing occurrences of substrings with another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">repl</td><td>- replacement string. </td></tr>
    <tr><td class="paramname">offset</td><td>- the starting position for the search. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a606b0373189a0fb89bce3801e972e46a" name="a606b0373189a0fb89bce3801e972e46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606b0373189a0fb89bce3801e972e46a">&#9670;&#160;</a></span>replaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::replaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string with occurrences of substrings replaced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to replace with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position of the search. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R a string of the given type, by default the same whose method was called. </dd></dl>

</div>
</div>
<a id="aafdcc9ae62c73be2c37e4a40c3366ded" name="aafdcc9ae62c73be2c37e4a40c3366ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdcc9ae62c73be2c37e4a40c3366ded">&#9670;&#160;</a></span>replaced_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::replaced_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the passed string with substrings replaced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">pattern</td><td>- substring to be replaced. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to be replaced with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position for searching substrings. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9b8b36c694de6015158b41d597e7551" name="ae9b8b36c694de6015158b41d597e7551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b8b36c694de6015158b41d597e7551">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a buffer large enough to hold newSize characters plus a terminating null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>- new string size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>K* - pointer to the buffer.</dd></dl>
<p>The contents of the string are preserved. When increasing the buffer, the size allocated is no larger than the requested one. The string size is set to newSize. </p>

</div>
</div>
<a id="aa0c80a142e77e0927ab5a17a17ff5ef7" name="aa0c80a142e77e0927ab5a17a17ff5ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c80a142e77e0927ab5a17a17ff5ef7">&#9670;&#160;</a></span>reserve_no_preserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::reserve_no_preserve </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a buffer large enough to hold newSize characters plus a terminating null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>- new string size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>K* - pointer to the buffer.</dd></dl>
<p>The contents of the buffer are undefined and the old contents are not guaranteed to be retained. The string size is set to newSize. </p>

</div>
</div>
<a id="abc32346401f3c9db8cee093b193524e7" name="abc32346401f3c9db8cee093b193524e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc32346401f3c9db8cee093b193524e7">&#9670;&#160;</a></span>set_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::set_size </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the current string, allocating space if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>- new string size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>K* - pointer to the buffer.</dd></dl>
<p>The contents of the string are preserved. When increasing the buffer size, at least 2 times the old buffer size are allocated. The string size is set to newSize. </p>

</div>
</div>
<a id="aa2732ccf421fcd1ba606addcca7e6e42" name="aa2732ccf421fcd1ba606addcca7e6e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2732ccf421fcd1ba606addcca7e6e42">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the string in characters. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="a4ad7e9416ed3abc8689034463f497e6b" name="a4ad7e9416ed3abc8689034463f497e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad7e9416ed3abc8689034463f497e6b">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into substrings using a given delimiter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- container type for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- delimiter. </td></tr>
    <tr><td class="paramname">offset</td><td>- the position to start searching for the separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - container with the result. </dd></dl>

</div>
</div>
<a id="adffb295777b82a1475a4fc0d9754481b" name="adffb295777b82a1475a4fc0d9754481b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffb295777b82a1475a4fc0d9754481b">&#9670;&#160;</a></span>splitf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::splitf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>beforeFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into parts at a given delimiter, possibly applying a functor to each substring. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of container for folding substrings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- substring delimiter. </td></tr>
    <tr><td class="paramname">beforeFunc</td><td>- a functor to apply to the found substrings, before placing them in the result. </td></tr>
    <tr><td class="paramname">offset</td><td>- the position to start searching for the separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - result.</dd></dl>
<p>For each substring found, if the functor can accept it, the functor is called, and the substring is assigned to the result of the functor. Next, the substring tries to be added to the result, calling one of its methods - <code>emplace_back</code>, <code>push_back</code>, <code>operator[]</code>. If none of this method no, nothing is done, just calling the functor. <code>operator[]</code> tries to apply if the result can have a size via <code>std::size</code> and we do not exceed this size. At the same time, if the found substring turns out to match the entire string, the result is attempted place not a substring, but the entire string object, which allows, for example, to effectively copy sstring. </p>

</div>
</div>
<a id="ab3f6c202d1c1723297d46a45d82c5808" name="ab3f6c202d1c1723297d46a45d82c5808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6c202d1c1723297d46a45d82c5808">&#9670;&#160;</a></span>splitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::splitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <code>Splitter</code> object by the given splitter, which allows sequential get substrings using the <code>next()</code> method while <code>is_done()</code> is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Splitter&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a2febfef44dabdf863a74db2049410e9f" name="a2febfef44dabdf863a74db2049410e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2febfef44dabdf863a74db2049410e9f">&#9670;&#160;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string begins with the given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9409e48b2f182546b7f7186af2477e" name="a6d9409e48b2f182546b7f7186af2477e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9409e48b2f182546b7f7186af2477e">&#9670;&#160;</a></span>starts_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::starts_with_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string begins with the given substring in a case-insensitive ASCII character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26465c7fdac87e8d215e836bdbf6e8c3" name="a26465c7fdac87e8d215e836bdbf6e8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26465c7fdac87e8d215e836bdbf6e8c3">&#9670;&#160;</a></span>starts_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::starts_with_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string starts with the given substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa77c31da012cf5cc23e0a60c1888cec2" name="aa77c31da012cf5cc23e0a60c1888cec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77c31da012cf5cc23e0a60c1888cec2">&#9670;&#160;</a></span>str_mid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::str_mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string with an object of the same type to which the method is applied, similar to mid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If the string size is exceeded, it will return an empty string. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". When going beyond the line, it will return everything up to the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the same type to which the method is applied. </dd></dl>

</div>
</div>
<a id="a610d501d16ab38c3efb1427f14ea7f67" name="a610d501d16ab38c3efb1427f14ea7f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d501d16ab38c3efb1427f14ea7f67">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::strcmp </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare with C-string character by character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a512eaf3c2c8736f3021a5bbe60823866" name="a512eaf3c2c8736f3021a5bbe60823866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512eaf3c2c8736f3021a5bbe60823866">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a substring. Works similarly to operator(), only the result is the same type as the method applied to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If less than zero, it is counted from the end of the line towards the beginning. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". If less than or equal to zero, then count len characters from the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type - a substring, an object of the same type to which the method is applied. </dd></dl>

</div>
</div>
<a id="aa1af52e61e73c687a34ff6978304edc3" name="aa1af52e61e73c687a34ff6978304edc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af52e61e73c687a34ff6978304edc3">&#9670;&#160;</a></span>to_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_double </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="a037d07ad0ee024d983927cec3ee81908" name="a037d07ad0ee024d983927cec3ee81908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037d07ad0ee024d983927cec3ee81908">&#9670;&#160;</a></span>to_double_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_double_hex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string in hex form to double. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="afa40ca4ad70df9ec0941599b88c443dc" name="afa40ca4ad70df9ec0941599b88c443dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa40ca4ad70df9ec0941599b88c443dc">&#9670;&#160;</a></span>to_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">convert_result&lt; T &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a number of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- the desired number type. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- check for overflow. </td></tr>
    <tr><td class="paramname">Base</td><td>- the base of the number, from -1 to 36, except 1.<ul>
<li>If 0: then tries to determine the base by the prefix 0[xX] as 16, 0 as 8, otherwise 10</li>
<li>If -1: then tries to determine the base by prefixes:<ul>
<li>0 or 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
</ul>
</li>
<li>in other cases 10. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- skip whitespace characters at the beginning of the line. All characters with ASCII codes &lt;= 32 are skipped. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- whether the '+' sign is allowed before a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>convert_result&lt;T&gt; - a tuple of the received number, the success of the conversion and the number of characters processed. </dd></dl>

</div>
</div>
<a id="aed242dbe057042c9f72f9514aaf861ee" name="aed242dbe057042c9f72f9514aaf861ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed242dbe057042c9f72f9514aaf861ee">&#9670;&#160;</a></span>to_nts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::to_nts </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a> starting at the given character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- position of the starting character, default 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>, </dd></dl>

</div>
</div>
<a id="a53d19b3fba03bfd481d2a3b3def766af" name="a53d19b3fba03bfd481d2a3b3def766af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d19b3fba03bfd481d2a3b3def766af">&#9670;&#160;</a></span>to_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert itself to a "string chunk" that includes the entire string. </p>
<dl class="section return"><dt>Returns</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="adc816f095922a510dfe466db1905fc63" name="adc816f095922a510dfe466db1905fc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc816f095922a510dfe466db1905fc63">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; D, Traits, Allocator &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::basic_string. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a1f2af1ee80a32a77ad30cffbf6987107" name="a1f2af1ee80a32a77ad30cffbf6987107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2af1ee80a32a77ad30cffbf6987107">&#9670;&#160;</a></span>to_sv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string_view&lt; D &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_sv </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::basic_string_view. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="ab697bf9b655f0ed7762ee830efb25b18" name="ab697bf9b655f0ed7762ee830efb25b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab697bf9b655f0ed7762ee830efb25b18">&#9670;&#160;</a></span>trim() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove whitespace from the beginning and end of a line. </p>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a14ae0d5f1aef083fc2c84274cd794c74" name="a14ae0d5f1aef083fc2c84274cd794c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ae0d5f1aef083fc2c84274cd794c74">&#9670;&#160;</a></span>trim() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in the passed string at the beginning and end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="af25c5f127c99392c53470f0a9919b504" name="af25c5f127c99392c53470f0a9919b504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25c5f127c99392c53470f0a9919b504">&#9670;&#160;</a></span>trim() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in a string literal at the beginning and end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a244334bd105c03fa510804b31707996f" name="a244334bd105c03fa510804b31707996f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244334bd105c03fa510804b31707996f">&#9670;&#160;</a></span>trim_left() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove whitespace at the beginning of a line. </p>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a2e26d84497e19b7bbfd83da9cc593310" name="a2e26d84497e19b7bbfd83da9cc593310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e26d84497e19b7bbfd83da9cc593310">&#9670;&#160;</a></span>trim_left() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in the passed string at the beginning of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a65b013501c10698abf323333d17ab2ac" name="a65b013501c10698abf323333d17ab2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b013501c10698abf323333d17ab2ac">&#9670;&#160;</a></span>trim_left() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in a string literal at the beginning of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a7ff45375785f56489e1e6d8f9d978120" name="a7ff45375785f56489e1e6d8f9d978120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff45375785f56489e1e6d8f9d978120">&#9670;&#160;</a></span>trim_left_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in the passed string, as well as whitespace, at the beginning of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a5f668bb7ec9de3acf40727167787e630" name="a5f668bb7ec9de3acf40727167787e630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f668bb7ec9de3acf40727167787e630">&#9670;&#160;</a></span>trim_left_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in a string literal, as well as whitespace, at the beginning of a line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal containing the characters to be removed.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a8a8daf67d09761a0834881d00562596f" name="a8a8daf67d09761a0834881d00562596f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8daf67d09761a0834881d00562596f">&#9670;&#160;</a></span>trim_right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove whitespace from the end of a line. </p>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a8c100b87423b8c6261c8c2d16cd82194" name="a8c100b87423b8c6261c8c2d16cd82194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c100b87423b8c6261c8c2d16cd82194">&#9670;&#160;</a></span>trim_right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in the passed string from the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a73083ad3987d977364c90a9a80a1509f" name="a73083ad3987d977364c90a9a80a1509f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73083ad3987d977364c90a9a80a1509f">&#9670;&#160;</a></span>trim_right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in a string literal at the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a73428dd849aa12f674ece721e067ccb9" name="a73428dd849aa12f674ece721e067ccb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73428dd849aa12f674ece721e067ccb9">&#9670;&#160;</a></span>trim_right_with_spaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in the passed string, as well as whitespace at the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a2c59b83d60ff726a3ec9a9aeb1ae404b" name="a2c59b83d60ff726a3ec9a9aeb1ae404b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c59b83d60ff726a3ec9a9aeb1ae404b">&#9670;&#160;</a></span>trim_right_with_wpaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right_with_wpaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in a string literal, as well as whitespace, at the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a8e8bfc1561a193de117800effb3bbc7d" name="a8e8bfc1561a193de117800effb3bbc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8bfc1561a193de117800effb3bbc7d">&#9670;&#160;</a></span>trim_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in the passed string, as well as whitespace characters, at the beginning and end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a3240c4342cc4fa0de4126d1446501647" name="a3240c4342cc4fa0de4126d1446501647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3240c4342cc4fa0de4126d1446501647">&#9670;&#160;</a></span>trim_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove characters included in a string literal, as well as whitespace, at the beginning and end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal containing the characters to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a9bded9dcb3da163cf73d690dd63a73d4" name="a9bded9dcb3da163cf73d690dd63a73d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bded9dcb3da163cf73d690dd63a73d4">&#9670;&#160;</a></span>trimmed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with whitespace characters removed at the beginning and end. </dd></dl>

</div>
</div>
<a id="a16e8b3bad27529f5033fee8985dbec7d" name="a16e8b3bad27529f5033fee8985dbec7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e8b3bad27529f5033fee8985dbec7d">&#9670;&#160;</a></span>trimmed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and at the end. </dd></dl>

</div>
</div>
<a id="a9b9958a7ba764ec2ee03fd5f205e3bcd" name="a9b9958a7ba764ec2ee03fd5f205e3bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9958a7ba764ec2ee03fd5f205e3bcd">&#9670;&#160;</a></span>trimmed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and at the end. </dd></dl>

</div>
</div>
<a id="a25d2652007aef40826102fb153134c4d" name="a25d2652007aef40826102fb153134c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d2652007aef40826102fb153134c4d">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with leading whitespace characters removed. </dd></dl>

</div>
</div>
<a id="a17a1d3727d030ed34c789a1fd45a8038" name="a17a1d3727d030ed34c789a1fd45a8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a1d3727d030ed34c789a1fd45a8038">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed from the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning. </dd></dl>

</div>
</div>
<a id="ab7910e7f7cb59cad7452f79ee8f1921a" name="ab7910e7f7cb59cad7452f79ee8f1921a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7910e7f7cb59cad7452f79ee8f1921a">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning. </dd></dl>

</div>
</div>
<a id="ae9b80529d46935202969c279de481cda" name="ae9b80529d46935202969c279de481cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b80529d46935202969c279de481cda">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and whitespace characters. </dd></dl>

</div>
</div>
<a id="ae0e7c2822c67cc2ea9a0b8c8ed9e0280" name="ae0e7c2822c67cc2ea9a0b8c8ed9e0280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e7c2822c67cc2ea9a0b8c8ed9e0280">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and whitespace characters. </dd></dl>

</div>
</div>
<a id="a0b3af5eab221e4645e6e91b7b1a6e7d2" name="a0b3af5eab221e4645e6e91b7b1a6e7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3af5eab221e4645e6e91b7b1a6e7d2">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with whitespace characters removed at the end. </dd></dl>

</div>
</div>
<a id="aa5a49ba436dd8d11037216dc97efcd4c" name="aa5a49ba436dd8d11037216dc97efcd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a49ba436dd8d11037216dc97efcd4c">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed to the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the pattern removed at the end. </dd></dl>

</div>
</div>
<a id="ac82f1096d596015340377b58704030cf" name="ac82f1096d596015340377b58704030cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82f1096d596015340377b58704030cf">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the literal removed at the end. </dd></dl>

</div>
</div>
<a id="ac21bff9dca83968de291faa2b6d59fa8" name="ac21bff9dca83968de291faa2b6d59fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21bff9dca83968de291faa2b6d59fa8">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the template removed at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="ad41853e3d4d2579fe7557873592e7302" name="ad41853e3d4d2579fe7557873592e7302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41853e3d4d2579fe7557873592e7302">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the literal removed at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a6c2541095cb5e5a262b8e20c4dc8428b" name="a6c2541095cb5e5a262b8e20c4dc8428b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2541095cb5e5a262b8e20c4dc8428b">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="ab950f20c494e2c60b22dfe95e410ec25" name="ab950f20c494e2c60b22dfe95e410ec25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab950f20c494e2c60b22dfe95e410ec25">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="ad1b975226e92b0e57796dd14fed5248f" name="ad1b975226e92b0e57796dd14fed5248f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b975226e92b0e57796dd14fed5248f">&#9670;&#160;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert first plane characters (&lt;0xFFFF) to uppercase Unicode. </p>
<p>Case is changed by simplified tables, where one code_point is always changed to one code_point (but for UTF-8 it is possible that the length in code units will change). </p><dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a1c7b47cfc00189c51a5683fd34095192" name="a1c7b47cfc00189c51a5683fd34095192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7b47cfc00189c51a5683fd34095192">&#9670;&#160;</a></span>upper_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::upper_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert ASCII characters to uppercase. </p>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a6ae3ef69a372dab777c952f22c492689" name="a6ae3ef69a372dab777c952f22c492689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3ef69a372dab777c952f22c492689">&#9670;&#160;</a></span>upperred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::upperred </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in upper case Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - uppercase copy of the string. </dd></dl>

</div>
</div>
<a id="a3c53f8d59e980315bc0d44b5cf6b1e6d" name="a3c53f8d59e980315bc0d44b5cf6b1e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c53f8d59e980315bc0d44b5cf6b1e6d">&#9670;&#160;</a></span>upperred_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::upperred_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the passed string in uppercase Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>Case is changed by simplified tables, where one code_point is always changed to one code_point (but for UTF-8 it is possible that the length in code units will change). </p>

</div>
</div>
<a id="a517129dd2774440cd48c401b65bcf066" name="a517129dd2774440cd48c401b65bcf066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517129dd2774440cd48c401b65bcf066">&#9670;&#160;</a></span>upperred_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::upperred_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in uppercase ASCII characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - uppercase copy of the string. </dd></dl>

</div>
</div>
<a id="a6cb647956eba06372b0cef5328a0bc91" name="a6cb647956eba06372b0cef5328a0bc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb647956eba06372b0cef5328a0bc91">&#9670;&#160;</a></span>upperred_only_ascii_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::upperred_only_ascii_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a string copy of the passed in uppercase ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0ab4a1d48cbf3b7c3474a4bf28569c" name="a4c0ab4a1d48cbf3b7c3474a4bf28569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0ab4a1d48cbf3b7c3474a4bf28569c">&#9670;&#160;</a></span>vformat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::vformat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a string using std::vformat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="a7cf2545d9002b51989700a64d7aaff0e" name="a7cf2545d9002b51989700a64d7aaff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf2545d9002b51989700a64d7aaff0e">&#9670;&#160;</a></span>vformat_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::vformat_from </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends std::vformat formatted output starting at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position of adding. </td></tr>
    <tr><td class="paramname">max_write</td><td>- the maximum number of characters to write. </td></tr>
    <tr><td class="paramname">format</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="a85893478637a79c79321e5c15cab9763" name="a85893478637a79c79321e5c15cab9763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85893478637a79c79321e5c15cab9763">&#9670;&#160;</a></span>vformat_n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::vformat_n </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a string using std::vformat up to the specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_write</td><td>- the maximum number of characters to write. </td></tr>
    <tr><td class="paramname">format</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself.</dd></dl>
<p>Automatically increases the string buffer size if necessary. </p>

</div>
</div>
<a id="a43a9104a71b1593fea01f6eff162fec4" name="a43a9104a71b1593fea01f6eff162fec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a9104a71b1593fea01f6eff162fec4">&#9670;&#160;</a></span>with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::with </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor with a string and passed arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillFunction</td><td>- a functor that takes a string reference as its first parameter. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments passed to the functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Impl&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="sstring_8h_source.html">sstring.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimstr.html">simstr</a></li><li class="navelem"><a class="el" href="classsimstr_1_1lstring.html">lstring</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: String Expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.3.1</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group___str_exprs.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#concepts">Concepts</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">String Expressions</div></div>
</div><!--header-->
<div class="contents">

<p>Description of String Expressions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1_str_expr.html">simstr::StrExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept of "String Expressions". <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1_str_expr_for_type.html">simstr::StrExprForType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept of a string expression of a given character type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__replaced.html">simstr::expr_replaced&lt; K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string expression that generates a string replacing all occurrences of the given substring.  <a href="structsimstr_1_1expr__replaced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__replace__symbols.html">simstr::expr_replace_symbols&lt; K, UseVectorForReplace &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for a string expression that generates a string in which the given characters are replaced by the given strings.  <a href="structsimstr_1_1expr__replace__symbols.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1strexprjoin.html">simstr::strexprjoin&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for concatenating two string expressions into one using <code>operator +</code>  <a href="structsimstr_1_1strexprjoin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1strexprjoin__c.html">simstr::strexprjoin_c&lt; A, B, last &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation of a reference to a string expression and the value of the string expression.  <a href="structsimstr_1_1strexprjoin__c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1empty__expr.html">simstr::empty_expr&lt; K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An "empty" string expression.  <a href="structsimstr_1_1empty__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__spaces.html">simstr::expr_spaces&lt; K, N, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of string expression that returns N specified characters.  <a href="structsimstr_1_1expr__spaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__pad.html">simstr::expr_pad&lt; K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of string expression that returns N specified characters.  <a href="structsimstr_1_1expr__pad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice.html">simstr::expr_choice&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__if.html">simstr::expr_if&lt; A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice__one__lit.html">simstr::expr_choice_one_lit&lt; A, N, Compare &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice__one__lit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice__two__lit.html">simstr::expr_choice_two_lit&lt; K, N, M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice__two__lit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__stdstr.html">simstr::expr_stdstr&lt; K, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for using std::string and std::string_view as sources in string expressions.  <a href="structsimstr_1_1expr__stdstr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0421f6f954a1f0a4575cb282c1e36712" id="r_ga0421f6f954a1f0a4575cb282c1e36712"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, FromIntNumber T&gt; </td></tr>
<tr class="memitem:ga0421f6f954a1f0a4575cb282c1e36712"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_num&lt; typename A::symb_type, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0421f6f954a1f0a4575cb282c1e36712">simstr::operator+</a> (const A &amp;a, T s)</td></tr>
<tr class="memdesc:ga0421f6f954a1f0a4575cb282c1e36712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for string expression and integer.  <br /></td></tr>
<tr class="separator:ga0421f6f954a1f0a4575cb282c1e36712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6edec79f617564db65f91039283f39" id="r_gaff6edec79f617564db65f91039283f39"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, FromIntNumber T&gt; </td></tr>
<tr class="memitem:gaff6edec79f617564db65f91039283f39"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_num&lt; typename A::symb_type, T &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaff6edec79f617564db65f91039283f39">simstr::operator+</a> (T s, const A &amp;a)</td></tr>
<tr class="memdesc:gaff6edec79f617564db65f91039283f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for integer and string expression.  <br /></td></tr>
<tr class="separator:gaff6edec79f617564db65f91039283f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd001ccf59de81ceb1493eff2d2214f" id="r_ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memTemplParams" colspan="2">template&lt;typename K, typename T&gt; </td></tr>
<tr class="memitem:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_num&lt; K, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4bd001ccf59de81ceb1493eff2d2214f">simstr::e_num</a> (T t)</td></tr>
<tr class="memdesc:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a string expression.  <br /></td></tr>
<tr class="separator:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcde8bf3ec1de77095e9dc62faf5cbcd" id="r_gafcde8bf3ec1de77095e9dc62faf5cbcd"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename R&gt; <br />
requires (std::is_same_v&lt;R, double&gt; || std::is_same_v&lt;R, float&gt;)</td></tr>
<tr class="memitem:gafcde8bf3ec1de77095e9dc62faf5cbcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafcde8bf3ec1de77095e9dc62faf5cbcd">simstr::operator+</a> (const A &amp;a, R s)</td></tr>
<tr class="memdesc:gafcde8bf3ec1de77095e9dc62faf5cbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for string expression and real number (<code>float</code>, <code>double</code>).  <br /></td></tr>
<tr class="separator:gafcde8bf3ec1de77095e9dc62faf5cbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f311136af3a57df58765525136811cb" id="r_ga5f311136af3a57df58765525136811cb"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename R&gt; <br />
requires (is_one_of_std_char_v&lt;typename A::symb_type&gt; &amp;&amp; (std::is_same_v&lt;R, double&gt; || std::is_same_v&lt;R, float&gt;))</td></tr>
<tr class="memitem:ga5f311136af3a57df58765525136811cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5f311136af3a57df58765525136811cb">simstr::operator+</a> (R s, const A &amp;a)</td></tr>
<tr class="memdesc:ga5f311136af3a57df58765525136811cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for float (<code>float</code>, <code>double</code>) and string expression.  <br /></td></tr>
<tr class="separator:ga5f311136af3a57df58765525136811cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a412b356789519d05d7c96942c2f3a" id="r_ga50a412b356789519d05d7c96942c2f3a"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires (is_one_of_std_char_v&lt;K&gt;)</td></tr>
<tr class="memitem:ga50a412b356789519d05d7c96942c2f3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga50a412b356789519d05d7c96942c2f3a">simstr::e_real</a> (double t)</td></tr>
<tr class="memdesc:ga50a412b356789519d05d7c96942c2f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <code>double</code> number to a string expression.  <br /></td></tr>
<tr class="separator:ga50a412b356789519d05d7c96942c2f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2e6b8a52bfe20c0b86d25f9f78cb52" id="r_gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memTemplParams" colspan="2">template&lt;bool tail = false, bool skip_empty = false, typename L, typename K = typename const_lit&lt;L&gt;::symb_type, size_t I = const_lit&lt;L&gt;::Count, typename T&gt; </td></tr>
<tr class="memitem:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafd2e6b8a52bfe20c0b86d25f9f78cb52">simstr::e_join</a> (const T &amp;s, L &amp;&amp;d)</td></tr>
<tr class="memdesc:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression concatenating the strings in the container into a single string with the given delimiter.limiter.limiter.  <br /></td></tr>
<tr class="separator:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d45ca1f944c59bd38c7c45bf556a1a8" id="r_ga1d45ca1f944c59bd38c7c45bf556a1a8"><td class="memTemplParams" colspan="2">template&lt;typename K, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename X, size_t L = const_lit_for&lt;K, X&gt;::Count&gt; <br />
requires (N &gt; 1)</td></tr>
<tr class="memitem:ga1d45ca1f944c59bd38c7c45bf556a1a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1d45ca1f944c59bd38c7c45bf556a1a8">simstr::e_repl</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt; w, T &amp;&amp;p, X &amp;&amp;r)</td></tr>
<tr class="memdesc:ga1d45ca1f944c59bd38c7c45bf556a1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that generates a string with all occurrences of a given substring replaced.  <br /></td></tr>
<tr class="separator:ga1d45ca1f944c59bd38c7c45bf556a1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae84acc2cd8a75190b0beb985b2a8d3bd" id="r_gae84acc2cd8a75190b0beb985b2a8d3bd"><td class="memTemplParams" colspan="2">template&lt;bool UseVector = false, typename K, typename ... Repl&gt; <br />
requires (sizeof...(Repl) % 2 == 0)</td></tr>
<tr class="memitem:gae84acc2cd8a75190b0beb985b2a8d3bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae84acc2cd8a75190b0beb985b2a8d3bd">simstr::e_repl_const_symbols</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt; src, Repl &amp;&amp;... other)</td></tr>
<tr class="memdesc:gae84acc2cd8a75190b0beb985b2a8d3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string expression that generates a string containing the given characters replaced with given substrings.  <br /></td></tr>
<tr class="separator:gae84acc2cd8a75190b0beb985b2a8d3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9742e8cdcccc67c0746578f3579127e2" id="r_ga9742e8cdcccc67c0746578f3579127e2"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </td></tr>
<tr class="memitem:ga9742e8cdcccc67c0746578f3579127e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin.html">strexprjoin</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9742e8cdcccc67c0746578f3579127e2">simstr::operator+</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:ga9742e8cdcccc67c0746578f3579127e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An addition operator for two arbitrary string expressions of the same character type.  <br /></td></tr>
<tr class="separator:ga9742e8cdcccc67c0746578f3579127e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8bc7652fac165ad43ae054fb083616" id="r_ga9d8bc7652fac165ad43ae054fb083616"><td class="memTemplParams" colspan="2">template&lt;typename K, StrExprForType&lt; K &gt; A&gt; </td></tr>
<tr class="memitem:ga9d8bc7652fac165ad43ae054fb083616"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_char&lt; K &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9d8bc7652fac165ad43ae054fb083616">simstr::operator+</a> (const A &amp;a, K s)</td></tr>
<tr class="memdesc:ga9d8bc7652fac165ad43ae054fb083616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator of a string expression and one character.  <br /></td></tr>
<tr class="separator:ga9d8bc7652fac165ad43ae054fb083616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d62d117c726329b31a3ab6b35e8153" id="r_gab0d62d117c726329b31a3ab6b35e8153"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:gab0d62d117c726329b31a3ab6b35e8153"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_char&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab0d62d117c726329b31a3ab6b35e8153">simstr::e_char</a> (K s)</td></tr>
<tr class="memdesc:gab0d62d117c726329b31a3ab6b35e8153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of 1 given character.  <br /></td></tr>
<tr class="separator:gab0d62d117c726329b31a3ab6b35e8153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9c377a32a2cc243efce977c4adffe3" id="r_ga9e9c377a32a2cc243efce977c4adffe3"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit&lt;T&gt;::Count&gt; </td></tr>
<tr class="memitem:ga9e9c377a32a2cc243efce977c4adffe3"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal&lt; typename const_lit&lt; T &gt;::symb_type, static_cast&lt; size_t &gt;(N - 1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9e9c377a32a2cc243efce977c4adffe3">simstr::e_t</a> (T &amp;&amp;s)</td></tr>
<tr class="memdesc:ga9e9c377a32a2cc243efce977c4adffe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string literal to a string expression.  <br /></td></tr>
<tr class="separator:ga9e9c377a32a2cc243efce977c4adffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9528a989819fa724d6e4ca739a749a3" id="r_gac9528a989819fa724d6e4ca739a749a3"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename K = typename A::symb_type, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:gac9528a989819fa724d6e4ca739a749a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal_join&lt; false, K,(N - 1), A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac9528a989819fa724d6e4ca739a749a3">simstr::operator+</a> (const A &amp;a, T &amp;&amp;s)</td></tr>
<tr class="memdesc:gac9528a989819fa724d6e4ca739a749a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator for a string expression and a string literal of the same character type.  <br /></td></tr>
<tr class="separator:gac9528a989819fa724d6e4ca739a749a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6981ff65002b1267ef4662fa22e2bacf" id="r_ga6981ff65002b1267ef4662fa22e2bacf"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename K = typename A::symb_type, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:ga6981ff65002b1267ef4662fa22e2bacf"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal_join&lt; true, K,(N - 1), A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6981ff65002b1267ef4662fa22e2bacf">simstr::operator+</a> (T &amp;&amp;s, const A &amp;a)</td></tr>
<tr class="memdesc:ga6981ff65002b1267ef4662fa22e2bacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator for a string literal of the same character type and string expression.  <br /></td></tr>
<tr class="separator:ga6981ff65002b1267ef4662fa22e2bacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e02268e25a635b4b7e14d0744b46c1" id="r_ga33e02268e25a635b4b7e14d0744b46c1"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ga33e02268e25a635b4b7e14d0744b46c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; u8s, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga33e02268e25a635b4b7e14d0744b46c1">simstr::e_spca</a> ()</td></tr>
<tr class="memdesc:ga33e02268e25a635b4b7e14d0744b46c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of N char spaces.  <br /></td></tr>
<tr class="separator:ga33e02268e25a635b4b7e14d0744b46c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b5d15132fcc706d1edc1364673a4ab" id="r_ga23b5d15132fcc706d1edc1364673a4ab"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ga23b5d15132fcc706d1edc1364673a4ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; uws, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga23b5d15132fcc706d1edc1364673a4ab">simstr::e_spcw</a> ()</td></tr>
<tr class="memdesc:ga23b5d15132fcc706d1edc1364673a4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of N wchar_t spaces.  <br /></td></tr>
<tr class="separator:ga23b5d15132fcc706d1edc1364673a4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54b64072b9629a32837d9197dfe51b5" id="r_gab54b64072b9629a32837d9197dfe51b5"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:gab54b64072b9629a32837d9197dfe51b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__pad.html">expr_pad</a>&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab54b64072b9629a32837d9197dfe51b5">simstr::e_c</a> (size_t l, K s)</td></tr>
<tr class="memdesc:gab54b64072b9629a32837d9197dfe51b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of l characters s of type K.  <br /></td></tr>
<tr class="separator:gab54b64072b9629a32837d9197dfe51b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d17e531ba0aa5e62e0480fa8b1a1497" id="r_ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memTemplParams" colspan="2">template&lt;typename T, typename K = const_lit&lt;T&gt;::symb_type, size_t M = const_lit&lt;T&gt;::Count&gt; <br />
requires (M &gt; 0)</td></tr>
<tr class="memitem:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_repeat_lit&lt; K, M - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9d17e531ba0aa5e62e0480fa8b1a1497">simstr::e_repeat</a> (T &amp;&amp;s, size_t l)</td></tr>
<tr class="memdesc:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string from l string constants s of type K.  <br /></td></tr>
<tr class="separator:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110a07b71eab2b667f78afc1068df0a9" id="r_ga110a07b71eab2b667f78afc1068df0a9"><td class="memTemplParams" colspan="2">template&lt;StrExpr A&gt; </td></tr>
<tr class="memitem:ga110a07b71eab2b667f78afc1068df0a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_repeat_expr&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga110a07b71eab2b667f78afc1068df0a9">simstr::e_repeat</a> (const A &amp;s, size_t l)</td></tr>
<tr class="memdesc:ga110a07b71eab2b667f78afc1068df0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string from l string expressions s of type K.  <br /></td></tr>
<tr class="separator:ga110a07b71eab2b667f78afc1068df0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab058a69a654cf3a0fce197e862a7400e" id="r_gab058a69a654cf3a0fce197e862a7400e"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </td></tr>
<tr class="memitem:gab058a69a654cf3a0fce197e862a7400e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice.html">expr_choice</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab058a69a654cf3a0fce197e862a7400e">simstr::e_choice</a> (bool c, const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:gab058a69a654cf3a0fce197e862a7400e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a conditional string expression <a class="el" href="structsimstr_1_1expr__choice.html" title="Conditional selection string expression.">expr_choice</a>.  <br /></td></tr>
<tr class="separator:gab058a69a654cf3a0fce197e862a7400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf82a22c191f2594c4fb0891ade17de" id="r_ga8cf82a22c191f2594c4fb0891ade17de"><td class="memTemplParams" colspan="2"><a id="ga8cf82a22c191f2594c4fb0891ade17de" name="ga8cf82a22c191f2594c4fb0891ade17de"></a>
template&lt;StrExpr A, typename T, size_t N = const_lit_for&lt;typename A::symb_type, T&gt;::Count&gt; </td></tr>
<tr class="memitem:ga8cf82a22c191f2594c4fb0891ade17de"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__one__lit.html">expr_choice_one_lit</a>&lt; A, N - 1, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::e_choice</b> (bool c, const A &amp;a, T &amp;&amp;str)</td></tr>
<tr class="memdesc:ga8cf82a22c191f2594c4fb0891ade17de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the third argument is a string literal. <br /></td></tr>
<tr class="separator:ga8cf82a22c191f2594c4fb0891ade17de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22052be8c98310e20a869896f988dca1" id="r_ga22052be8c98310e20a869896f988dca1"><td class="memTemplParams" colspan="2"><a id="ga22052be8c98310e20a869896f988dca1" name="ga22052be8c98310e20a869896f988dca1"></a>
template&lt;StrExpr A, typename T, size_t N = const_lit_for&lt;typename A::symb_type, T&gt;::Count&gt; </td></tr>
<tr class="memitem:ga22052be8c98310e20a869896f988dca1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__one__lit.html">expr_choice_one_lit</a>&lt; A, N - 1, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::e_choice</b> (bool c, T &amp;&amp;str, const A &amp;a)</td></tr>
<tr class="memdesc:ga22052be8c98310e20a869896f988dca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the second argument is a string literal. <br /></td></tr>
<tr class="separator:ga22052be8c98310e20a869896f988dca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe3c3afbd100a1f9dd2a969472f96561" id="r_gafe3c3afbd100a1f9dd2a969472f96561"><td class="memTemplParams" colspan="2"><a id="gafe3c3afbd100a1f9dd2a969472f96561" name="gafe3c3afbd100a1f9dd2a969472f96561"></a>
template&lt;typename T, typename L, size_t N = const_lit&lt;T&gt;::Count, size_t M = const_lit_for&lt;typename const_lit&lt;T&gt;::symb_type, L&gt;::Count&gt; </td></tr>
<tr class="memitem:gafe3c3afbd100a1f9dd2a969472f96561"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__two__lit.html">expr_choice_two_lit</a>&lt; typename const_lit&lt; T &gt;::symb_type, N -1, M - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::e_choice</b> (bool c, T &amp;&amp;str_a, L &amp;&amp;str_b)</td></tr>
<tr class="memdesc:gafe3c3afbd100a1f9dd2a969472f96561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the second and third arguments are string literals. <br /></td></tr>
<tr class="separator:gafe3c3afbd100a1f9dd2a969472f96561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2bd93f7c79b2c59ddf5adb18246751" id="r_ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memTemplParams" colspan="2">template&lt;StrExpr A&gt; </td></tr>
<tr class="memitem:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__if.html">expr_if</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">simstr::e_if</a> (bool c, const A &amp;a)</td></tr>
<tr class="memdesc:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a conditional string expression <a class="el" href="structsimstr_1_1expr__if.html" title="Conditional selection string expression.">expr_if</a>.  <br /></td></tr>
<tr class="separator:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaea41c25b6dc26662221fd1c5fb705c" id="r_gacaea41c25b6dc26662221fd1c5fb705c"><td class="memTemplParams" colspan="2"><a id="gacaea41c25b6dc26662221fd1c5fb705c" name="gacaea41c25b6dc26662221fd1c5fb705c"></a>
template&lt;typename T, size_t N = const_lit&lt;T&gt;::Count&gt; </td></tr>
<tr class="memitem:gacaea41c25b6dc26662221fd1c5fb705c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::e_if</b> (bool c, T &amp;&amp;str)</td></tr>
<tr class="memdesc:gacaea41c25b6dc26662221fd1c5fb705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_if when the second argument is a string literal. <br /></td></tr>
<tr class="separator:gacaea41c25b6dc26662221fd1c5fb705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee8ac9b7a5e5789f61466627bca6746" id="r_gadee8ac9b7a5e5789f61466627bca6746"><td class="memTemplParams" colspan="2"><a id="gadee8ac9b7a5e5789f61466627bca6746" name="gadee8ac9b7a5e5789f61466627bca6746"></a>
template&lt;StrExprForType&lt; u8s &gt; A&gt; </td></tr>
<tr class="memitem:gadee8ac9b7a5e5789f61466627bca6746"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; u8s, std::string &gt;, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const A &amp;a, const std::string &amp;s)</td></tr>
<tr class="memdesc:gadee8ac9b7a5e5789f61466627bca6746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for char string expression and std::string. <br /></td></tr>
<tr class="separator:gadee8ac9b7a5e5789f61466627bca6746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2bf254ee570373d4550d89f1dd62d34" id="r_gae2bf254ee570373d4550d89f1dd62d34"><td class="memTemplParams" colspan="2"><a id="gae2bf254ee570373d4550d89f1dd62d34" name="gae2bf254ee570373d4550d89f1dd62d34"></a>
template&lt;StrExprForType&lt; u8s &gt; A&gt; </td></tr>
<tr class="memitem:gae2bf254ee570373d4550d89f1dd62d34"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; u8s, std::string &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const std::string &amp;s, const A &amp;a)</td></tr>
<tr class="memdesc:gae2bf254ee570373d4550d89f1dd62d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for std::string and char string expression. <br /></td></tr>
<tr class="separator:gae2bf254ee570373d4550d89f1dd62d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa719292b65b5ee6d2e731d77806d8a7b" id="r_gaa719292b65b5ee6d2e731d77806d8a7b"><td class="memTemplParams" colspan="2"><a id="gaa719292b65b5ee6d2e731d77806d8a7b" name="gaa719292b65b5ee6d2e731d77806d8a7b"></a>
template&lt;StrExprForType&lt; u8s &gt; A&gt; </td></tr>
<tr class="memitem:gaa719292b65b5ee6d2e731d77806d8a7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; u8s, std::string_view &gt;, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const A &amp;a, const std::string_view &amp;s)</td></tr>
<tr class="memdesc:gaa719292b65b5ee6d2e731d77806d8a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for char string expression and std::string_view. <br /></td></tr>
<tr class="separator:gaa719292b65b5ee6d2e731d77806d8a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f1040036cc6caf4118099bdc751d3d" id="r_ga08f1040036cc6caf4118099bdc751d3d"><td class="memTemplParams" colspan="2"><a id="ga08f1040036cc6caf4118099bdc751d3d" name="ga08f1040036cc6caf4118099bdc751d3d"></a>
template&lt;StrExprForType&lt; u8s &gt; A&gt; </td></tr>
<tr class="memitem:ga08f1040036cc6caf4118099bdc751d3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; u8s, std::string_view &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const std::string_view &amp;s, const A &amp;a)</td></tr>
<tr class="memdesc:ga08f1040036cc6caf4118099bdc751d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for std::string_view and char string expression. <br /></td></tr>
<tr class="separator:ga08f1040036cc6caf4118099bdc751d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c7c4e16213700ab683dd602d558f0af" id="r_ga3c7c4e16213700ab683dd602d558f0af"><td class="memTemplParams" colspan="2"><a id="ga3c7c4e16213700ab683dd602d558f0af" name="ga3c7c4e16213700ab683dd602d558f0af"></a>
template&lt;StrExprForType&lt; uws &gt; A&gt; </td></tr>
<tr class="memitem:ga3c7c4e16213700ab683dd602d558f0af"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; uws, std::wstring &gt;, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const A &amp;a, const std::wstring &amp;s)</td></tr>
<tr class="memdesc:ga3c7c4e16213700ab683dd602d558f0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for wchar_t string expression and std::wstring. <br /></td></tr>
<tr class="separator:ga3c7c4e16213700ab683dd602d558f0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadafc7f4711ffa3fc07fa57ccbdb642b1" id="r_gadafc7f4711ffa3fc07fa57ccbdb642b1"><td class="memTemplParams" colspan="2"><a id="gadafc7f4711ffa3fc07fa57ccbdb642b1" name="gadafc7f4711ffa3fc07fa57ccbdb642b1"></a>
template&lt;StrExprForType&lt; uws &gt; A&gt; </td></tr>
<tr class="memitem:gadafc7f4711ffa3fc07fa57ccbdb642b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; uws, std::wstring &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const std::wstring &amp;s, const A &amp;a)</td></tr>
<tr class="memdesc:gadafc7f4711ffa3fc07fa57ccbdb642b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for std::wstring and wchar_t string expression. <br /></td></tr>
<tr class="separator:gadafc7f4711ffa3fc07fa57ccbdb642b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad7cc1588956ff85b7850270a24b5f2" id="r_ga8ad7cc1588956ff85b7850270a24b5f2"><td class="memTemplParams" colspan="2"><a id="ga8ad7cc1588956ff85b7850270a24b5f2" name="ga8ad7cc1588956ff85b7850270a24b5f2"></a>
template&lt;StrExprForType&lt; uws &gt; A&gt; </td></tr>
<tr class="memitem:ga8ad7cc1588956ff85b7850270a24b5f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; uws, std::wstring_view &gt;, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const A &amp;a, const std::wstring_view &amp;s)</td></tr>
<tr class="memdesc:ga8ad7cc1588956ff85b7850270a24b5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for wchar_t string expression and std::wstring_view. <br /></td></tr>
<tr class="separator:ga8ad7cc1588956ff85b7850270a24b5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a0156145a107469a59d196fdbbec08" id="r_gae5a0156145a107469a59d196fdbbec08"><td class="memTemplParams" colspan="2"><a id="gae5a0156145a107469a59d196fdbbec08" name="gae5a0156145a107469a59d196fdbbec08"></a>
template&lt;StrExprForType&lt; uws &gt; A&gt; </td></tr>
<tr class="memitem:gae5a0156145a107469a59d196fdbbec08"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; uws, std::wstring_view &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const std::wstring_view &amp;s, const A &amp;a)</td></tr>
<tr class="memdesc:gae5a0156145a107469a59d196fdbbec08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for std::wstring_view and wchar_t string expression. <br /></td></tr>
<tr class="separator:gae5a0156145a107469a59d196fdbbec08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab19693e574a384f42220cf115ec86c75" id="r_gab19693e574a384f42220cf115ec86c75"><td class="memItemLeft" align="right" valign="top"><a id="gab19693e574a384f42220cf115ec86c75" name="gab19693e574a384f42220cf115ec86c75"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eea</b> {}</td></tr>
<tr class="memdesc:gab19693e574a384f42220cf115ec86c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char. <br /></td></tr>
<tr class="separator:gab19693e574a384f42220cf115ec86c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ebc01b80560370b2f318d897bb6000a" id="r_ga2ebc01b80560370b2f318d897bb6000a"><td class="memItemLeft" align="right" valign="top"><a id="ga2ebc01b80560370b2f318d897bb6000a" name="ga2ebc01b80560370b2f318d897bb6000a"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; uws &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eew</b> {}</td></tr>
<tr class="memdesc:ga2ebc01b80560370b2f318d897bb6000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type wchar_t. <br /></td></tr>
<tr class="separator:ga2ebc01b80560370b2f318d897bb6000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96ac61f552b627d623bf4958337242a" id="r_gab96ac61f552b627d623bf4958337242a"><td class="memItemLeft" align="right" valign="top"><a id="gab96ac61f552b627d623bf4958337242a" name="gab96ac61f552b627d623bf4958337242a"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u16s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eeu</b> {}</td></tr>
<tr class="memdesc:gab96ac61f552b627d623bf4958337242a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char16_t. <br /></td></tr>
<tr class="separator:gab96ac61f552b627d623bf4958337242a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470627498bd16d6b5337607650d1c699" id="r_ga470627498bd16d6b5337607650d1c699"><td class="memItemLeft" align="right" valign="top"><a id="ga470627498bd16d6b5337607650d1c699" name="ga470627498bd16d6b5337607650d1c699"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u32s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eeuu</b> {}</td></tr>
<tr class="memdesc:ga470627498bd16d6b5337607650d1c699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char32_t. <br /></td></tr>
<tr class="separator:ga470627498bd16d6b5337607650d1c699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Description of String Expressions. </p>
<p>All owning string types can be initialized using "string expressions" (essentially a variant of <a href="https://en.wikipedia.org/wiki/Expression_templates">https://en.wikipedia.org/wiki/Expression_templates</a> for strings). A string expression is an object of an arbitrary type that has methods:</p><ul>
<li><code>size_t length() const</code>: returns the length of the string</li>
<li><code>K* place(K*) const</code>: copy the characters of the string to the intended buffer and return a pointer behind the last character</li>
<li><code>typename symb_type</code>: shows what type of symbols it works with.</li>
</ul>
<p>During initialization, a string object asks the string expression for its size, allocates the necessary memory, and passes the memory to a string expression that places the characters in the allocated buffer.</p>
<p>All library string objects are themselves string expressions that simply copy the original string. Basically, string expressions are used to concatenate or convert strings.</p>
<p>For all string expressions, <a class="el" href="#op_plus_str_expr">operator +</a> is defined, which creates a new string expression from two operands <a class="el" href="structsimstr_1_1strexprjoin.html" title="Template class for concatenating two string expressions into one using operator +">simstr::strexprjoin</a>, which combines two string expressions, and which in the <code>length</code> method returns the sum of the <code>length</code> original operands, and in the <code>place</code> method - places first the first operand, then the second, into the result buffer. And since this operator itself returns a string expression, you can again apply <code>operator +</code> to it, forming a chain of several string expressions, and eventually “materialize” the last resulting object, which will first calculate the size of the entire shared memory for the final result, and then will place the nested subexpressions into a single buffer.</p>
<p>Also <code>operator +</code> is defined for string expressions and string literals, string expressions and numbers (numbers are converted to decimal representation), and you can also add the desired types of string expressions yourself. Example: </p><div class="fragment"><div class="line">stringa text = header + <span class="stringliteral">&quot;, count = &quot;</span> + count + <span class="stringliteral">&quot;, done&quot;</span>;</div>
</div><!-- fragment --><p> There are several types of string expressions out of the box to perform various operations on strings</p><ul>
<li><code><a class="el" href="structsimstr_1_1expr__spaces.html" title="A type of string expression that returns N specified characters.">expr_spaces</a>&lt; Character Type, Number of Characters, Symbol&gt;{}</code>: returns a string of length Number of Characters, filled with the specified character. The number of characters and character are compile-time constants. For some cases there is a shorthand notation:<ul>
<li><code>e_spca&lt; Number of Characters&gt;()</code>: char string of spaces</li>
<li><code>e_spcw&lt; Number of Characters&gt;()</code>: w_char string of spaces</li>
</ul>
</li>
<li><code><a class="el" href="structsimstr_1_1expr__pad.html" title="A type of string expression that returns N specified characters.">expr_pad</a>&lt; Character Type&gt;{Number of Characters, Symbol}</code>: produces a string long Number of Characters, filled with the specified character. The number of characters and the symbol can be set at runtime. Shorthand: <code>e_c(Number of Characters, Character)</code></li>
<li><code>e_choice(bool Condition, StrExpr1, StrExpr2)</code>: if Condition == true, the result will be StrExpr1, otherwise StrExpr2</li>
<li><code>e_num&lt; CharacterType&gt;(IntegerNumber)</code>: Converts a number to decimal notation. Rarely used because for string expressions and numbers the "+" operator is redefined, and the number can simply be written as text + number;</li>
<li><code>e_real&lt; CharacterType&gt;(RealNumber)</code>: Converts a number to decimal notation. Rarely used because for string expressions and numbers the "+" operator is overridden, and the number can simply be written as <code>text + number</code>;</li>
<li><code>e_join&lt; bool AfterLast = false, bool SkipEmpty = false&gt;(container, "Separator")</code>: concatenates all strings in a container using a separator. If <code>AfterLast == true</code>, then the separator is added after the last element of the container, otherwise only between elements. If <code>Skip Empty == true</code>, then empty lines do not add a separator, otherwise for each empty line a separator is also inserted</li>
<li><code>e_repl(SourceString, "Search", "Replace")</code>: replaces occurrences of "Search" with "Replace" in the source string. Find and replace patterns are compile-time string literals.</li>
<li><code><a class="el" href="structsimstr_1_1expr__replaced.html" title="A string expression that generates a string replacing all occurrences of the given substring.">expr_replaced</a>&lt; CharacterType&gt;{SourceString, Search, Replace}</code>: replaces occurrences of Search with Replace in the source string. Search and replace patterns - can be any string objects at runtime. etc. etc. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab54b64072b9629a32837d9197dfe51b5" name="gab54b64072b9629a32837d9197dfe51b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab54b64072b9629a32837d9197dfe51b5">&#9670;&#160;</a></span>e_c()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__pad.html">expr_pad</a>&lt; K &gt; simstr::e_c </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string of l characters s of type K. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>is a symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>- number of characters. </td></tr>
    <tr><td class="paramname">s</td><td>- symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression that generates a string of l characters k. </dd></dl>

</div>
</div>
<a id="gab0d62d117c726329b31a3ab6b35e8153" name="gab0d62d117c726329b31a3ab6b35e8153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d62d117c726329b31a3ab6b35e8153">&#9670;&#160;</a></span>e_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_char&lt; K &gt; simstr::e_char </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string of 1 given character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string expression for a single character string. </dd></dl>

</div>
</div>
<a id="gab058a69a654cf3a0fce197e862a7400e" name="gab058a69a654cf3a0fce197e862a7400e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab058a69a654cf3a0fce197e862a7400e">&#9670;&#160;</a></span>e_choice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__choice.html">expr_choice</a>&lt; A, B &gt; simstr::e_choice </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a conditional string expression <a class="el" href="structsimstr_1_1expr__choice.html" title="Conditional selection string expression.">expr_choice</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- Type expression when the condition is true, inferred from the argument. </td></tr>
    <tr><td class="paramname">B</td><td>- The type of expression when the condition is false, inferred from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>is a Boolean condition. </td></tr>
    <tr><td class="paramname">a</td><td>is a string expression that is executed when <code>c == true</code>. </td></tr>
    <tr><td class="paramname">b</td><td>is a string expression that is executed when <code>c == false</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Serves to allow you to select different options in one expression depending on the condition.</p>
<p>Example: </p><div class="fragment"><div class="line">columns_metadata.emplace_back(<a class="code hl_function" href="#gab058a69a654cf3a0fce197e862a7400e">e_choice</a>(name.is_empty(), <span class="stringliteral">&quot;?column?&quot;</span>, name) + <span class="stringliteral">&quot;::&quot;</span> + metadata_column.type.to_string());</div>
<div class="ttc" id="agroup___str_exprs_html_gab058a69a654cf3a0fce197e862a7400e"><div class="ttname"><a href="#gab058a69a654cf3a0fce197e862a7400e">simstr::e_choice</a></div><div class="ttdeci">constexpr expr_choice&lt; A, B &gt; e_choice(bool c, const A &amp;a, const B &amp;b)</div><div class="ttdoc">Create a conditional string expression expr_choice.</div><div class="ttdef"><b>Definition</b> strexpr.h:1106</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">lstringa&lt;512&gt; str = <a class="code hl_function" href="#gab058a69a654cf3a0fce197e862a7400e">e_choice</a>(!ret_type_resolver_, sql_value::type_name(ret_type_), <span class="stringliteral">&quot;any&quot;</span>) + <span class="stringliteral">&quot; &quot;</span> + name_ + <span class="stringliteral">&quot;(&quot;</span>;</div>
</div><!-- fragment --><p> Otherwise, such operations would have to be split into several string modifications or the use of temporary strings, which is not optimal and will reduce performance. (This is checked in the "Build Full Func Name" benchmark) </p>

</div>
</div>
<a id="ga1f2bd93f7c79b2c59ddf5adb18246751" name="ga1f2bd93f7c79b2c59ddf5adb18246751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f2bd93f7c79b2c59ddf5adb18246751">&#9670;&#160;</a></span>e_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__if.html">expr_if</a>&lt; A &gt; simstr::e_if </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating a conditional string expression <a class="el" href="structsimstr_1_1expr__if.html" title="Conditional selection string expression.">expr_if</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- Type expression when the condition is true, inferred from the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- boolean condition </td></tr>
    <tr><td class="paramname">a</td><td>- string expression executed when <code>c == true</code></td></tr>
  </table>
  </dd>
</dl>
<p>Serves to allow one expression to generate, depending on the condition, either the specified option or an empty string.</p>
<p>Example </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> sql_func_info::build_full_name() {</div>
<div class="line">    <span class="comment">// Временный буфер для результата, возьмём с запасом</span></div>
<div class="line">    <span class="comment">// Temporary buffer for the result, take it with reserve</span></div>
<div class="line">    lstringa&lt;512&gt; str = <a class="code hl_function" href="#gab058a69a654cf3a0fce197e862a7400e">e_choice</a>(!ret_type_resolver_, sql_value::type_name(ret_type_), <span class="stringliteral">&quot;any&quot;</span>) + <span class="stringliteral">&quot; &quot;</span> + name_ + <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> add_comma = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; param : params_) {</div>
<div class="line">        str += <a class="code hl_function" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a>(add_comma, <span class="stringliteral">&quot;, &quot;</span>) + <a class="code hl_function" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a>(param.optional_, <span class="stringliteral">&quot;[&quot;</span>);</div>
<div class="line">        <span class="comment">// Добавляет к str названия допустимых типов</span></div>
<div class="line">        <span class="comment">// Adds the names of valid types to str</span></div>
<div class="line">        param.allowed_types.to_string(str);</div>
<div class="line">        <span class="keywordflow">if</span> (param.optional_) {</div>
<div class="line">            str += <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        add_comma = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Сохраним в stringa</span></div>
<div class="line">    <span class="comment">// Save it in stringa</span></div>
<div class="line">    full_name_ = str + <a class="code hl_function" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a>(unlim_params_, <a class="code hl_function" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a>(add_comma, <span class="stringliteral">&quot;, &quot;</span>) + <span class="stringliteral">&quot;...&quot;</span>) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup___str_exprs_html_ga1f2bd93f7c79b2c59ddf5adb18246751"><div class="ttname"><a href="#ga1f2bd93f7c79b2c59ddf5adb18246751">simstr::e_if</a></div><div class="ttdeci">constexpr expr_if&lt; A &gt; e_if(bool c, const A &amp;a)</div><div class="ttdoc">Creating a conditional string expression expr_if.</div><div class="ttdef"><b>Definition</b> strexpr.h:1182</div></div>
</div><!-- fragment --><p> Otherwise, such operations would have to be split into several string modifications or the use of temporary strings, which is not optimal and will reduce performance. (This example is tested in the "Build Full Func Name" benchmark) </p>

</div>
</div>
<a id="gafd2e6b8a52bfe20c0b86d25f9f78cb52" name="gafd2e6b8a52bfe20c0b86d25f9f78cb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd2e6b8a52bfe20c0b86d25f9f78cb52">&#9670;&#160;</a></span>e_join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool tail = false, bool skip_empty = false, typename L, typename K = typename const_lit&lt;L&gt;::symb_type, size_t I = const_lit&lt;L&gt;::Count, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string expression concatenating the strings in the container into a single string with the given delimiter.limiter.limiter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tail</td><td>- whether to add a separator after the last line. </td></tr>
    <tr><td class="paramname">skip_empty</td><td>- skip empty lines without adding a separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- container with strings, must support <code>range for</code>. </td></tr>
    <tr><td class="paramname">d</td><td>- delimiter, string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4bd001ccf59de81ceb1493eff2d2214f" name="ga4bd001ccf59de81ceb1493eff2d2214f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bd001ccf59de81ceb1493eff2d2214f">&#9670;&#160;</a></span>e_num()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_num&lt; K, T &gt; simstr::e_num </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an integer to a string expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- character type. </td></tr>
    <tr><td class="paramname">T</td><td>- number type, inferred from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- number.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a string expression that generates the decimal representation of the given number. Can be used when you need to concatenate a number and a string literal. </p>

</div>
</div>
<a id="ga50a412b356789519d05d7c96942c2f3a" name="ga50a412b356789519d05d7c96942c2f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50a412b356789519d05d7c96942c2f3a">&#9670;&#160;</a></span>e_real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires (is_one_of_std_char_v&lt;K&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_real </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <code>double</code> number to a string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- number.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a string expression that generates the decimal representation of the given number. using <code>sprintf("%.16g")</code>. Can be used when you need to concatenate a number and a string literal. </p>

</div>
</div>
<a id="ga110a07b71eab2b667f78afc1068df0a9" name="ga110a07b71eab2b667f78afc1068df0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga110a07b71eab2b667f78afc1068df0a9">&#9670;&#160;</a></span>e_repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_repeat_expr&lt; A &gt; simstr::e_repeat </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a string from l string expressions s of type K. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- character type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>- number of repetitions </td></tr>
    <tr><td class="paramname">s</td><td>- string expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression generating a string of l string expressions s </dd></dl>

</div>
</div>
<a id="ga9d17e531ba0aa5e62e0480fa8b1a1497" name="ga9d17e531ba0aa5e62e0480fa8b1a1497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d17e531ba0aa5e62e0480fa8b1a1497">&#9670;&#160;</a></span>e_repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename K = const_lit&lt;T&gt;::symb_type, size_t M = const_lit&lt;T&gt;::Count&gt; <br />
requires (M &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_repeat_lit&lt; K, M - 1 &gt; simstr::e_repeat </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a string from l string constants s of type K. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- character type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>- number of repetitions </td></tr>
    <tr><td class="paramname">s</td><td>- string literal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression generating a string of l strings s </dd></dl>

</div>
</div>
<a id="ga1d45ca1f944c59bd38c7c45bf556a1a8" name="ga1d45ca1f944c59bd38c7c45bf556a1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d45ca1f944c59bd38c7c45bf556a1a8">&#9670;&#160;</a></span>e_repl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename X, size_t L = const_lit_for&lt;K, X&gt;::Count&gt; <br />
requires (N &gt; 1)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_repl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string expression that generates a string with all occurrences of a given substring replaced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- the type of the symbol, inferred from the first argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>- starting line. </td></tr>
    <tr><td class="paramname">p</td><td>- string literal, searched substring. </td></tr>
    <tr><td class="paramname">r</td><td>- string literal, what to replace with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae84acc2cd8a75190b0beb985b2a8d3bd" name="gae84acc2cd8a75190b0beb985b2a8d3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae84acc2cd8a75190b0beb985b2a8d3bd">&#9670;&#160;</a></span>e_repl_const_symbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseVector = false, typename K, typename ... Repl&gt; <br />
requires (sizeof...(Repl) % 2 == 0)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_repl_const_symbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Repl &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string expression that generates a string containing the given characters replaced with given substrings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseVector</td><td>- use a vector to save symbol search results. Described in more detail in <code><a class="el" href="structsimstr_1_1expr__replace__symbols.html" title="A type for a string expression that generates a string in which the given characters are replaced by ...">expr_replace_symbols</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- source string. </td></tr>
    <tr><td class="paramname">symbol</td><td>- constant symbol that needs to be replaced. </td></tr>
    <tr><td class="paramname">repl</td><td>- string literal to replace the character with. </td></tr>
    <tr><td class="paramname">...</td><td>symbol, repl - other symbols and strings.</td></tr>
  </table>
  </dd>
</dl>
<p>Used to generate character replacements for strings if all of them are known at compile time. Example:</p>
<div class="fragment"><div class="line">out += <span class="stringliteral">&quot;&lt;div&gt;&quot;</span> + <a class="code hl_function" href="#gae84acc2cd8a75190b0beb985b2a8d3bd">e_repl_const_symbols</a>(text, <span class="charliteral">&#39;\&quot;&#39;</span>, <span class="stringliteral">&quot;&amp;quot;&quot;</span>, <span class="charliteral">&#39;&lt;&#39;</span>, <span class="stringliteral">&quot;&amp;lt;&quot;</span>, <span class="charliteral">&#39;\&#39;&#39;</span>, <span class="stringliteral">&quot;&amp;#39;&quot;</span>, <span class="charliteral">&#39;&amp;&#39;</span>, <span class="stringliteral">&quot;&amp;amp;&quot;</span>) + <span class="stringliteral">&quot;&lt;/div&gt;&quot;</span>;</div>
<div class="ttc" id="agroup___str_exprs_html_gae84acc2cd8a75190b0beb985b2a8d3bd"><div class="ttname"><a href="#gae84acc2cd8a75190b0beb985b2a8d3bd">simstr::e_repl_const_symbols</a></div><div class="ttdeci">auto e_repl_const_symbols(simple_str&lt; K &gt; src, Repl &amp;&amp;... other)</div><div class="ttdoc">Returns a string expression that generates a string containing the given characters replaced with giv...</div><div class="ttdef"><b>Definition</b> sstring.h:6715</div></div>
</div><!-- fragment --><p> In principle, <code>e_repl_const_symbols</code> is quite safe to return from a function if the source string external to function.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> repl_html_symbols(ssa text) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="#gae84acc2cd8a75190b0beb985b2a8d3bd">e_repl_const_symbols</a>(text, <span class="charliteral">&#39;\&quot;&#39;</span>, <span class="stringliteral">&quot;&amp;quot;&quot;</span>, <span class="charliteral">&#39;&lt;&#39;</span>, <span class="stringliteral">&quot;&amp;lt;&quot;</span>, <span class="charliteral">&#39;\&#39;&#39;</span>, <span class="stringliteral">&quot;&amp;#39;&quot;</span>, <span class="charliteral">&#39;&amp;&#39;</span>, <span class="stringliteral">&quot;&amp;amp;&quot;</span>);</div>
<div class="line">}</div>
<div class="line">....</div>
<div class="line">out += <span class="stringliteral">&quot;&lt;div&gt;&quot;</span> + repl_html_symbols(content) + <span class="stringliteral">&quot;&lt;/div&gt;&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga33e02268e25a635b4b7e14d0744b46c1" name="ga33e02268e25a635b4b7e14d0744b46c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33e02268e25a635b4b7e14d0744b46c1">&#9670;&#160;</a></span>e_spca()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; u8s, N &gt; simstr::e_spca </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string of N char spaces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>- Number of spaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string expression for N char spaces.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">stringa text = <a class="code hl_function" href="#ga33e02268e25a635b4b7e14d0744b46c1">e_spca&lt;10&gt;</a>() + text + <a class="code hl_function" href="#ga33e02268e25a635b4b7e14d0744b46c1">e_spca&lt;10&gt;</a>();</div>
<div class="ttc" id="agroup___str_exprs_html_ga33e02268e25a635b4b7e14d0744b46c1"><div class="ttname"><a href="#ga33e02268e25a635b4b7e14d0744b46c1">simstr::e_spca</a></div><div class="ttdeci">constexpr expr_spaces&lt; u8s, N &gt; e_spca()</div><div class="ttdoc">Generates a string of N char spaces.</div><div class="ttdef"><b>Definition</b> strexpr.h:751</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga23b5d15132fcc706d1edc1364673a4ab" name="ga23b5d15132fcc706d1edc1364673a4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b5d15132fcc706d1edc1364673a4ab">&#9670;&#160;</a></span>e_spcw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; uws, N &gt; simstr::e_spcw </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string of N wchar_t spaces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>- Number of spaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string expression for N wchar_t spaces.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">stringw text = <a class="code hl_function" href="#ga23b5d15132fcc706d1edc1364673a4ab">e_spcw&lt;10&gt;</a>() + text + <a class="code hl_function" href="#ga23b5d15132fcc706d1edc1364673a4ab">e_spcw&lt;10&gt;</a>();</div>
<div class="ttc" id="agroup___str_exprs_html_ga23b5d15132fcc706d1edc1364673a4ab"><div class="ttname"><a href="#ga23b5d15132fcc706d1edc1364673a4ab">simstr::e_spcw</a></div><div class="ttdeci">constexpr expr_spaces&lt; uws, N &gt; e_spcw()</div><div class="ttdoc">Generates a string of N wchar_t spaces.</div><div class="ttdef"><b>Definition</b> strexpr.h:769</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9e9c377a32a2cc243efce977c4adffe3" name="ga9e9c377a32a2cc243efce977c4adffe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e9c377a32a2cc243efce977c4adffe3">&#9670;&#160;</a></span>e_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit&lt;T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_literal&lt; typename const_lit&lt; T &gt;::symb_type, static_cast&lt; size_t &gt;(N - 1)&gt; simstr::e_t </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string literal to a string expression. </p>
<p>String literals are not themselves string expressions. This usually does not cause problems in concatenation operations, since the second operand is already a string expression, and addition with a literal works for it. But there are situations when the second operand is not either string expression. For example: </p><div class="fragment"><div class="line"> <span class="keywordtype">int</span> intVar = calculate();</div>
<div class="line"> ...</div>
<div class="line">res = <span class="stringliteral">&quot;text&quot;</span> + intVar;</div>
<div class="line"> ...</div>
<div class="line">res = intVar + <span class="stringliteral">&quot;text&quot;</span>;</div>
</div><!-- fragment --><p> In this case, you can convert the literal to a string expression in two ways:</p><ul>
<li>add _ss: <code>"text"_ss</code>, which converts the literal to <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>: <code>res = "text"_ss + intVar</code></li>
<li>apply e_t: <code>e_t("text")</code>, which converts the literal to expr_literal: <code>res = e_t("text") + intVar</code></li>
</ul>
<p>In the second method, the compiler can more aggressively apply optimizations related to what is known at compilation literal size.</p>
<p>Although strictly speaking, in these situations you can use other methods:</p><ul>
<li>Add an operand - an empty string expression: <code>result = eea + "text" + intVar</code>, <code>result = "text" + eea + intVar</code></li>
<li>Convert another operand to a string expression: <code>result = "text" + e_num&lt;u8s&gt;(intVar)</code>.</li>
</ul>
<p>All these methods work and give the same result. Which one to use is a matter of taste. </p>

</div>
</div>
<a id="ga9742e8cdcccc67c0746578f3579127e2" name="ga9742e8cdcccc67c0746578f3579127e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9742e8cdcccc67c0746578f3579127e2">&#9670;&#160;</a></span>operator+() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin.html">strexprjoin</a>&lt; A, B &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An addition operator for two arbitrary string expressions of the same character type. </p>
<p><a class="anchor" id="op_plus_str_expr"></a></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- first string expression </td></tr>
    <tr><td class="paramname">b</td><td>- second string expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1strexprjoin.html" title="Template class for concatenating two string expressions into one using operator +">strexprjoin&lt;A, B&gt;</a>, a string expression that generates a join of the given expressions.</dd></dl>
<p>When two objects are added - string expressions, one of type <code>A</code>, the other of type <code>B</code>, we return an object of type <a class="el" href="structsimstr_1_1strexprjoin.html" title="Template class for concatenating two string expressions into one using operator +">strexprjoin&lt;A, B&gt;</a>, which contains references to these two operands. And the <a class="el" href="structsimstr_1_1strexprjoin.html" title="Template class for concatenating two string expressions into one using operator +">strexprjoin&lt;A, B&gt;</a> object itself, in turn, is also a string expression, and can participate in the following addition operations. In this way, a “tree” is formed from the original strings expressions, which are then “materialized” into the final result in one call. </p>

</div>
</div>
<a id="ga9d8bc7652fac165ad43ae054fb083616" name="ga9d8bc7652fac165ad43ae054fb083616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d8bc7652fac165ad43ae054fb083616">&#9670;&#160;</a></span>operator+() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, StrExprForType&lt; K &gt; A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_char&lt; K &gt; &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator of a string expression and one character. </p>
<dl class="section return"><dt>Returns</dt><dd>a string expression that combines the passed expression and a character.</dd></dl>
<p>Example:</p>
<div class="fragment"><div class="line">reply = prompt + <span class="charliteral">&#39;&gt;&#39;</span> + result;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gafcde8bf3ec1de77095e9dc62faf5cbcd" name="gafcde8bf3ec1de77095e9dc62faf5cbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcde8bf3ec1de77095e9dc62faf5cbcd">&#9670;&#160;</a></span>operator+() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename R&gt; <br />
requires (std::is_same_v&lt;R, double&gt; || std::is_same_v&lt;R, float&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for string expression and real number (<code>float</code>, <code>double</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a string expression. </td></tr>
    <tr><td class="paramname">s</td><td>- number.</td></tr>
  </table>
  </dd>
</dl>
<p>The number is converted to a string representation via sprintf("%.16g"). </p>

</div>
</div>
<a id="gac9528a989819fa724d6e4ca739a749a3" name="gac9528a989819fa724d6e4ca739a749a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9528a989819fa724d6e4ca739a749a3">&#9670;&#160;</a></span>operator+() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename K = typename A::symb_type, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_literal_join&lt; false, K,(N - 1), A &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The addition operator for a string expression and a string literal of the same character type. </p>
<dl class="section return"><dt>Returns</dt><dd>A string expression concatenating the operands. </dd></dl>

</div>
</div>
<a id="ga0421f6f954a1f0a4575cb282c1e36712" name="ga0421f6f954a1f0a4575cb282c1e36712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0421f6f954a1f0a4575cb282c1e36712">&#9670;&#160;</a></span>operator+() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, FromIntNumber T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_num&lt; typename A::symb_type, T &gt; &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for string expression and integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a string expression. </td></tr>
    <tr><td class="paramname">s</td><td>- number.</td></tr>
  </table>
  </dd>
</dl>
<p>The number is converted to a decimal string representation. </p>

</div>
</div>
<a id="ga5f311136af3a57df58765525136811cb" name="ga5f311136af3a57df58765525136811cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f311136af3a57df58765525136811cb">&#9670;&#160;</a></span>operator+() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename R&gt; <br />
requires (is_one_of_std_char_v&lt;typename A::symb_type&gt; &amp;&amp; (std::is_same_v&lt;R, double&gt; || std::is_same_v&lt;R, float&gt;))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">R</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for float (<code>float</code>, <code>double</code>) and string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- number. </td></tr>
    <tr><td class="paramname">a</td><td>is a string expression.</td></tr>
  </table>
  </dd>
</dl>
<p>The number is converted to a string representation via <code>sprintf("%.16g")</code>. </p>

</div>
</div>
<a id="ga6981ff65002b1267ef4662fa22e2bacf" name="ga6981ff65002b1267ef4662fa22e2bacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6981ff65002b1267ef4662fa22e2bacf">&#9670;&#160;</a></span>operator+() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename K = typename A::symb_type, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_literal_join&lt; true, K,(N - 1), A &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The addition operator for a string literal of the same character type and string expression. </p>
<dl class="section return"><dt>Returns</dt><dd>A string expression concatenating the operands. </dd></dl>

</div>
</div>
<a id="gaff6edec79f617564db65f91039283f39" name="gaff6edec79f617564db65f91039283f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff6edec79f617564db65f91039283f39">&#9670;&#160;</a></span>operator+() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, FromIntNumber T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_num&lt; typename A::symb_type, T &gt;, false &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for integer and string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- number. </td></tr>
    <tr><td class="paramname">a</td><td>is a string expression.</td></tr>
  </table>
  </dd>
</dl>
<p>The number is converted to a decimal string representation. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

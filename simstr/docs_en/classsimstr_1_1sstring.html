<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: simstr::sstring&lt; K, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.6.0</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsimstr_1_1sstring.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsimstr_1_1sstring-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simstr::sstring&lt; K, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Immutable owning string class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sstring_8h_source.html">sstring.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for simstr::sstring&lt; K, Allocator &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsimstr_1_1sstring.png" usemap="#simstr::sstring_3C_20K_2C_20Allocator_20_3E_map" alt=""/>
  <map id="simstr::sstring_3C_20K_2C_20Allocator_20_3E_map" name="simstr::sstring_3C_20K_2C_20Allocator_20_3E_map">
<area href="classsimstr_1_1str__algs.html" alt="simstr::str_algs&lt; K, simple_str&lt; K &gt;, sstring&lt; K, allocator_string &gt;, false &gt;" shape="rect" coords="0,56,476,80"/>
<area href="classsimstr_1_1str__storable.html" alt="simstr::str_storable&lt; K, sstring&lt; K, allocator_string &gt;, allocator_string &gt;" shape="rect" coords="486,56,962,80"/>
<area href="classsimstr_1_1from__utf__convertible.html" alt="simstr::from_utf_convertible&lt; K, sstring&lt; K, allocator_string &gt; &gt;" shape="rect" coords="972,56,1448,80"/>
<area href="classsimstr_1_1str__src__algs.html" alt="simstr::str_src_algs&lt; K, simple_str&lt; K &gt;, sstring&lt; K, allocator_string &gt;, Mutable &gt;" shape="rect" coords="0,0,476,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea69c6325884ae95e7d1989d5f9a0209" id="r_aea69c6325884ae95e7d1989d5f9a0209"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (std::is_constructible_v&lt;allocator_t, Args...&gt; &amp;&amp; sizeof...(Args) &gt; 0)</td></tr>
<tr class="memitem:aea69c6325884ae95e7d1989d5f9a0209"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea69c6325884ae95e7d1989d5f9a0209">sstring</a> (Args &amp;&amp;... args) noexcept(std::is_nothrow_constructible_v&lt; allocator_t, Args... &gt;)</td></tr>
<tr class="memdesc:aea69c6325884ae95e7d1989d5f9a0209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the empty string.  <br /></td></tr>
<tr class="separator:aea69c6325884ae95e7d1989d5f9a0209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352a1e2de2de7c2d75a82075f9c9db3d" id="r_a352a1e2de2de7c2d75a82075f9c9db3d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a352a1e2de2de7c2d75a82075f9c9db3d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a352a1e2de2de7c2d75a82075f9c9db3d">sstring</a> (<a class="el" href="structsimstr_1_1simple__str.html">s_str</a> other, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a352a1e2de2de7c2d75a82075f9c9db3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor from another string object.  <br /></td></tr>
<tr class="separator:a352a1e2de2de7c2d75a82075f9c9db3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618a19b34ef8db3e8ac3aa903175ccd3" id="r_a618a19b34ef8db3e8ac3aa903175ccd3"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a618a19b34ef8db3e8ac3aa903175ccd3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a618a19b34ef8db3e8ac3aa903175ccd3">sstring</a> (size_t repeat, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a618a19b34ef8db3e8ac3aa903175ccd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">String repetition constructor.  <br /></td></tr>
<tr class="separator:a618a19b34ef8db3e8ac3aa903175ccd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef46eb3fb57583ad6f71a3452f630ca" id="r_a3ef46eb3fb57583ad6f71a3452f630ca"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a3ef46eb3fb57583ad6f71a3452f630ca"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ef46eb3fb57583ad6f71a3452f630ca">sstring</a> (size_t count, K pad, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3ef46eb3fb57583ad6f71a3452f630ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character repetition constructor.  <br /></td></tr>
<tr class="separator:a3ef46eb3fb57583ad6f71a3452f630ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cb8a560660d8ecbe923fe129b91085" id="r_ae5cb8a560660d8ecbe923fe129b91085"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:ae5cb8a560660d8ecbe923fe129b91085"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5cb8a560660d8ecbe923fe129b91085">sstring</a> (const StrExprForType&lt; K &gt; auto &amp;expr, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae5cb8a560660d8ecbe923fe129b91085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a string expression.  <br /></td></tr>
<tr class="separator:ae5cb8a560660d8ecbe923fe129b91085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7bf5c4af291131936a6e22eaa831c2" id="r_afc7bf5c4af291131936a6e22eaa831c2"><td class="memTemplParams" colspan="2">template&lt;StrType&lt; K &gt; From, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:afc7bf5c4af291131936a6e22eaa831c2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afc7bf5c4af291131936a6e22eaa831c2">sstring</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:afc7bf5c4af291131936a6e22eaa831c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from string source with replacement.  <br /></td></tr>
<tr class="separator:afc7bf5c4af291131936a6e22eaa831c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e986175aeb545eabcc5fbcfc11f72f" id="r_af3e986175aeb545eabcc5fbcfc11f72f"><td class="memItemLeft" align="right" valign="top"><a id="af3e986175aeb545eabcc5fbcfc11f72f" name="af3e986175aeb545eabcc5fbcfc11f72f"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>~sstring</b> ()</td></tr>
<tr class="memdesc:af3e986175aeb545eabcc5fbcfc11f72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">String destructor. <br /></td></tr>
<tr class="separator:af3e986175aeb545eabcc5fbcfc11f72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab876fcbc688f999e75704f13e01be" id="r_a40ab876fcbc688f999e75704f13e01be"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40ab876fcbc688f999e75704f13e01be">sstring</a> (const <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a40ab876fcbc688f999e75704f13e01be"><td class="mdescLeft">&#160;</td><td class="mdescRight">String copy constructor.  <br /></td></tr>
<tr class="separator:a40ab876fcbc688f999e75704f13e01be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8546ee3cde089fc614033c2fb3a22c" id="r_abb8546ee3cde089fc614033c2fb3a22c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb8546ee3cde089fc614033c2fb3a22c">sstring</a> (<a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:abb8546ee3cde089fc614033c2fb3a22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:abb8546ee3cde089fc614033c2fb3a22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895058580f91a0295acda313b9e23c12" id="r_a895058580f91a0295acda313b9e23c12"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a895058580f91a0295acda313b9e23c12"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a895058580f91a0295acda313b9e23c12">sstring</a> (<a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, true, Allocator &gt; &amp;&amp;src)</td></tr>
<tr class="memdesc:a895058580f91a0295acda313b9e23c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">A move constructor from lstring with an sstring-compatible external buffer.  <br /></td></tr>
<tr class="separator:a895058580f91a0295acda313b9e23c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873059081053f7d9c9ab251d3ed7721d" id="r_a873059081053f7d9c9ab251d3ed7721d"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a873059081053f7d9c9ab251d3ed7721d"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a873059081053f7d9c9ab251d3ed7721d">sstring</a> (T &amp;&amp;s, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a873059081053f7d9c9ab251d3ed7721d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from a string literal.  <br /></td></tr>
<tr class="separator:a873059081053f7d9c9ab251d3ed7721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b4c4809190881aab635d1688999dc" id="r_a760b4c4809190881aab635d1688999dc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760b4c4809190881aab635d1688999dc">operator=</a> (<a class="el" href="classsimstr_1_1sstring.html">my_type</a> other) noexcept</td></tr>
<tr class="memdesc:a760b4c4809190881aab635d1688999dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator to another string of the same type.  <br /></td></tr>
<tr class="separator:a760b4c4809190881aab635d1688999dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c99f7d4fbb03a5238e2bc9d750591f" id="r_ac2c99f7d4fbb03a5238e2bc9d750591f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2c99f7d4fbb03a5238e2bc9d750591f">operator=</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt; other)</td></tr>
<tr class="memdesc:ac2c99f7d4fbb03a5238e2bc9d750591f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator to another string of a different type.  <br /></td></tr>
<tr class="separator:ac2c99f7d4fbb03a5238e2bc9d750591f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f08dbc02e99f3cfff5011afeb389f61" id="r_a5f08dbc02e99f3cfff5011afeb389f61"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:a5f08dbc02e99f3cfff5011afeb389f61"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f08dbc02e99f3cfff5011afeb389f61">operator=</a> (T &amp;&amp;other)</td></tr>
<tr class="memdesc:a5f08dbc02e99f3cfff5011afeb389f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">String literal assignment operator.  <br /></td></tr>
<tr class="separator:a5f08dbc02e99f3cfff5011afeb389f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ef58e8b8305988a9ca634460109204" id="r_a28ef58e8b8305988a9ca634460109204"><td class="memTemplParams" colspan="2">template&lt;size_t N, bool forShared, typename A&gt; </td></tr>
<tr class="memitem:a28ef58e8b8305988a9ca634460109204"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28ef58e8b8305988a9ca634460109204">operator=</a> (const <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, forShared, A &gt; &amp;other)</td></tr>
<tr class="memdesc:a28ef58e8b8305988a9ca634460109204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator to another string of type lstring.  <br /></td></tr>
<tr class="separator:a28ef58e8b8305988a9ca634460109204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39824f566fd5a9373af91c4e24d8897" id="r_ae39824f566fd5a9373af91c4e24d8897"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ae39824f566fd5a9373af91c4e24d8897"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae39824f566fd5a9373af91c4e24d8897">operator=</a> (<a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, true, Allocator &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ae39824f566fd5a9373af91c4e24d8897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator to a movable string of type lstring with a compatible buffer.  <br /></td></tr>
<tr class="separator:ae39824f566fd5a9373af91c4e24d8897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace848e3ccdf857a365ad5e395f7f6528" id="r_ace848e3ccdf857a365ad5e395f7f6528"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace848e3ccdf857a365ad5e395f7f6528">operator=</a> (const StrExprForType&lt; K &gt; auto &amp;expr)</td></tr>
<tr class="memdesc:ace848e3ccdf857a365ad5e395f7f6528"><td class="mdescLeft">&#160;</td><td class="mdescRight">String expression assignment operator.  <br /></td></tr>
<tr class="separator:ace848e3ccdf857a365ad5e395f7f6528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d01e72c7352735003c55c33f33fffd" id="r_ac7d01e72c7352735003c55c33f33fffd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7d01e72c7352735003c55c33f33fffd">make_empty</a> () noexcept</td></tr>
<tr class="memdesc:ac7d01e72c7352735003c55c33f33fffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the string empty.  <br /></td></tr>
<tr class="separator:ac7d01e72c7352735003c55c33f33fffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f608228b4db83ce396f48ec5373b36f" id="r_a3f608228b4db83ce396f48ec5373b36f"><td class="memItemLeft" align="right" valign="top"><a id="a3f608228b4db83ce396f48ec5373b36f" name="a3f608228b4db83ce396f48ec5373b36f"></a>
constexpr const K *&#160;</td><td class="memItemRight" valign="bottom"><b>symbols</b> () const noexcept</td></tr>
<tr class="memdesc:a3f608228b4db83ce396f48ec5373b36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to characters in the string. <br /></td></tr>
<tr class="separator:a3f608228b4db83ce396f48ec5373b36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c22e6630eb8ec76c43da7c13f2adf83" id="r_a8c22e6630eb8ec76c43da7c13f2adf83"><td class="memItemLeft" align="right" valign="top"><a id="a8c22e6630eb8ec76c43da7c13f2adf83" name="a8c22e6630eb8ec76c43da7c13f2adf83"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> () const noexcept</td></tr>
<tr class="memdesc:a8c22e6630eb8ec76c43da7c13f2adf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line length. <br /></td></tr>
<tr class="separator:a8c22e6630eb8ec76c43da7c13f2adf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35191ce33c60798706f8403507ea04f7" id="r_a35191ce33c60798706f8403507ea04f7"><td class="memItemLeft" align="right" valign="top"><a id="a35191ce33c60798706f8403507ea04f7" name="a35191ce33c60798706f8403507ea04f7"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const noexcept</td></tr>
<tr class="memdesc:a35191ce33c60798706f8403507ea04f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the string empty? <br /></td></tr>
<tr class="separator:a35191ce33c60798706f8403507ea04f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad525f8016f703d729af00538b5f2a3" id="r_a2ad525f8016f703d729af00538b5f2a3"><td class="memItemLeft" align="right" valign="top"><a id="a2ad525f8016f703d729af00538b5f2a3" name="a2ad525f8016f703d729af00538b5f2a3"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:a2ad525f8016f703d729af00538b5f2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string is empty, for compatibility with std::string. <br /></td></tr>
<tr class="separator:a2ad525f8016f703d729af00538b5f2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400250ea87cc59daa152dc9ddb57491f" id="r_a400250ea87cc59daa152dc9ddb57491f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a400250ea87cc59daa152dc9ddb57491f">compare_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a400250ea87cc59daa152dc9ddb57491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character without taking into account the case of Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a400250ea87cc59daa152dc9ddb57491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf0990c46a280cd363da46bef12e02f" id="r_adbf0990c46a280cd363da46bef12e02f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#adbf0990c46a280cd363da46bef12e02f">equal_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:adbf0990c46a280cd363da46bef12e02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is equal to another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:adbf0990c46a280cd363da46bef12e02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79e99462478b57d62873f7942ff2b6" id="r_a4e79e99462478b57d62873f7942ff2b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a4e79e99462478b57d62873f7942ff2b6">less_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a4e79e99462478b57d62873f7942ff2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is smaller than another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a4e79e99462478b57d62873f7942ff2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26465c7fdac87e8d215e836bdbf6e8c3" id="r_a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a26465c7fdac87e8d215e836bdbf6e8c3">starts_with_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string starts with the given substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535d655a6702861b788830a1d266e48f" id="r_a535d655a6702861b788830a1d266e48f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a535d655a6702861b788830a1d266e48f">ends_with_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a535d655a6702861b788830a1d266e48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a535d655a6702861b788830a1d266e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3ef69a372dab777c952f22c492689" id="r_a6ae3ef69a372dab777c952f22c492689"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a6ae3ef69a372dab777c952f22c492689">upperred</a> () const</td></tr>
<tr class="memdesc:a6ae3ef69a372dab777c952f22c492689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in upper case Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a6ae3ef69a372dab777c952f22c492689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51ac2887746e40214eeee7d52460f4" id="r_a8d51ac2887746e40214eeee7d52460f4"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a8d51ac2887746e40214eeee7d52460f4">lowered</a> () const</td></tr>
<tr class="memdesc:a8d51ac2887746e40214eeee7d52460f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in lowercase Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a8d51ac2887746e40214eeee7d52460f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af52e61e73c687a34ff6978304edc3" id="r_aa1af52e61e73c687a34ff6978304edc3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aa1af52e61e73c687a34ff6978304edc3">to_double</a> () const noexcept</td></tr>
<tr class="memdesc:aa1af52e61e73c687a34ff6978304edc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <br /></td></tr>
<tr class="separator:aa1af52e61e73c687a34ff6978304edc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860598fca0df848662d7d8578a8f6da" id="r_af860598fca0df848662d7d8578a8f6da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af860598fca0df848662d7d8578a8f6da">as_number</a> (double &amp;t) const</td></tr>
<tr class="memdesc:af860598fca0df848662d7d8578a8f6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <br /></td></tr>
<tr class="separator:af860598fca0df848662d7d8578a8f6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17421202713ebd4d62ddf175023f535" id="r_ac17421202713ebd4d62ddf175023f535"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ac17421202713ebd4d62ddf175023f535">as_number</a> (T &amp;t) const</td></tr>
<tr class="memdesc:ac17421202713ebd4d62ddf175023f535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an integer.  <br /></td></tr>
<tr class="separator:ac17421202713ebd4d62ddf175023f535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af893677739e0d24418f6acc0a29090cc" id="r_af893677739e0d24418f6acc0a29090cc"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place</a> (K *ptr) const noexcept</td></tr>
<tr class="memdesc:af893677739e0d24418f6acc0a29090cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string to the specified buffer.  <br /></td></tr>
<tr class="separator:af893677739e0d24418f6acc0a29090cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2498615b426546b65e9b6c4f973264" id="r_a3c2498615b426546b65e9b6c4f973264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a3c2498615b426546b65e9b6c4f973264">copy_to</a> (K *buffer, size_t bufSize)</td></tr>
<tr class="memdesc:a3c2498615b426546b65e9b6c4f973264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string to the specified buffer.  <br /></td></tr>
<tr class="separator:a3c2498615b426546b65e9b6c4f973264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2732ccf421fcd1ba606addcca7e6e42" id="r_aa2732ccf421fcd1ba606addcca7e6e42"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa2732ccf421fcd1ba606addcca7e6e42">size</a> () const</td></tr>
<tr class="memdesc:aa2732ccf421fcd1ba606addcca7e6e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the string in characters.  <br /></td></tr>
<tr class="separator:aa2732ccf421fcd1ba606addcca7e6e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2af1ee80a32a77ad30cffbf6987107" id="r_a1f2af1ee80a32a77ad30cffbf6987107"><td class="memItemLeft" align="right" valign="top">constexpr std::basic_string_view&lt; D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a1f2af1ee80a32a77ad30cffbf6987107">to_sv</a> () const noexcept</td></tr>
<tr class="memdesc:a1f2af1ee80a32a77ad30cffbf6987107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::basic_string_view.  <br /></td></tr>
<tr class="separator:a1f2af1ee80a32a77ad30cffbf6987107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c6b4c365f05e609a7b22cbf37b39c6" id="r_ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab4c6b4c365f05e609a7b22cbf37b39c6">operator std::basic_string_view&lt; D, Traits &gt;</a> () const</td></tr>
<tr class="memdesc:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::basic_string_view.  <br /></td></tr>
<tr class="separator:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc816f095922a510dfe466db1905fc63" id="r_adc816f095922a510dfe466db1905fc63"><td class="memItemLeft" align="right" valign="top">constexpr std::basic_string&lt; D, Traits, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#adc816f095922a510dfe466db1905fc63">to_string</a> () const</td></tr>
<tr class="memdesc:adc816f095922a510dfe466db1905fc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::basic_string.  <br /></td></tr>
<tr class="separator:adc816f095922a510dfe466db1905fc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9959513e8a072c51620248c4a29f4196" id="r_a9959513e8a072c51620248c4a29f4196"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9959513e8a072c51620248c4a29f4196">operator std::basic_string&lt; D, Traits, Allocator &gt;</a> () const</td></tr>
<tr class="memdesc:a9959513e8a072c51620248c4a29f4196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::basic_string.  <br /></td></tr>
<tr class="separator:a9959513e8a072c51620248c4a29f4196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916218a7a75a3866a9d3d0da9334653c" id="r_a916218a7a75a3866a9d3d0da9334653c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a916218a7a75a3866a9d3d0da9334653c">operator str_piece</a> () const noexcept</td></tr>
<tr class="memdesc:a916218a7a75a3866a9d3d0da9334653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert itself to a "string chunk" that includes the entire string.  <br /></td></tr>
<tr class="separator:a916218a7a75a3866a9d3d0da9334653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d19b3fba03bfd481d2a3b3def766af" id="r_a53d19b3fba03bfd481d2a3b3def766af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a53d19b3fba03bfd481d2a3b3def766af">to_str</a> () const noexcept</td></tr>
<tr class="memdesc:a53d19b3fba03bfd481d2a3b3def766af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert itself to a "string chunk" that includes the entire string.  <br /></td></tr>
<tr class="separator:a53d19b3fba03bfd481d2a3b3def766af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8f275b33545d2491850f49ba3b7876" id="r_ace8f275b33545d2491850f49ba3b7876"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ace8f275b33545d2491850f49ba3b7876">operator()</a> (ptrdiff_t from, ptrdiff_t len=0) const noexcept</td></tr>
<tr class="memdesc:ace8f275b33545d2491850f49ba3b7876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string as "str_src".  <br /></td></tr>
<tr class="separator:ace8f275b33545d2491850f49ba3b7876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507a43e6ebcc51e6409874712abbbd63" id="r_a507a43e6ebcc51e6409874712abbbd63"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a507a43e6ebcc51e6409874712abbbd63">mid</a> (size_t from, size_t len=-1) const noexcept</td></tr>
<tr class="memdesc:a507a43e6ebcc51e6409874712abbbd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string as "string chunk".  <br /></td></tr>
<tr class="separator:a507a43e6ebcc51e6409874712abbbd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5659e7fb47dfb6bd6736a1b454ffde92" id="r_a5659e7fb47dfb6bd6736a1b454ffde92"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a5659e7fb47dfb6bd6736a1b454ffde92">from_to</a> (size_t from, size_t to) const noexcept</td></tr>
<tr class="memdesc:a5659e7fb47dfb6bd6736a1b454ffde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substring <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a> from position from to position to (not including it).  <br /></td></tr>
<tr class="separator:a5659e7fb47dfb6bd6736a1b454ffde92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a3ed434bc8ecc755076da742f8e5b" id="r_a992a3ed434bc8ecc755076da742f8e5b"><td class="memItemLeft" align="right" valign="top"><a id="a992a3ed434bc8ecc755076da742f8e5b" name="a992a3ed434bc8ecc755076da742f8e5b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!</b> () const noexcept</td></tr>
<tr class="memdesc:a992a3ed434bc8ecc755076da742f8e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for emptiness. <br /></td></tr>
<tr class="separator:a992a3ed434bc8ecc755076da742f8e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c053de38bf2a0eab39cf1de5b0a21a" id="r_ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="memItemLeft" align="right" valign="top">constexpr K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad2c053de38bf2a0eab39cf1de5b0a21a">at</a> (ptrdiff_t idx) const</td></tr>
<tr class="memdesc:ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at the given position.  <br /></td></tr>
<tr class="separator:ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d9cd0dc24f5d395e838a3ef20d846" id="r_a108d9cd0dc24f5d395e838a3ef20d846"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a108d9cd0dc24f5d395e838a3ef20d846">compare</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> o) const</td></tr>
<tr class="memdesc:a108d9cd0dc24f5d395e838a3ef20d846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character.  <br /></td></tr>
<tr class="separator:a108d9cd0dc24f5d395e838a3ef20d846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d501d16ab38c3efb1427f14ea7f67" id="r_a610d501d16ab38c3efb1427f14ea7f67"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a610d501d16ab38c3efb1427f14ea7f67">strcmp</a> (const K *text) const</td></tr>
<tr class="memdesc:a610d501d16ab38c3efb1427f14ea7f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare with C-string character by character.  <br /></td></tr>
<tr class="separator:a610d501d16ab38c3efb1427f14ea7f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b0cb780c465cb9b6bd925d712ff07" id="r_a3b9b0cb780c465cb9b6bd925d712ff07"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a3b9b0cb780c465cb9b6bd925d712ff07">equal</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other) const noexcept</td></tr>
<tr class="memdesc:a3b9b0cb780c465cb9b6bd925d712ff07"><td class="mdescLeft">&#160;</td><td class="mdescRight">String comparison for equality.  <br /></td></tr>
<tr class="separator:a3b9b0cb780c465cb9b6bd925d712ff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddd0a1f9b25247465fb55c79b58826d" id="r_a1ddd0a1f9b25247465fb55c79b58826d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a1ddd0a1f9b25247465fb55c79b58826d">operator==</a> (const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a1ddd0a1f9b25247465fb55c79b58826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator comparing strings for equality.  <br /></td></tr>
<tr class="separator:a1ddd0a1f9b25247465fb55c79b58826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19dc728f9d7edafbd85a52e70b46376" id="r_ac19dc728f9d7edafbd85a52e70b46376"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac19dc728f9d7edafbd85a52e70b46376">operator==</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ac19dc728f9d7edafbd85a52e70b46376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for comparing a string and a string literal for equality.  <br /></td></tr>
<tr class="separator:ac19dc728f9d7edafbd85a52e70b46376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34637c1f071ac6e6faa0237a092cc61" id="r_ac34637c1f071ac6e6faa0237a092cc61"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac34637c1f071ac6e6faa0237a092cc61">operator&lt;=&gt;</a> (const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ac34637c1f071ac6e6faa0237a092cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">String comparison operator.  <br /></td></tr>
<tr class="separator:ac34637c1f071ac6e6faa0237a092cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63f315c4a97ee6ad1e2b045b9f5f9e0" id="r_ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad63f315c4a97ee6ad1e2b045b9f5f9e0">operator&lt;=&gt;</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator between a string and a string literal.  <br /></td></tr>
<tr class="separator:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5e10ff025504ee5d60e8c77f439003" id="r_a0e5e10ff025504ee5d60e8c77f439003"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0e5e10ff025504ee5d60e8c77f439003">compare_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a0e5e10ff025504ee5d60e8c77f439003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character and not case sensitive ASCII characters.  <br /></td></tr>
<tr class="separator:a0e5e10ff025504ee5d60e8c77f439003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9fca49d189fd0d760ffe8aed1485f1" id="r_afa9fca49d189fd0d760ffe8aed1485f1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#afa9fca49d189fd0d760ffe8aed1485f1">equal_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:afa9fca49d189fd0d760ffe8aed1485f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is equal to another string, character-by-character-insensitive, of ASCII characters.  <br /></td></tr>
<tr class="separator:afa9fca49d189fd0d760ffe8aed1485f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ede528e694988f26555e91cf9a1ca2" id="r_a44ede528e694988f26555e91cf9a1ca2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a44ede528e694988f26555e91cf9a1ca2">less_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a44ede528e694988f26555e91cf9a1ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is smaller than another string, character-by-character-insensitive, ASCII characters.  <br /></td></tr>
<tr class="separator:a44ede528e694988f26555e91cf9a1ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38e5cc7893a20e69cdf03d88232b49c" id="r_ab38e5cc7893a20e69cdf03d88232b49c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab38e5cc7893a20e69cdf03d88232b49c">find</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ab38e5cc7893a20e69cdf03d88232b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:ab38e5cc7893a20e69cdf03d88232b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129d72cc64be6029f10bbe1f8385f3ea" id="r_a129d72cc64be6029f10bbe1f8385f3ea"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a129d72cc64be6029f10bbe1f8385f3ea">find</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a129d72cc64be6029f10bbe1f8385f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a character in this string.  <br /></td></tr>
<tr class="separator:a129d72cc64be6029f10bbe1f8385f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab0482ea5f02bc0c3097bed6c9a5fa" id="r_a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a40ab0482ea5f02bc0c3097bed6c9a5fa">find_or_throw</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, Args &amp;&amp;... args) const noexcept</td></tr>
<tr class="memdesc:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string or throw an exception.  <br /></td></tr>
<tr class="separator:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcde5878d3d7fd5138d38ff2f1df4d2" id="r_a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a8bcde5878d3d7fd5138d38ff2f1df4d2">find_end</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029fd5412ed114bfefbdddba2c50167" id="r_ac029fd5412ed114bfefbdddba2c50167"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac029fd5412ed114bfefbdddba2c50167">find_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac029fd5412ed114bfefbdddba2c50167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string or the end of the string.  <br /></td></tr>
<tr class="separator:ac029fd5412ed114bfefbdddba2c50167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762c55d09b34ba2b7b5f9f10783da662" id="r_a762c55d09b34ba2b7b5f9f10783da662"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a762c55d09b34ba2b7b5f9f10783da662">find_or_all</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a762c55d09b34ba2b7b5f9f10783da662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a character in this string or the end of a string.  <br /></td></tr>
<tr class="separator:a762c55d09b34ba2b7b5f9f10783da662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c56c3345019c8d5dc20717092d52101" id="r_a2c56c3345019c8d5dc20717092d52101"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a2c56c3345019c8d5dc20717092d52101">find_end_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a2c56c3345019c8d5dc20717092d52101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the first occurrence of a substring in this string, or the end of a string.  <br /></td></tr>
<tr class="separator:a2c56c3345019c8d5dc20717092d52101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a2c0b10e857c245f67a2abd7c1a2f0" id="r_a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a72a2c0b10e857c245f67a2abd7c1a2f0">find_last</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the last occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0564461ab81bfbb6c5bd8b4c7e5a496e" id="r_a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0564461ab81bfbb6c5bd8b4c7e5a496e">find_last</a> (K s, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character in this string.  <br /></td></tr>
<tr class="separator:a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab67ba06c8637f93984e45cf349c3eb8" id="r_aab67ba06c8637f93984e45cf349c3eb8"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aab67ba06c8637f93984e45cf349c3eb8">find_end_of_last</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:aab67ba06c8637f93984e45cf349c3eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the last occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:aab67ba06c8637f93984e45cf349c3eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5bdd0e7ab4f7e64e1e776f4dabe11c" id="r_a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6a5bdd0e7ab4f7e64e1e776f4dabe11c">find_last_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the last occurrence of a substring in this string or the end of the string.  <br /></td></tr>
<tr class="separator:a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281c63da2d81ef8aac65a2dad77eb93" id="r_ae281c63da2d81ef8aac65a2dad77eb93"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae281c63da2d81ef8aac65a2dad77eb93">find_end_of_last_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:ae281c63da2d81ef8aac65a2dad77eb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the last occurrence of a substring in this string, or the end of a string.  <br /></td></tr>
<tr class="separator:ae281c63da2d81ef8aac65a2dad77eb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d712294186e2e181910677ba9c3ca7" id="r_ac4d712294186e2e181910677ba9c3ca7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac4d712294186e2e181910677ba9c3ca7">contains</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac4d712294186e2e181910677ba9c3ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string contains the specified substring.  <br /></td></tr>
<tr class="separator:ac4d712294186e2e181910677ba9c3ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8185ccf8fc2297b628cce3c83b6a0b4c" id="r_a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a8185ccf8fc2297b628cce3c83b6a0b4c">for_all_finded</a> (const Op &amp;op, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor on all found occurrences of a substring in this string.  <br /></td></tr>
<tr class="separator:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d568443f3ed5752279098b9a488655" id="r_aa6d568443f3ed5752279098b9a488655"><td class="memItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa6d568443f3ed5752279098b9a488655">find_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:aa6d568443f3ed5752279098b9a488655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all occurrences of a substring in this string.  <br /></td></tr>
<tr class="separator:aa6d568443f3ed5752279098b9a488655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bf839edef0abbd43c3f3654e8e700" id="r_a643bf839edef0abbd43c3f3654e8e700"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a643bf839edef0abbd43c3f3654e8e700">find_first_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a643bf839edef0abbd43c3f3654e8e700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:a643bf839edef0abbd43c3f3654e8e700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5ad9c702f21003a272469cb1edcbf3" id="r_aad5ad9c702f21003a272469cb1edcbf3"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aad5ad9c702f21003a272469cb1edcbf3">find_first_of_idx</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:aad5ad9c702f21003a272469cb1edcbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:aad5ad9c702f21003a272469cb1edcbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff5e918afcc8e1fba9a3ec19c47897" id="r_a63ff5e918afcc8e1fba9a3ec19c47897"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a63ff5e918afcc8e1fba9a3ec19c47897">find_first_not_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a63ff5e918afcc8e1fba9a3ec19c47897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character not from the given character set.  <br /></td></tr>
<tr class="separator:a63ff5e918afcc8e1fba9a3ec19c47897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73806fa93c9ec619ba93d479d413ea0f" id="r_a73806fa93c9ec619ba93d479d413ea0f"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a73806fa93c9ec619ba93d479d413ea0f">find_last_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:a73806fa93c9ec619ba93d479d413ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:a73806fa93c9ec619ba93d479d413ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab630d62252bf1210f573a8c7222942c8" id="r_ab630d62252bf1210f573a8c7222942c8"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab630d62252bf1210f573a8c7222942c8">find_last_of_idx</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:ab630d62252bf1210f573a8c7222942c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:ab630d62252bf1210f573a8c7222942c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775a7c8e218ab3223f0248f225076b7c" id="r_a775a7c8e218ab3223f0248f225076b7c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a775a7c8e218ab3223f0248f225076b7c">find_last_not_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:a775a7c8e218ab3223f0248f225076b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character not from the given character set.  <br /></td></tr>
<tr class="separator:a775a7c8e218ab3223f0248f225076b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512eaf3c2c8736f3021a5bbe60823866" id="r_a512eaf3c2c8736f3021a5bbe60823866"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a512eaf3c2c8736f3021a5bbe60823866">substr</a> (ptrdiff_t from, ptrdiff_t len=0) const</td></tr>
<tr class="memdesc:a512eaf3c2c8736f3021a5bbe60823866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a substring. Works similarly to operator(), only the result is the same type as the method applied to.  <br /></td></tr>
<tr class="separator:a512eaf3c2c8736f3021a5bbe60823866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77c31da012cf5cc23e0a60c1888cec2" id="r_aa77c31da012cf5cc23e0a60c1888cec2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa77c31da012cf5cc23e0a60c1888cec2">str_mid</a> (size_t from, size_t len=-1) const</td></tr>
<tr class="memdesc:aa77c31da012cf5cc23e0a60c1888cec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string with an object of the same type to which the method is applied, similar to mid.  <br /></td></tr>
<tr class="separator:aa77c31da012cf5cc23e0a60c1888cec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4213df62c3208dd26ae540122dcfa45d" id="r_a4213df62c3208dd26ae540122dcfa45d"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a4213df62c3208dd26ae540122dcfa45d">as_int</a> () const noexcept</td></tr>
<tr class="memdesc:a4213df62c3208dd26ae540122dcfa45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number of the given type.  <br /></td></tr>
<tr class="separator:a4213df62c3208dd26ae540122dcfa45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa40ca4ad70df9ec0941599b88c443dc" id="r_afa40ca4ad70df9ec0941599b88c443dc"><td class="memItemLeft" align="right" valign="top">constexpr convert_result&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#afa40ca4ad70df9ec0941599b88c443dc">to_int</a> () const noexcept</td></tr>
<tr class="memdesc:afa40ca4ad70df9ec0941599b88c443dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number of the given type.  <br /></td></tr>
<tr class="separator:afa40ca4ad70df9ec0941599b88c443dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037d07ad0ee024d983927cec3ee81908" id="r_a037d07ad0ee024d983927cec3ee81908"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a037d07ad0ee024d983927cec3ee81908">to_double_hex</a> () const noexcept</td></tr>
<tr class="memdesc:a037d07ad0ee024d983927cec3ee81908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string in hex form to double.  <br /></td></tr>
<tr class="separator:a037d07ad0ee024d983927cec3ee81908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffb295777b82a1475a4fc0d9754481b" id="r_adffb295777b82a1475a4fc0d9754481b"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#adffb295777b82a1475a4fc0d9754481b">splitf</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter, const Op &amp;beforeFunc, size_t offset=0) const</td></tr>
<tr class="memdesc:adffb295777b82a1475a4fc0d9754481b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into parts at a given delimiter, possibly applying a functor to each substring.  <br /></td></tr>
<tr class="separator:adffb295777b82a1475a4fc0d9754481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad7e9416ed3abc8689034463f497e6b" id="r_a4ad7e9416ed3abc8689034463f497e6b"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a4ad7e9416ed3abc8689034463f497e6b">split</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter, size_t offset=0) const</td></tr>
<tr class="memdesc:a4ad7e9416ed3abc8689034463f497e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into substrings using a given delimiter.  <br /></td></tr>
<tr class="separator:a4ad7e9416ed3abc8689034463f497e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2febfef44dabdf863a74db2049410e9f" id="r_a2febfef44dabdf863a74db2049410e9f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a2febfef44dabdf863a74db2049410e9f">starts_with</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a2febfef44dabdf863a74db2049410e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string begins with the given substring.  <br /></td></tr>
<tr class="separator:a2febfef44dabdf863a74db2049410e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9409e48b2f182546b7f7186af2477e" id="r_a6d9409e48b2f182546b7f7186af2477e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6d9409e48b2f182546b7f7186af2477e">starts_with_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a6d9409e48b2f182546b7f7186af2477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string begins with the given substring in a case-insensitive ASCII character.  <br /></td></tr>
<tr class="separator:a6d9409e48b2f182546b7f7186af2477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37c68155961c5c7b1609aa1b873b8d3" id="r_ae37c68155961c5c7b1609aa1b873b8d3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae37c68155961c5c7b1609aa1b873b8d3">prefix_in</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:ae37c68155961c5c7b1609aa1b873b8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this string is the beginning of another string.  <br /></td></tr>
<tr class="separator:ae37c68155961c5c7b1609aa1b873b8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15504449e8d2a8f77832046b559ae0a8" id="r_a15504449e8d2a8f77832046b559ae0a8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a15504449e8d2a8f77832046b559ae0a8">ends_with</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a15504449e8d2a8f77832046b559ae0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring.  <br /></td></tr>
<tr class="separator:a15504449e8d2a8f77832046b559ae0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63742e2c0e55c85b0569f6a0004e5418" id="r_a63742e2c0e55c85b0569f6a0004e5418"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a63742e2c0e55c85b0569f6a0004e5418">ends_with_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a63742e2c0e55c85b0569f6a0004e5418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring in a case-insensitive ASCII character.  <br /></td></tr>
<tr class="separator:a63742e2c0e55c85b0569f6a0004e5418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeefcf45750a8260d5a57b3056a1521f" id="r_aaeefcf45750a8260d5a57b3056a1521f"><td class="memItemLeft" align="right" valign="top"><a id="aaeefcf45750a8260d5a57b3056a1521f" name="aaeefcf45750a8260d5a57b3056a1521f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ascii</b> () const noexcept</td></tr>
<tr class="memdesc:aaeefcf45750a8260d5a57b3056a1521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string contains only ASCII characters. <br /></td></tr>
<tr class="separator:aaeefcf45750a8260d5a57b3056a1521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517129dd2774440cd48c401b65bcf066" id="r_a517129dd2774440cd48c401b65bcf066"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a517129dd2774440cd48c401b65bcf066">upperred_only_ascii</a> () const</td></tr>
<tr class="memdesc:a517129dd2774440cd48c401b65bcf066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in uppercase ASCII characters.  <br /></td></tr>
<tr class="separator:a517129dd2774440cd48c401b65bcf066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f36df5ff2422e43919e74d965f24a4" id="r_ad2f36df5ff2422e43919e74d965f24a4"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad2f36df5ff2422e43919e74d965f24a4">lowered_only_ascii</a> () const</td></tr>
<tr class="memdesc:ad2f36df5ff2422e43919e74d965f24a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in lowercase ASCII characters.  <br /></td></tr>
<tr class="separator:ad2f36df5ff2422e43919e74d965f24a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606b0373189a0fb89bce3801e972e46a" id="r_a606b0373189a0fb89bce3801e972e46a"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a606b0373189a0fb89bce3801e972e46a">replaced</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> repl, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a606b0373189a0fb89bce3801e972e46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string with occurrences of substrings replaced.  <br /></td></tr>
<tr class="separator:a606b0373189a0fb89bce3801e972e46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bded9dcb3da163cf73d690dd63a73d4" id="r_a9bded9dcb3da163cf73d690dd63a73d4"><td class="memItemLeft" align="right" valign="top">constexpr R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9bded9dcb3da163cf73d690dd63a73d4">trimmed</a> () const</td></tr>
<tr class="memdesc:a9bded9dcb3da163cf73d690dd63a73d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the left and right.  <br /></td></tr>
<tr class="separator:a9bded9dcb3da163cf73d690dd63a73d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9958a7ba764ec2ee03fd5f205e3bcd" id="r_a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9b9958a7ba764ec2ee03fd5f205e3bcd">trimmed</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the left and right.  <br /></td></tr>
<tr class="separator:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e8b3bad27529f5033fee8985dbec7d" id="r_a16e8b3bad27529f5033fee8985dbec7d"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a16e8b3bad27529f5033fee8985dbec7d">trimmed</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a16e8b3bad27529f5033fee8985dbec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed, left and right.  <br /></td></tr>
<tr class="separator:a16e8b3bad27529f5033fee8985dbec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d2652007aef40826102fb153134c4d" id="r_a25d2652007aef40826102fb153134c4d"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a25d2652007aef40826102fb153134c4d">trimmed_left</a> () const</td></tr>
<tr class="memdesc:a25d2652007aef40826102fb153134c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the left.  <br /></td></tr>
<tr class="separator:a25d2652007aef40826102fb153134c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7910e7f7cb59cad7452f79ee8f1921a" id="r_ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab7910e7f7cb59cad7452f79ee8f1921a">trimmed_left</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the left.  <br /></td></tr>
<tr class="separator:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a1d3727d030ed34c789a1fd45a8038" id="r_a17a1d3727d030ed34c789a1fd45a8038"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a17a1d3727d030ed34c789a1fd45a8038">trimmed_left</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a17a1d3727d030ed34c789a1fd45a8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed from the left.  <br /></td></tr>
<tr class="separator:a17a1d3727d030ed34c789a1fd45a8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3af5eab221e4645e6e91b7b1a6e7d2" id="r_a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0b3af5eab221e4645e6e91b7b1a6e7d2">trimmed_right</a> () const</td></tr>
<tr class="memdesc:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the right.  <br /></td></tr>
<tr class="separator:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82f1096d596015340377b58704030cf" id="r_ac82f1096d596015340377b58704030cf"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac82f1096d596015340377b58704030cf">trimmed_right</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ac82f1096d596015340377b58704030cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the right.  <br /></td></tr>
<tr class="separator:ac82f1096d596015340377b58704030cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a49ba436dd8d11037216dc97efcd4c" id="r_aa5a49ba436dd8d11037216dc97efcd4c"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa5a49ba436dd8d11037216dc97efcd4c">trimmed_right</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:aa5a49ba436dd8d11037216dc97efcd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed to the right.  <br /></td></tr>
<tr class="separator:aa5a49ba436dd8d11037216dc97efcd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab950f20c494e2c60b22dfe95e410ec25" id="r_ab950f20c494e2c60b22dfe95e410ec25"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab950f20c494e2c60b22dfe95e410ec25">trimmed_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab950f20c494e2c60b22dfe95e410ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, left and right.  <br /></td></tr>
<tr class="separator:ab950f20c494e2c60b22dfe95e410ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2541095cb5e5a262b8e20c4dc8428b" id="r_a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6c2541095cb5e5a262b8e20c4dc8428b">trimmed_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, left and right.  <br /></td></tr>
<tr class="separator:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e7c2822c67cc2ea9a0b8c8ed9e0280" id="r_ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae0e7c2822c67cc2ea9a0b8c8ed9e0280">trimmed_left_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, left.  <br /></td></tr>
<tr class="separator:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b80529d46935202969c279de481cda" id="r_ae9b80529d46935202969c279de481cda"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae9b80529d46935202969c279de481cda">trimmed_left_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:ae9b80529d46935202969c279de481cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, left.  <br /></td></tr>
<tr class="separator:ae9b80529d46935202969c279de481cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41853e3d4d2579fe7557873592e7302" id="r_ad41853e3d4d2579fe7557873592e7302"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad41853e3d4d2579fe7557873592e7302">trimmed_right_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ad41853e3d4d2579fe7557873592e7302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, right.  <br /></td></tr>
<tr class="separator:ad41853e3d4d2579fe7557873592e7302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21bff9dca83968de291faa2b6d59fa8" id="r_ac21bff9dca83968de291faa2b6d59fa8"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac21bff9dca83968de291faa2b6d59fa8">trimmed_right_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:ac21bff9dca83968de291faa2b6d59fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, right.  <br /></td></tr>
<tr class="separator:ac21bff9dca83968de291faa2b6d59fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6c202d1c1723297d46a45d82c5808" id="r_ab3f6c202d1c1723297d46a45d82c5808"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab3f6c202d1c1723297d46a45d82c5808">splitter</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter) const</td></tr>
<tr class="memdesc:ab3f6c202d1c1723297d46a45d82c5808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <code>Splitter</code> object by the given splitter, which allows sequential get substrings using the <code>next()</code> method while <code>is_done()</code> is false.  <br /></td></tr>
<tr class="separator:ab3f6c202d1c1723297d46a45d82c5808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93a700258bc7492e53ceb2acf414315" id="r_af93a700258bc7492e53ceb2acf414315"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#af93a700258bc7492e53ceb2acf414315">operator const K *</a> () const noexcept</td></tr>
<tr class="memdesc:af93a700258bc7492e53ceb2acf414315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to a null-terminated C string.  <br /></td></tr>
<tr class="separator:af93a700258bc7492e53ceb2acf414315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed242dbe057042c9f72f9514aaf861ee" id="r_aed242dbe057042c9f72f9514aaf861ee"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#aed242dbe057042c9f72f9514aaf861ee">to_nts</a> (size_t from=0) const</td></tr>
<tr class="memdesc:aed242dbe057042c9f72f9514aaf861ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a> starting at the given character.  <br /></td></tr>
<tr class="separator:aed242dbe057042c9f72f9514aaf861ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcae77eab91707d4b3fa578dde83d34a" id="r_abcae77eab91707d4b3fa578dde83d34a"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#abcae77eab91707d4b3fa578dde83d34a">operator s_str_nt</a> () const</td></tr>
<tr class="memdesc:abcae77eab91707d4b3fa578dde83d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>.  <br /></td></tr>
<tr class="separator:abcae77eab91707d4b3fa578dde83d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476d90d2e02d4e72e99f4b4e40f3fec" id="r_ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="memItemLeft" align="right" valign="top">constexpr const K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1null__terminated.html#ac476d90d2e02d4e72e99f4b4e40f3fec">c_str</a> () const</td></tr>
<tr class="memdesc:ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a constant character buffer of a string.  <br /></td></tr>
<tr class="separator:ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7addc04fbbc6bca788260b7b8ae9de36" id="r_a7addc04fbbc6bca788260b7b8ae9de36"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a7addc04fbbc6bca788260b7b8ae9de36"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7addc04fbbc6bca788260b7b8ae9de36">printf</a> (const K *pattern, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7addc04fbbc6bca788260b7b8ae9de36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string formatted with <code>std::sprintf</code>.  <br /></td></tr>
<tr class="separator:a7addc04fbbc6bca788260b7b8ae9de36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe90e471e553d7b9e367459ce2e686ce" id="r_abe90e471e553d7b9e367459ce2e686ce"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:abe90e471e553d7b9e367459ce2e686ce"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe90e471e553d7b9e367459ce2e686ce">format</a> (const FmtString&lt; typename to_std_char_type&lt; K &gt;::type, T... &gt; &amp;fmtString, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:abe90e471e553d7b9e367459ce2e686ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string formatted with <code>std::format</code>.  <br /></td></tr>
<tr class="separator:abe90e471e553d7b9e367459ce2e686ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebd675d7e83e75c271113dd48115980" id="r_abebd675d7e83e75c271113dd48115980"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:abebd675d7e83e75c271113dd48115980"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abebd675d7e83e75c271113dd48115980">vformat</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt; fmtString, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:abebd675d7e83e75c271113dd48115980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string formatted with <code>std::vformat</code>.  <br /></td></tr>
<tr class="separator:abebd675d7e83e75c271113dd48115980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b002a3618bbfcebc945cef197a397a1" id="r_a9b002a3618bbfcebc945cef197a397a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">join</a> (const T &amp;strings, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> delimiter, bool tail=false, bool skip_empty=false, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9b002a3618bbfcebc945cef197a397a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate strings from the container into one string.  <br /></td></tr>
<tr class="separator:a9b002a3618bbfcebc945cef197a397a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb647956eba06372b0cef5328a0bc91" id="r_a6cb647956eba06372b0cef5328a0bc91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a6cb647956eba06372b0cef5328a0bc91">upperred_only_ascii_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6cb647956eba06372b0cef5328a0bc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string copy of the passed in uppercase ASCII characters.  <br /></td></tr>
<tr class="separator:a6cb647956eba06372b0cef5328a0bc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c800534b214e4473b6f59c3d761dc4" id="r_a95c800534b214e4473b6f59c3d761dc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a95c800534b214e4473b6f59c3d761dc4">lowered_only_ascii_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a95c800534b214e4473b6f59c3d761dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the passed string in lowercase ASCII characters.  <br /></td></tr>
<tr class="separator:a95c800534b214e4473b6f59c3d761dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c53f8d59e980315bc0d44b5cf6b1e6d" id="r_a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a3c53f8d59e980315bc0d44b5cf6b1e6d">upperred_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the passed string in uppercase Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7946e4e405f908fd85c896bd75f67d72" id="r_a7946e4e405f908fd85c896bd75f67d72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a7946e4e405f908fd85c896bd75f67d72">lowered_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7946e4e405f908fd85c896bd75f67d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the passed string in lowercase Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a7946e4e405f908fd85c896bd75f67d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdcc9ae62c73be2c37e4a40c3366ded" id="r_aafdcc9ae62c73be2c37e4a40c3366ded"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#aafdcc9ae62c73be2c37e4a40c3366ded">replaced_from</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aafdcc9ae62c73be2c37e4a40c3366ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the passed string with substrings replaced.  <br /></td></tr>
<tr class="separator:aafdcc9ae62c73be2c37e4a40c3366ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a458697f089f5d3f2aba985e0c707a577" id="r_a458697f089f5d3f2aba985e0c707a577"><td class="memItemLeft" align="right" valign="top"><a id="a458697f089f5d3f2aba985e0c707a577" name="a458697f089f5d3f2aba985e0c707a577"></a>
constexpr allocator_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>allocator</b> ()</td></tr>
<tr class="memdesc:a458697f089f5d3f2aba985e0c707a577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the allocator. <br /></td></tr>
<tr class="separator:a458697f089f5d3f2aba985e0c707a577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4116dbd55a53014cef88f4f571cb0c64" id="r_a4116dbd55a53014cef88f4f571cb0c64"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a4116dbd55a53014cef88f4f571cb0c64">init_from_str_other</a> (<a class="el" href="structsimstr_1_1simple__str.html">s_str</a> other)</td></tr>
<tr class="memdesc:a4116dbd55a53014cef88f4f571cb0c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization from another string object.  <br /></td></tr>
<tr class="separator:a4116dbd55a53014cef88f4f571cb0c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e0afaaca95e435c77ecc4ab3f26b8d" id="r_a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a92e0afaaca95e435c77ecc4ab3f26b8d">init_str_repeat</a> (size_t repeat, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern)</td></tr>
<tr class="memdesc:a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">String repetition initialization.  <br /></td></tr>
<tr class="separator:a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d5032575e4c90cdb9a8bcd0aa8c735" id="r_a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a47d5032575e4c90cdb9a8bcd0aa8c735">init_symb_repeat</a> (size_t count, K pad)</td></tr>
<tr class="memdesc:a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character repetition initialization.  <br /></td></tr>
<tr class="separator:a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6ca99606646e8a2fb07f5808dae999" id="r_a5d6ca99606646e8a2fb07f5808dae999"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a5d6ca99606646e8a2fb07f5808dae999">init_str_expr</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:a5d6ca99606646e8a2fb07f5808dae999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization from a string expression.  <br /></td></tr>
<tr class="separator:a5d6ca99606646e8a2fb07f5808dae999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1090a808b0e761a7ecff753d80faebba" id="r_a1090a808b0e761a7ecff753d80faebba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a1090a808b0e761a7ecff753d80faebba">init_replaced</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0)</td></tr>
<tr class="memdesc:a1090a808b0e761a7ecff753d80faebba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization from string source with replacement.  <br /></td></tr>
<tr class="separator:a1090a808b0e761a7ecff753d80faebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, Allocatorable Allocator = allocator_string&gt;<br />
class simstr::sstring&lt; K, Allocator &gt;</div><p>Immutable owning string class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- character type. </td></tr>
    <tr><td class="paramname">Allocator</td><td>- allocator type.</td></tr>
  </table>
  </dd>
</dl>
<p>"shared" string. Class with small string optimization plus a shared immutable string buffer. Since the string buffer in this class is immutable, then: Firstly, there is no need to store the size of the allocated buffer; we will not change it anyway. Secondly, another type of string appears - a string initialized with a string literal. For it, we simply save a pointer to symbols and do not count references. Thus, initializing a string object in a program with a literal does not copy anything anywhere - neither into itself nor into dynamic memory, and does not cost more than initialization a raw pointer to a string, and even more optimal, since it also immediately substitutes the size, but does not calculate it at runtime. </p><div class="fragment"><div class="line">stringa text = <span class="stringliteral">&quot;text or very very very long text&quot;</span>; <span class="comment">// costs nothing!</span></div>
<div class="line"><span class="keywordtype">string</span> copy = anotherString; <span class="comment">// All you need to do is copy the bytes of the object itself, plus possibly one atomic increment</span></div>
</div><!-- fragment --><p> In the case of a shared buffer, the size of the string is still stored not in the shared buffer, but in each object. Because of SSO, there is still enough space, and you will have to go to memory less for the length. For example, calculating the sum of the lengths of strings in a vector will only go through the memory in the vector.</p>
<p>Sizes for x64:</p><ul>
<li>for u8s - 24 bytes, stores strings up to 23 characters + 0</li>
<li>for u16s - 32 bytes, stores strings of up to 15 characters + 0</li>
<li>for u32s - 32 bytes, stores strings of up to 7 characters + 0 </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea69c6325884ae95e7d1989d5f9a0209" name="aea69c6325884ae95e7d1989d5f9a0209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea69c6325884ae95e7d1989d5f9a0209">&#9670;&#160;</a></span>sstring() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (std::is_constructible_v&lt;allocator_t, Args...&gt; &amp;&amp; sizeof...(Args) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a352a1e2de2de7c2d75a82075f9c9db3d" name="a352a1e2de2de7c2d75a82075f9c9db3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352a1e2de2de7c2d75a82075f9c9db3d">&#9670;&#160;</a></span>sstring() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor from another string object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string object, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a618a19b34ef8db3e8ac3aa903175ccd3" name="a618a19b34ef8db3e8ac3aa903175ccd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618a19b34ef8db3e8ac3aa903175ccd3">&#9670;&#160;</a></span>sstring() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>repeat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String repetition constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeat</td><td>- number of repetitions. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the line to be repeated. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ef46eb3fb57583ad6f71a3452f630ca" name="a3ef46eb3fb57583ad6f71a3452f630ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef46eb3fb57583ad6f71a3452f630ca">&#9670;&#160;</a></span>sstring() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>pad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Character repetition constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- number of repetitions. </td></tr>
    <tr><td class="paramname">pad</td><td>- the character to be repeated. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5cb8a560660d8ecbe923fe129b91085" name="ae5cb8a560660d8ecbe923fe129b91085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cb8a560660d8ecbe923fe129b91085">&#9670;&#160;</a></span>sstring() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype">const StrExprForType&lt; K &gt; auto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>The constructor queries the string expression <code><a class="el" href="#a8c22e6630eb8ec76c43da7c13f2adf83" title="Line length.">length()</a></code>, allocates memory of the required size, and calls the <code><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place()</a></code> method to allocate result in buffer. </p>

</div>
</div>
<a id="afc7bf5c4af291131936a6e22eaa831c2" name="afc7bf5c4af291131936a6e22eaa831c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7bf5c4af291131936a6e22eaa831c2">&#9670;&#160;</a></span>sstring() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;StrType&lt; K &gt; From, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from string source with replacement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- the string object from which the source string is taken. </td></tr>
    <tr><td class="paramname">pattern</td><td>- substring to be replaced. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to be replaced with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position for searching substrings. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40ab876fcbc688f999e75704f13e01be" name="a40ab876fcbc688f999e75704f13e01be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab876fcbc688f999e75704f13e01be">&#9670;&#160;</a></span>sstring() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- the string to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb8546ee3cde089fc614033c2fb3a22c" name="abb8546ee3cde089fc614033c2fb3a22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8546ee3cde089fc614033c2fb3a22c">&#9670;&#160;</a></span>sstring() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- the string to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a895058580f91a0295acda313b9e23c12" name="a895058580f91a0295acda313b9e23c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895058580f91a0295acda313b9e23c12">&#9670;&#160;</a></span>sstring() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, true, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A move constructor from lstring with an sstring-compatible external buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- the string to be moved.</td></tr>
  </table>
  </dd>
</dl>
<p>If the characters in lstring are in an external allocated buffer, we just take the pointer to the buffer, it will suit us. </p>

</div>
</div>
<a id="a873059081053f7d9c9ab251d3ed7721d" name="a873059081053f7d9c9ab251d3ed7721d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873059081053f7d9c9ab251d3ed7721d">&#9670;&#160;</a></span>sstring() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::sstring </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from a string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- string literal. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>In this case, we simply remember the pointer to the string and its length. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4213df62c3208dd26ae540122dcfa45d" name="a4213df62c3208dd26ae540122dcfa45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4213df62c3208dd26ae540122dcfa45d">&#9670;&#160;</a></span>as_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::as_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a number of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- the desired number type. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- check for overflow. </td></tr>
    <tr><td class="paramname">Base</td><td>- the base of the number, from -1 to 36, except 1.<ul>
<li>If 0: then tries to determine the base by the prefix 0[xX] as 16, 0 as 8, otherwise 10.</li>
<li>If -1: then tries to determine the base by prefixes:<ul>
<li>0 or 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
</ul>
</li>
<li>in other cases 10. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- skip whitespace characters at the beginning of the line. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- whether the '+' sign is allowed before a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - a number, the result of the transformation, how much it turned out, or 0 if it overflows. </dd></dl>

</div>
</div>
<a id="af860598fca0df848662d7d8578a8f6da" name="af860598fca0df848662d7d8578a8f6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af860598fca0df848662d7d8578a8f6da">&#9670;&#160;</a></span>as_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- the variable into which the result is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17421202713ebd4d62ddf175023f535" name="ac17421202713ebd4d62ddf175023f535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17421202713ebd4d62ddf175023f535">&#9670;&#160;</a></span>as_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to an integer. </p>
<p>Since <code>as_number(double&amp; t)</code> overrides the visibility of <code>as_number</code> from the base class, will have to add it again. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- number type, inferred from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- the variable into which the result is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c053de38bf2a0eab39cf1de5b0a21a" name="ad2c053de38bf2a0eab39cf1de5b0a21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c053de38bf2a0eab39cf1de5b0a21a">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::at </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the character at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- symbol index. For negative values, it is counted from the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>K - character.</dd></dl>
<p>Does not check for line boundaries. </p>

</div>
</div>
<a id="ac476d90d2e02d4e72e99f4b4e40f3fec" name="ac476d90d2e02d4e72e99f4b4e40f3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac476d90d2e02d4e72e99f4b4e40f3fec">&#9670;&#160;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename Impl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const K * simstr::null_terminated&lt; K, Impl &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a constant character buffer of a string. </p>
<dl class="section return"><dt>Returns</dt><dd>const K* - pointer to a constant string character buffer </dd></dl>

</div>
</div>
<a id="a108d9cd0dc24f5d395e838a3ef20d846" name="a108d9cd0dc24f5d395e838a3ef20d846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d9cd0dc24f5d395e838a3ef20d846">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a0e5e10ff025504ee5d60e8c77f439003" name="a0e5e10ff025504ee5d60e8c77f439003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5e10ff025504ee5d60e8c77f439003">&#9670;&#160;</a></span>compare_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::compare_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character and not case sensitive ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a400250ea87cc59daa152dc9ddb57491f" name="a400250ea87cc59daa152dc9ddb57491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400250ea87cc59daa152dc9ddb57491f">&#9670;&#160;</a></span>compare_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::compare_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character without taking into account the case of Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="ac4d712294186e2e181910677ba9c3ca7" name="ac4d712294186e2e181910677ba9c3ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d712294186e2e181910677ba9c3ca7">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string contains the specified substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a id="a3c2498615b426546b65e9b6c4f973264" name="a3c2498615b426546b65e9b6c4f973264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2498615b426546b65e9b6c4f973264">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string to the specified buffer. </p>
<p>The method adds <code>\0</code> after the copied characters. Does not exceed buffer boundaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to buffer </td></tr>
    <tr><td class="paramname">bufSize</td><td>- buffer size in characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15504449e8d2a8f77832046b559ae0a8" name="a15504449e8d2a8f77832046b559ae0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15504449e8d2a8f77832046b559ae0a8">&#9670;&#160;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63742e2c0e55c85b0569f6a0004e5418" name="a63742e2c0e55c85b0569f6a0004e5418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63742e2c0e55c85b0569f6a0004e5418">&#9670;&#160;</a></span>ends_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::ends_with_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring in a case-insensitive ASCII character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a535d655a6702861b788830a1d266e48f" name="a535d655a6702861b788830a1d266e48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535d655a6702861b788830a1d266e48f">&#9670;&#160;</a></span>ends_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::ends_with_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b9b0cb780c465cb9b6bd925d712ff07" name="a3b9b0cb780c465cb9b6bd925d712ff07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9b0cb780c465cb9b6bd925d712ff07">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String comparison for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="afa9fca49d189fd0d760ffe8aed1485f1" name="afa9fca49d189fd0d760ffe8aed1485f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9fca49d189fd0d760ffe8aed1485f1">&#9670;&#160;</a></span>equal_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::equal_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is equal to another string, character-by-character-insensitive, of ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="adbf0990c46a280cd363da46bef12e02f" name="adbf0990c46a280cd363da46bef12e02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf0990c46a280cd363da46bef12e02f">&#9670;&#160;</a></span>equal_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::equal_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is equal to another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a129d72cc64be6029f10bbe1f8385f3ea" name="a129d72cc64be6029f10bbe1f8385f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129d72cc64be6029f10bbe1f8385f3ea">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ab38e5cc7893a20e69cdf03d88232b49c" name="ab38e5cc7893a20e69cdf03d88232b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38e5cc7893a20e69cdf03d88232b49c">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="aa6d568443f3ed5752279098b9a488655" name="aa6d568443f3ed5752279098b9a488655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d568443f3ed5752279098b9a488655">&#9670;&#160;</a></span>find_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all occurrences of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- the maximum number of occurrences to be processed, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;size_t&gt; - a vector with the positions of the beginnings of the found occurrences. </dd></dl>

</div>
</div>
<a id="a8bcde5878d3d7fd5138d38ff2f1df4d2" name="a8bcde5878d3d7fd5138d38ff2f1df4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcde5878d3d7fd5138d38ff2f1df4d2">&#9670;&#160;</a></span>find_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="aab67ba06c8637f93984e45cf349c3eb8" name="aab67ba06c8637f93984e45cf349c3eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab67ba06c8637f93984e45cf349c3eb8">&#9670;&#160;</a></span>find_end_of_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_end_of_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the last occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the last occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ae281c63da2d81ef8aac65a2dad77eb93" name="ae281c63da2d81ef8aac65a2dad77eb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae281c63da2d81ef8aac65a2dad77eb93">&#9670;&#160;</a></span>find_end_of_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_end_of_last_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the last occurrence of a substring in this string, or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the last occurrence of the substring, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a2c56c3345019c8d5dc20717092d52101" name="a2c56c3345019c8d5dc20717092d52101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c56c3345019c8d5dc20717092d52101">&#9670;&#160;</a></span>find_end_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_end_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the first occurrence of a substring in this string, or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the occurrence of the substring, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a63ff5e918afcc8e1fba9a3ec19c47897" name="a63ff5e918afcc8e1fba9a3ec19c47897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff5e918afcc8e1fba9a3ec19c47897">&#9670;&#160;</a></span>find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character not from the given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the character set. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a643bf839edef0abbd43c3f3654e8e700" name="a643bf839edef0abbd43c3f3654e8e700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bf839edef0abbd43c3f3654e8e700">&#9670;&#160;</a></span>find_first_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="aad5ad9c702f21003a272469cb1edcbf3" name="aad5ad9c702f21003a272469cb1edcbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5ad9c702f21003a272469cb1edcbf3">&#9670;&#160;</a></span>find_first_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_first_of_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t, size_t&gt; - a pair from the position of the found occurrence and the number of the found character in the set, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a0564461ab81bfbb6c5bd8b4c7e5a496e" name="a0564461ab81bfbb6c5bd8b4c7e5a496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0564461ab81bfbb6c5bd8b4c7e5a496e">&#9670;&#160;</a></span>find_last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a72a2c0b10e857c245f67a2abd7c1a2f0" name="a72a2c0b10e857c245f67a2abd7c1a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a2c0b10e857c245f67a2abd7c1a2f0">&#9670;&#160;</a></span>find_last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the last occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a775a7c8e218ab3223f0248f225076b7c" name="a775a7c8e218ab3223f0248f225076b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775a7c8e218ab3223f0248f225076b7c">&#9670;&#160;</a></span>find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character not from the given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the character set. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a73806fa93c9ec619ba93d479d413ea0f" name="a73806fa93c9ec619ba93d479d413ea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73806fa93c9ec619ba93d479d413ea0f">&#9670;&#160;</a></span>find_last_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ab630d62252bf1210f573a8c7222942c8" name="ab630d62252bf1210f573a8c7222942c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab630d62252bf1210f573a8c7222942c8">&#9670;&#160;</a></span>find_last_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_last_of_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t, size_t&gt; - a pair from the position of the found occurrence and the number of the found character in the set, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a6a5bdd0e7ab4f7e64e1e776f4dabe11c" name="a6a5bdd0e7ab4f7e64e1e776f4dabe11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5bdd0e7ab4f7e64e1e776f4dabe11c">&#9670;&#160;</a></span>find_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_last_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the last occurrence of a substring in this string or the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position at which the substring begins, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a762c55d09b34ba2b7b5f9f10783da662" name="a762c55d09b34ba2b7b5f9f10783da662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762c55d09b34ba2b7b5f9f10783da662">&#9670;&#160;</a></span>find_or_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a character in this string or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or string length if not found. </dd></dl>

</div>
</div>
<a id="ac029fd5412ed114bfefbdddba2c50167" name="ac029fd5412ed114bfefbdddba2c50167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac029fd5412ed114bfefbdddba2c50167">&#9670;&#160;</a></span>find_or_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string or the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position at which the substring begins, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a40ab0482ea5f02bc0c3097bed6c9a5fa" name="a40ab0482ea5f02bc0c3097bed6c9a5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab0482ea5f02bc0c3097bed6c9a5fa">&#9670;&#160;</a></span>find_or_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::find_or_throw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string or throw an exception. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exc</td><td>- exception type. </td></tr>
    <tr><td class="paramname">Args...</td><td>- types of parameters for constructing an exception, inferred from the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
    <tr><td class="paramname">args</td><td>- arguments for the exception constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the substring occurrence, or throws an Exc exception if not found. </dd></dl>

</div>
</div>
<a id="a8185ccf8fc2297b628cce3c83b6a0b4c" name="a8185ccf8fc2297b628cce3c83b6a0b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8185ccf8fc2297b628cce3c83b6a0b4c">&#9670;&#160;</a></span>for_all_finded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::for_all_finded </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor on all found occurrences of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is a functor that takes a string. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- the maximum number of occurrences to be processed, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe90e471e553d7b9e367459ce2e686ce" name="abe90e471e553d7b9e367459ce2e686ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe90e471e553d7b9e367459ce2e686ce">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::format </td>
          <td>(</td>
          <td class="paramtype">const FmtString&lt; typename to_std_char_type&lt; K &gt;::type, T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fmtString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string formatted with <code>std::format</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmtString</td><td>- constant format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for <code>std::format</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type. </dd></dl>

</div>
</div>
<a id="a5659e7fb47dfb6bd6736a1b454ffde92" name="a5659e7fb47dfb6bd6736a1b454ffde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5659e7fb47dfb6bd6736a1b454ffde92">&#9670;&#160;</a></span>from_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::from_to </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the substring <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a> from position from to position to (not including it). </p>
<p>For performance reasons, the method does not check for line boundaries in any way, use in scenarios when you know for sure that these are positions inside the line and to &gt;= from. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position. </td></tr>
    <tr><td class="paramname">to</td><td>- final position (not included in the result). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a4116dbd55a53014cef88f4f571cb0c64" name="a4116dbd55a53014cef88f4f571cb0c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4116dbd55a53014cef88f4f571cb0c64">&#9670;&#160;</a></span>init_from_str_other()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::init_from_str_other </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization from another string object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string object, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1090a808b0e761a7ecff753d80faebba" name="a1090a808b0e761a7ecff753d80faebba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1090a808b0e761a7ecff753d80faebba">&#9670;&#160;</a></span>init_replaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::init_replaced </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization from string source with replacement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- the string object from which the source string is taken. </td></tr>
    <tr><td class="paramname">pattern</td><td>- substring to be replaced. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to be replaced with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position for searching substrings. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d6ca99606646e8a2fb07f5808dae999" name="a5d6ca99606646e8a2fb07f5808dae999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6ca99606646e8a2fb07f5808dae999">&#9670;&#160;</a></span>init_str_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::init_str_expr </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization from a string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- string expression.</td></tr>
  </table>
  </dd>
</dl>
<p>Queries the string expression <code><a class="el" href="#a8c22e6630eb8ec76c43da7c13f2adf83" title="Line length.">length()</a></code>, allocates memory of the required size, and calls the <code><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place()</a></code> method to allocate result in buffer. </p>

</div>
</div>
<a id="a92e0afaaca95e435c77ecc4ab3f26b8d" name="a92e0afaaca95e435c77ecc4ab3f26b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e0afaaca95e435c77ecc4ab3f26b8d">&#9670;&#160;</a></span>init_str_repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::init_str_repeat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>repeat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String repetition initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeat</td><td>- number of repetitions. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the line to be repeated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d5032575e4c90cdb9a8bcd0aa8c735" name="a47d5032575e4c90cdb9a8bcd0aa8c735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d5032575e4c90cdb9a8bcd0aa8c735">&#9670;&#160;</a></span>init_symb_repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::init_symb_repeat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>pad</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Character repetition initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- number of repetitions. </td></tr>
    <tr><td class="paramname">pad</td><td>- the character to be repeated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b002a3618bbfcebc945cef197a397a1" name="a9b002a3618bbfcebc945cef197a397a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b002a3618bbfcebc945cef197a397a1">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>strings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_empty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate strings from the container into one string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>- container with strings. </td></tr>
    <tr><td class="paramname">delimiter</td><td>- delimiter added between lines. </td></tr>
    <tr><td class="paramname">tail</td><td>- add a separator after the last line. </td></tr>
    <tr><td class="paramname">skip_empty</td><td>- skip empty lines without adding a separator. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>The function is used to merge a container of strings into one delimited string. </p><div class="fragment"><div class="line">std::vector&lt;ssa&gt; strings = get_strings();</div>
<div class="line">ssa delim = get_current_delimiter();</div>
<div class="line"><span class="keyword">auto</span> line = <a class="code hl_function" href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">lstringa&lt;200&gt;::join</a>(strings, delimiter);</div>
<div class="ttc" id="aclasssimstr_1_1str__storable_html_a9b002a3618bbfcebc945cef197a397a1"><div class="ttname"><a href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">simstr::lstring&lt; u8s, N &gt;::join</a></div><div class="ttdeci">static my_type join(const T &amp;strings, s_str delimiter, bool tail=false, bool skip_empty=false, Args &amp;&amp;... args)</div><div class="ttdef"><b>Definition</b> sstring.h:1203</div></div>
</div><!-- fragment --><p> It is worth noting that if the separator is known in advance, it is better to use the string expression <code>e_join</code>. </p><div class="fragment"><div class="line">std::vector&lt;ssa&gt; strings = get_strings();</div>
<div class="line">lstringa&lt;200&gt; line{<a class="code hl_function" href="group___str_exprs.html#gafd2e6b8a52bfe20c0b86d25f9f78cb52">e_join</a>(strings, <span class="stringliteral">&quot;/&quot;</span>)};</div>
<div class="ttc" id="agroup___str_exprs_html_gafd2e6b8a52bfe20c0b86d25f9f78cb52"><div class="ttname"><a href="group___str_exprs.html#gafd2e6b8a52bfe20c0b86d25f9f78cb52">simstr::e_join</a></div><div class="ttdeci">constexpr auto e_join(const T &amp;s, L &amp;&amp;d)</div><div class="ttdoc">Get a string expression concatenating the strings in the container into a single string with the give...</div><div class="ttdef"><b>Definition</b> strexpr.h:2035</div></div>
</div><!-- fragment --><p> In this case, the compiler can better optimize the string merging code. </p>

</div>
</div>
<a id="a44ede528e694988f26555e91cf9a1ca2" name="a44ede528e694988f26555e91cf9a1ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ede528e694988f26555e91cf9a1ca2">&#9670;&#160;</a></span>less_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::less_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is smaller than another string, character-by-character-insensitive, ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the string is smaller. </dd></dl>

</div>
</div>
<a id="a4e79e99462478b57d62873f7942ff2b6" name="a4e79e99462478b57d62873f7942ff2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79e99462478b57d62873f7942ff2b6">&#9670;&#160;</a></span>less_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::less_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is smaller than another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the string is smaller. </dd></dl>

</div>
</div>
<a id="a8d51ac2887746e40214eeee7d52460f4" name="a8d51ac2887746e40214eeee7d52460f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d51ac2887746e40214eeee7d52460f4">&#9670;&#160;</a></span>lowered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::lowered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in lowercase Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - lowercase copy of the string. </dd></dl>

</div>
</div>
<a id="a7946e4e405f908fd85c896bd75f67d72" name="a7946e4e405f908fd85c896bd75f67d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7946e4e405f908fd85c896bd75f67d72">&#9670;&#160;</a></span>lowered_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::lowered_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the passed string in lowercase Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>Case is changed by simplified tables, where one code_point is always changed to one code_point (but for UTF-8 it is possible that the length in code units will change). </p>

</div>
</div>
<a id="ad2f36df5ff2422e43919e74d965f24a4" name="ad2f36df5ff2422e43919e74d965f24a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f36df5ff2422e43919e74d965f24a4">&#9670;&#160;</a></span>lowered_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::lowered_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in lowercase ASCII characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - lowercase copy of the string. </dd></dl>

</div>
</div>
<a id="a95c800534b214e4473b6f59c3d761dc4" name="a95c800534b214e4473b6f59c3d761dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c800534b214e4473b6f59c3d761dc4">&#9670;&#160;</a></span>lowered_only_ascii_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::lowered_only_ascii_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the passed string in lowercase ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7d01e72c7352735003c55c33f33fffd" name="ac7d01e72c7352735003c55c33f33fffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d01e72c7352735003c55c33f33fffd">&#9670;&#160;</a></span>make_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::make_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the string empty. </p>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a507a43e6ebcc51e6409874712abbbd63" name="a507a43e6ebcc51e6409874712abbbd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507a43e6ebcc51e6409874712abbbd63">&#9670;&#160;</a></span>mid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string as "string chunk". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If the string size is exceeded, it will return an empty string. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". When going beyond the line, it will return everything up to the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="af93a700258bc7492e53ceb2acf414315" name="af93a700258bc7492e53ceb2acf414315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93a700258bc7492e53ceb2acf414315">&#9670;&#160;</a></span>operator const K *()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::operator const K * </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator to a null-terminated C string. </p>
<dl class="section return"><dt>Returns</dt><dd>const K* - pointer to the beginning of the line. </dd></dl>

</div>
</div>
<a id="abcae77eab91707d4b3fa578dde83d34a" name="abcae77eab91707d4b3fa578dde83d34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcae77eab91707d4b3fa578dde83d34a">&#9670;&#160;</a></span>operator s_str_nt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::operator <a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </dd></dl>

</div>
</div>
<a id="a9959513e8a072c51620248c4a29f4196" name="a9959513e8a072c51620248c4a29f4196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9959513e8a072c51620248c4a29f4196">&#9670;&#160;</a></span>operator std::basic_string&lt; D, Traits, Allocator &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::operator std::basic_string&lt; D, Traits, Allocator &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::basic_string. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="ab4c6b4c365f05e609a7b22cbf37b39c6" name="ab4c6b4c365f05e609a7b22cbf37b39c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c6b4c365f05e609a7b22cbf37b39c6">&#9670;&#160;</a></span>operator std::basic_string_view&lt; D, Traits &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::operator std::basic_string_view&lt; D, Traits &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::basic_string_view. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a916218a7a75a3866a9d3d0da9334653c" name="a916218a7a75a3866a9d3d0da9334653c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916218a7a75a3866a9d3d0da9334653c">&#9670;&#160;</a></span>operator str_piece()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::operator <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert itself to a "string chunk" that includes the entire string. </p>
<dl class="section return"><dt>Returns</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="ace8f275b33545d2491850f49ba3b7876" name="ace8f275b33545d2491850f49ba3b7876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8f275b33545d2491850f49ba3b7876">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string as "str_src". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>.</dd></dl>
<p>If <code>from</code> is less than zero, then <code>-from</code> characters are counted from the end of the line towards the beginning. If <code>len</code> is less than or equal to zero, then count <code>-len</code> characters from the end of the line</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, 2) == <span class="stringliteral">&quot;56&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5) == <span class="stringliteral">&quot;56789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, -1) == <span class="stringliteral">&quot;5678&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3) == <span class="stringliteral">&quot;789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3, 2) == <span class="stringliteral">&quot;78&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-4, -1) == <span class="stringliteral">&quot;678&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac34637c1f071ac6e6faa0237a092cc61" name="ac34637c1f071ac6e6faa0237a092cc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34637c1f071ac6e6faa0237a092cc61">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad63f315c4a97ee6ad1e2b045b9f5f9e0" name="ad63f315c4a97ee6ad1e2b045b9f5f9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63f315c4a97ee6ad1e2b045b9f5f9e0">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator between a string and a string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is a string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28ef58e8b8305988a9ca634460109204" name="a28ef58e8b8305988a9ca634460109204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ef58e8b8305988a9ca634460109204">&#9670;&#160;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;size_t N, bool forShared, typename A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, forShared, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator to another string of type lstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="ace848e3ccdf857a365ad5e395f7f6528" name="ace848e3ccdf857a365ad5e395f7f6528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace848e3ccdf857a365ad5e395f7f6528">&#9670;&#160;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const StrExprForType&lt; K &gt; auto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String expression assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- string expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself.</dd></dl>
<p>In a string expression, it is possible to refer to parts of the same string, since a copy is created first. </p>

</div>
</div>
<a id="ae39824f566fd5a9373af91c4e24d8897" name="ae39824f566fd5a9373af91c4e24d8897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39824f566fd5a9373af91c4e24d8897">&#9670;&#160;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, true, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator to a movable string of type lstring with a compatible buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a760b4c4809190881aab635d1688999dc" name="a760b4c4809190881aab635d1688999dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760b4c4809190881aab635d1688999dc">&#9670;&#160;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimstr_1_1sstring.html">my_type</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator to another string of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="ac2c99f7d4fbb03a5238e2bc9d750591f" name="ac2c99f7d4fbb03a5238e2bc9d750591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c99f7d4fbb03a5238e2bc9d750591f">&#9670;&#160;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator to another string of a different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a5f08dbc02e99f3cfff5011afeb389f61" name="a5f08dbc02e99f3cfff5011afeb389f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f08dbc02e99f3cfff5011afeb389f61">&#9670;&#160;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String literal assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- string character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp; - a reference to yourself. </dd></dl>

</div>
</div>
<a id="a1ddd0a1f9b25247465fb55c79b58826d" name="a1ddd0a1f9b25247465fb55c79b58826d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddd0a1f9b25247465fb55c79b58826d">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator comparing strings for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="ac19dc728f9d7edafbd85a52e70b46376" name="ac19dc728f9d7edafbd85a52e70b46376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19dc728f9d7edafbd85a52e70b46376">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for comparing a string and a string literal for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af893677739e0d24418f6acc0a29090cc" name="af893677739e0d24418f6acc0a29090cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af893677739e0d24418f6acc0a29090cc">&#9670;&#160;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::place </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string to the specified buffer. </p>
<p>The method assumes that the size of the allocated buffer is sufficient for the entire line, i.e. <code><a class="el" href="#a8c22e6630eb8ec76c43da7c13f2adf83" title="Line length.">length()</a></code> was previously requested. Does not add <code>\0</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the character after the end of the symbols placed in the buffer. </dd></dl>

</div>
</div>
<a id="ae37c68155961c5c7b1609aa1b873b8d3" name="ae37c68155961c5c7b1609aa1b873b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37c68155961c5c7b1609aa1b873b8d3">&#9670;&#160;</a></span>prefix_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::prefix_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this string is the beginning of another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7addc04fbbc6bca788260b7b8ae9de36" name="a7addc04fbbc6bca788260b7b8ae9de36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7addc04fbbc6bca788260b7b8ae9de36">&#9670;&#160;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::printf </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string formatted with <code>std::sprintf</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for <code>sprintf</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type.</dd></dl>
<p>On Windows, posix positional arguments are supported, using <code>_sprintf_p</code>. </p>

</div>
</div>
<a id="a606b0373189a0fb89bce3801e972e46a" name="a606b0373189a0fb89bce3801e972e46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606b0373189a0fb89bce3801e972e46a">&#9670;&#160;</a></span>replaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::replaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string with occurrences of substrings replaced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to replace with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position of the search. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R a string of the given type, by default the same whose method was called. </dd></dl>

</div>
</div>
<a id="aafdcc9ae62c73be2c37e4a40c3366ded" name="aafdcc9ae62c73be2c37e4a40c3366ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdcc9ae62c73be2c37e4a40c3366ded">&#9670;&#160;</a></span>replaced_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::replaced_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the passed string with substrings replaced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">pattern</td><td>- substring to be replaced. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to be replaced with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position for searching substrings. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2732ccf421fcd1ba606addcca7e6e42" name="aa2732ccf421fcd1ba606addcca7e6e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2732ccf421fcd1ba606addcca7e6e42">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the string in characters. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="a4ad7e9416ed3abc8689034463f497e6b" name="a4ad7e9416ed3abc8689034463f497e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad7e9416ed3abc8689034463f497e6b">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into substrings using a given delimiter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- container type for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- delimiter. </td></tr>
    <tr><td class="paramname">offset</td><td>- the position to start searching for the separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - container with the result. </dd></dl>

</div>
</div>
<a id="adffb295777b82a1475a4fc0d9754481b" name="adffb295777b82a1475a4fc0d9754481b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffb295777b82a1475a4fc0d9754481b">&#9670;&#160;</a></span>splitf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::splitf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>beforeFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into parts at a given delimiter, possibly applying a functor to each substring. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of container for folding substrings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- substring delimiter. </td></tr>
    <tr><td class="paramname">beforeFunc</td><td>- a functor to apply to the found substrings, before placing them in the result. </td></tr>
    <tr><td class="paramname">offset</td><td>- the position to start searching for the separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - result.</dd></dl>
<p>For each substring found, if the functor can accept it, the functor is called, and the substring is assigned to the result of the functor. Next, the substring tries to be added to the result, calling one of its methods - <code>emplace_back</code>, <code>push_back</code>, <code>operator[]</code>. If none of this method no, nothing is done, just calling the functor. <code>operator[]</code> tries to apply if the result can have a size via <code>std::size</code> and we do not exceed this size. At the same time, if the found substring turns out to match the entire string, the result is attempted place not a substring, but the entire string object, which allows, for example, to effectively copy sstring. </p>

</div>
</div>
<a id="ab3f6c202d1c1723297d46a45d82c5808" name="ab3f6c202d1c1723297d46a45d82c5808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6c202d1c1723297d46a45d82c5808">&#9670;&#160;</a></span>splitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::splitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <code>Splitter</code> object by the given splitter, which allows sequential get substrings using the <code>next()</code> method while <code>is_done()</code> is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Splitter&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a2febfef44dabdf863a74db2049410e9f" name="a2febfef44dabdf863a74db2049410e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2febfef44dabdf863a74db2049410e9f">&#9670;&#160;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string begins with the given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9409e48b2f182546b7f7186af2477e" name="a6d9409e48b2f182546b7f7186af2477e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9409e48b2f182546b7f7186af2477e">&#9670;&#160;</a></span>starts_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::starts_with_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string begins with the given substring in a case-insensitive ASCII character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26465c7fdac87e8d215e836bdbf6e8c3" name="a26465c7fdac87e8d215e836bdbf6e8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26465c7fdac87e8d215e836bdbf6e8c3">&#9670;&#160;</a></span>starts_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::starts_with_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string starts with the given substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa77c31da012cf5cc23e0a60c1888cec2" name="aa77c31da012cf5cc23e0a60c1888cec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77c31da012cf5cc23e0a60c1888cec2">&#9670;&#160;</a></span>str_mid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::str_mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string with an object of the same type to which the method is applied, similar to mid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If the string size is exceeded, it will return an empty string. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". When going beyond the line, it will return everything up to the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the same type to which the method is applied. </dd></dl>

</div>
</div>
<a id="a610d501d16ab38c3efb1427f14ea7f67" name="a610d501d16ab38c3efb1427f14ea7f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d501d16ab38c3efb1427f14ea7f67">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::strcmp </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare with C-string character by character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a512eaf3c2c8736f3021a5bbe60823866" name="a512eaf3c2c8736f3021a5bbe60823866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512eaf3c2c8736f3021a5bbe60823866">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a substring. Works similarly to operator(), only the result is the same type as the method applied to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If less than zero, it is counted from the end of the line towards the beginning. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". If less than or equal to zero, then count len characters from the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type - a substring, an object of the same type to which the method is applied. </dd></dl>

</div>
</div>
<a id="aa1af52e61e73c687a34ff6978304edc3" name="aa1af52e61e73c687a34ff6978304edc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af52e61e73c687a34ff6978304edc3">&#9670;&#160;</a></span>to_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::to_double </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="a037d07ad0ee024d983927cec3ee81908" name="a037d07ad0ee024d983927cec3ee81908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037d07ad0ee024d983927cec3ee81908">&#9670;&#160;</a></span>to_double_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::to_double_hex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string in hex form to double. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="afa40ca4ad70df9ec0941599b88c443dc" name="afa40ca4ad70df9ec0941599b88c443dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa40ca4ad70df9ec0941599b88c443dc">&#9670;&#160;</a></span>to_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">convert_result&lt; T &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::to_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a number of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- the desired number type. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- check for overflow. </td></tr>
    <tr><td class="paramname">Base</td><td>- the base of the number, from -1 to 36, except 1.<ul>
<li>If 0: then tries to determine the base by the prefix 0[xX] as 16, 0 as 8, otherwise 10</li>
<li>If -1: then tries to determine the base by prefixes:<ul>
<li>0 or 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
</ul>
</li>
<li>in other cases 10. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- skip whitespace characters at the beginning of the line. All characters with ASCII codes &lt;= 32 are skipped. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- whether the '+' sign is allowed before a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>convert_result&lt;T&gt; - a tuple of the received number, the success of the conversion and the number of characters processed. </dd></dl>

</div>
</div>
<a id="aed242dbe057042c9f72f9514aaf861ee" name="aed242dbe057042c9f72f9514aaf861ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed242dbe057042c9f72f9514aaf861ee">&#9670;&#160;</a></span>to_nts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::to_nts </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a> starting at the given character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- position of the starting character, default 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>, </dd></dl>

</div>
</div>
<a id="a53d19b3fba03bfd481d2a3b3def766af" name="a53d19b3fba03bfd481d2a3b3def766af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d19b3fba03bfd481d2a3b3def766af">&#9670;&#160;</a></span>to_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::to_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert itself to a "string chunk" that includes the entire string. </p>
<dl class="section return"><dt>Returns</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="adc816f095922a510dfe466db1905fc63" name="adc816f095922a510dfe466db1905fc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc816f095922a510dfe466db1905fc63">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; D, Traits, Allocator &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::basic_string. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a1f2af1ee80a32a77ad30cffbf6987107" name="a1f2af1ee80a32a77ad30cffbf6987107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2af1ee80a32a77ad30cffbf6987107">&#9670;&#160;</a></span>to_sv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string_view&lt; D &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::to_sv </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::basic_string_view. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a9bded9dcb3da163cf73d690dd63a73d4" name="a9bded9dcb3da163cf73d690dd63a73d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bded9dcb3da163cf73d690dd63a73d4">&#9670;&#160;</a></span>trimmed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with whitespace characters removed at the beginning and end. </dd></dl>

</div>
</div>
<a id="a16e8b3bad27529f5033fee8985dbec7d" name="a16e8b3bad27529f5033fee8985dbec7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e8b3bad27529f5033fee8985dbec7d">&#9670;&#160;</a></span>trimmed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and at the end. </dd></dl>

</div>
</div>
<a id="a9b9958a7ba764ec2ee03fd5f205e3bcd" name="a9b9958a7ba764ec2ee03fd5f205e3bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9958a7ba764ec2ee03fd5f205e3bcd">&#9670;&#160;</a></span>trimmed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and at the end. </dd></dl>

</div>
</div>
<a id="a25d2652007aef40826102fb153134c4d" name="a25d2652007aef40826102fb153134c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d2652007aef40826102fb153134c4d">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with leading whitespace characters removed. </dd></dl>

</div>
</div>
<a id="a17a1d3727d030ed34c789a1fd45a8038" name="a17a1d3727d030ed34c789a1fd45a8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a1d3727d030ed34c789a1fd45a8038">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed from the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning. </dd></dl>

</div>
</div>
<a id="ab7910e7f7cb59cad7452f79ee8f1921a" name="ab7910e7f7cb59cad7452f79ee8f1921a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7910e7f7cb59cad7452f79ee8f1921a">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning. </dd></dl>

</div>
</div>
<a id="ae9b80529d46935202969c279de481cda" name="ae9b80529d46935202969c279de481cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b80529d46935202969c279de481cda">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and whitespace characters. </dd></dl>

</div>
</div>
<a id="ae0e7c2822c67cc2ea9a0b8c8ed9e0280" name="ae0e7c2822c67cc2ea9a0b8c8ed9e0280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e7c2822c67cc2ea9a0b8c8ed9e0280">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and whitespace characters. </dd></dl>

</div>
</div>
<a id="a0b3af5eab221e4645e6e91b7b1a6e7d2" name="a0b3af5eab221e4645e6e91b7b1a6e7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3af5eab221e4645e6e91b7b1a6e7d2">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with whitespace characters removed at the end. </dd></dl>

</div>
</div>
<a id="aa5a49ba436dd8d11037216dc97efcd4c" name="aa5a49ba436dd8d11037216dc97efcd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a49ba436dd8d11037216dc97efcd4c">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed to the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the pattern removed at the end. </dd></dl>

</div>
</div>
<a id="ac82f1096d596015340377b58704030cf" name="ac82f1096d596015340377b58704030cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82f1096d596015340377b58704030cf">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the literal removed at the end. </dd></dl>

</div>
</div>
<a id="ac21bff9dca83968de291faa2b6d59fa8" name="ac21bff9dca83968de291faa2b6d59fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21bff9dca83968de291faa2b6d59fa8">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the template removed at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="ad41853e3d4d2579fe7557873592e7302" name="ad41853e3d4d2579fe7557873592e7302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41853e3d4d2579fe7557873592e7302">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the literal removed at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a6c2541095cb5e5a262b8e20c4dc8428b" name="a6c2541095cb5e5a262b8e20c4dc8428b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2541095cb5e5a262b8e20c4dc8428b">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="ab950f20c494e2c60b22dfe95e410ec25" name="ab950f20c494e2c60b22dfe95e410ec25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab950f20c494e2c60b22dfe95e410ec25">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a6ae3ef69a372dab777c952f22c492689" name="a6ae3ef69a372dab777c952f22c492689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3ef69a372dab777c952f22c492689">&#9670;&#160;</a></span>upperred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::upperred </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in upper case Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - uppercase copy of the string. </dd></dl>

</div>
</div>
<a id="a3c53f8d59e980315bc0d44b5cf6b1e6d" name="a3c53f8d59e980315bc0d44b5cf6b1e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c53f8d59e980315bc0d44b5cf6b1e6d">&#9670;&#160;</a></span>upperred_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::upperred_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the passed string in uppercase Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>Case is changed by simplified tables, where one code_point is always changed to one code_point (but for UTF-8 it is possible that the length in code units will change). </p>

</div>
</div>
<a id="a517129dd2774440cd48c401b65bcf066" name="a517129dd2774440cd48c401b65bcf066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517129dd2774440cd48c401b65bcf066">&#9670;&#160;</a></span>upperred_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, Mutable &gt;::upperred_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in uppercase ASCII characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - uppercase copy of the string. </dd></dl>

</div>
</div>
<a id="a6cb647956eba06372b0cef5328a0bc91" name="a6cb647956eba06372b0cef5328a0bc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb647956eba06372b0cef5328a0bc91">&#9670;&#160;</a></span>upperred_only_ascii_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; K, allocator_string &gt;, allocator_string &gt;::upperred_only_ascii_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a string copy of the passed in uppercase ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- source string. </td></tr>
    <tr><td class="paramname">...args</td><td>- parameters for initializing the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abebd675d7e83e75c271113dd48115980" name="abebd675d7e83e75c271113dd48115980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebd675d7e83e75c271113dd48115980">&#9670;&#160;</a></span>vformat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1sstring.html">my_type</a> <a class="el" href="classsimstr_1_1sstring.html">simstr::sstring</a>&lt; K, Allocator &gt;::vformat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>fmtString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string formatted with <code>std::vformat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmtString</td><td>- format string. </td></tr>
    <tr><td class="paramname">...args</td><td>- arguments for <code>std::vformat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="sstring_8h_source.html">sstring.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimstr.html">simstr</a></li><li class="navelem"><a class="el" href="classsimstr_1_1sstring.html">sstring</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

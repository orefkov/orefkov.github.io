<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: simstr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.6.4</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacesimstr.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">simstr Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Library namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesimstr_1_1str.html">str</a></td></tr>
<tr class="memdesc:namespacesimstr_1_1str"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small namespace for standard string methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1chunked__string__builder.html">chunked_string_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For constructing long dynamic strings by concatenating small pieces.  <a href="classsimstr_1_1chunked__string__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1convert__to__strexpr_3_01_k_00_01const_01_t_01_5_01_4.html">convert_to_strexpr&lt; K, const T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization for converting pointers to string expressions, allowing their use in concatenation operations with string expressions.  <a href="structsimstr_1_1convert__to__strexpr_3_01_k_00_01const_01_t_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1convert__to__strexpr_3_01_k_00_01expr__hex__src_3_01_val_00_01_all_00_01_ucase_00_01_ox_01_4_01_4.html">convert_to_strexpr&lt; K, expr_hex_src&lt; Val, All, Ucase, Ox &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization for converting e_hex to string expressions, allowing their use in concatenation operations with string expressions.  <a href="structsimstr_1_1convert__to__strexpr_3_01_k_00_01expr__hex__src_3_01_val_00_01_all_00_01_ucase_00_01_ox_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1convert__to__strexpr_3_01_k_00_01_t_01_4.html">convert_to_strexpr&lt; K, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization for converting standard strings to string expressions, allowing their use in concatenation operations with string expressions.  <a href="structsimstr_1_1convert__to__strexpr_3_01_k_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1e__concat.html">e_concat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String expression concatenating the specified string expressions using the specified delimiter.  <a href="structsimstr_1_1e__concat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1e__subst.html">e_subst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String expression that substitutes the values ​​of the passed string expressions into the specified places in a string literal.  <a href="structsimstr_1_1e__subst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1e__vsubst.html">e_vsubst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String expression that substitutes the values ​​of the passed string expressions into the specified positions in the pattern string, specified at runtime.  <a href="structsimstr_1_1e__vsubst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An "empty" string expression.  <a href="structsimstr_1_1empty__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice.html">expr_choice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice__one__lit.html">expr_choice_one_lit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice__one__lit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice__two__lit.html">expr_choice_two_lit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice__two__lit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__if.html">expr_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__pad.html">expr_pad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of string expression that returns N specified characters.  <a href="structsimstr_1_1expr__pad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__replace__symbols.html">expr_replace_symbols</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for a string expression that generates a string in which the given characters are replaced by the given strings.  <a href="structsimstr_1_1expr__replace__symbols.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__replaced.html">expr_replaced</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string expression that generates a string replacing all occurrences of the given substring to another string.  <a href="structsimstr_1_1expr__replaced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__replaced__e.html">expr_replaced_e</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string expression that generates a string replacing all occurrences of the given substring to string expression.  <a href="structsimstr_1_1expr__replaced__e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of string expression that returns N specified characters.  <a href="structsimstr_1_1expr__spaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for using std::basic_string and std::basic_string_view as sources in string expressions.  <a href="structsimstr_1_1expr__stdstr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__to__std__string.html">expr_to_std_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for converting string expressions to standard strings.  <a href="structsimstr_1_1expr__to__std__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__utf.html">expr_utf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String expression to convert strings to different UTF types.  <a href="structsimstr_1_1expr__utf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1from__utf__convertible.html">from_utf_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for strings that can be converted from another character type.  <a href="classsimstr_1_1from__utf__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for more efficient searching by string keys.  <a href="classsimstr_1_1hash_str_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1lstring.html">lstring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mutable, owning string class. Contains an internal buffer for text of a given size.  <a href="classsimstr_1_1lstring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest immutable non-owning string class.  <a href="structsimstr_1_1simple__str.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that claims to refer to a null-terminated string.  <a href="structsimstr_1_1simple__str__nt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for sequentially obtaining substrings by a given delimiter.  <a href="classsimstr_1_1_splitter_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1sstring.html">sstring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable owning string class.  <a href="classsimstr_1_1sstring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html">str_algs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class with additional constant string algorithms.  <a href="classsimstr_1_1str__algs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html">str_mutable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for working with mutable strings.  <a href="classsimstr_1_1str__mutable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1str__src.html">str_src</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest class of an immutable non-owning string.  <a href="structsimstr_1_1str__src.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html">str_src_algs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class with basic constant string algorithms.  <a href="classsimstr_1_1str__src__algs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that claims to refer to a null-terminated string.  <a href="structsimstr_1_1str__src__nt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html">str_storable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base for the objects that own the string.  <a href="classsimstr_1_1str__storable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1strexprjoin.html">strexprjoin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for concatenating two string expressions into one using <code>operator +</code>  <a href="structsimstr_1_1strexprjoin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation of a reference to a string expression and the value of the string expression.  <a href="structsimstr_1_1strexprjoin__c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1storable__str.html">storable_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type concept that can store a string. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1mutable__str.html">mutable_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type concept that can modify a stored string. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1immutable__str.html">immutable_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type concept that cannot modify a stored string. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1_allocatorable.html">Allocatorable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept of a memory management type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1is__equal__str__type__v.html">is_equal_str_type_v</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two types are compatible string types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1_str_type.html">StrType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base concept of string object. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1_str_expr.html">StrExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept of "String Expressions". <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1_str_expr_for_type.html">StrExprForType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept of a string expression compatible with a given character type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a71efaa1a1996bef96e81b7b088589e1a" id="r_a71efaa1a1996bef96e81b7b088589e1a"><td class="memTemplParams" colspan="2"><a id="a71efaa1a1996bef96e81b7b088589e1a" name="a71efaa1a1996bef96e81b7b088589e1a"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a71efaa1a1996bef96e81b7b088589e1a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapA</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u8s, T, strhash&lt;u8s&gt;, streql&lt;u8s&gt;&gt;</td></tr>
<tr class="memdesc:a71efaa1a1996bef96e81b7b088589e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash dictionary for char strings, case sensitive search. <br /></td></tr>
<tr class="separator:a71efaa1a1996bef96e81b7b088589e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1790ec609099f364a6956dfa22333aa5" id="r_a1790ec609099f364a6956dfa22333aa5"><td class="memTemplParams" colspan="2"><a id="a1790ec609099f364a6956dfa22333aa5" name="a1790ec609099f364a6956dfa22333aa5"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1790ec609099f364a6956dfa22333aa5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapAIA</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u8s, T, strhashia&lt;u8s&gt;, streqlia&lt;u8s&gt;&gt;</td></tr>
<tr class="memdesc:a1790ec609099f364a6956dfa22333aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash dictionary for char strings, case-insensitive lookup for ASCII characters. <br /></td></tr>
<tr class="separator:a1790ec609099f364a6956dfa22333aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78f2af21d02b2a7fbe3a5111d5e5d3e" id="r_ac78f2af21d02b2a7fbe3a5111d5e5d3e"><td class="memTemplParams" colspan="2"><a id="ac78f2af21d02b2a7fbe3a5111d5e5d3e" name="ac78f2af21d02b2a7fbe3a5111d5e5d3e"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac78f2af21d02b2a7fbe3a5111d5e5d3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapAIU</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u8s, T, strhashiu&lt;u8s&gt;, streqliu&lt;u8s&gt;&gt;</td></tr>
<tr class="memdesc:ac78f2af21d02b2a7fbe3a5111d5e5d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for char strings, case-insensitive search for Unicode characters up to 0xFFFF. <br /></td></tr>
<tr class="separator:ac78f2af21d02b2a7fbe3a5111d5e5d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30b610e5d5dcce51beab757a6c408b9" id="r_aa30b610e5d5dcce51beab757a6c408b9"><td class="memTemplParams" colspan="2"><a id="aa30b610e5d5dcce51beab757a6c408b9" name="aa30b610e5d5dcce51beab757a6c408b9"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa30b610e5d5dcce51beab757a6c408b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapW</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;wchar_t, T, strhash&lt;wchar_t&gt;, streql&lt;wchar_t&gt;&gt;</td></tr>
<tr class="memdesc:aa30b610e5d5dcce51beab757a6c408b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for wchar_t strings, case sensitive search. <br /></td></tr>
<tr class="separator:aa30b610e5d5dcce51beab757a6c408b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617db678b8f77967dc114be7706582a5" id="r_a617db678b8f77967dc114be7706582a5"><td class="memTemplParams" colspan="2"><a id="a617db678b8f77967dc114be7706582a5" name="a617db678b8f77967dc114be7706582a5"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a617db678b8f77967dc114be7706582a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapWIA</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;wchar_t, T, strhashia&lt;wchar_t&gt;, streqlia&lt;wchar_t&gt;&gt;</td></tr>
<tr class="memdesc:a617db678b8f77967dc114be7706582a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for wchar_t strings, case-insensitive lookup for ASCII characters. <br /></td></tr>
<tr class="separator:a617db678b8f77967dc114be7706582a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376c405d7404546a07f440f355038de5" id="r_a376c405d7404546a07f440f355038de5"><td class="memTemplParams" colspan="2"><a id="a376c405d7404546a07f440f355038de5" name="a376c405d7404546a07f440f355038de5"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a376c405d7404546a07f440f355038de5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapWIU</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;wchar_t, T, strhashiu&lt;wchar_t&gt;, streqliu&lt;wchar_t&gt;&gt;</td></tr>
<tr class="memdesc:a376c405d7404546a07f440f355038de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for wchar_t strings, case insensitive search for Unicode characters up to 0xFFFF. <br /></td></tr>
<tr class="separator:a376c405d7404546a07f440f355038de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030877384507e9a42a658adcba5876ff" id="r_a030877384507e9a42a658adcba5876ff"><td class="memTemplParams" colspan="2"><a id="a030877384507e9a42a658adcba5876ff" name="a030877384507e9a42a658adcba5876ff"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a030877384507e9a42a658adcba5876ff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapU</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u16s, T, strhash&lt;u16s&gt;, streql&lt;u16s&gt;&gt;</td></tr>
<tr class="memdesc:a030877384507e9a42a658adcba5876ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for char16_t strings, case sensitive search. <br /></td></tr>
<tr class="separator:a030877384507e9a42a658adcba5876ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e4388c264efd467d0b166e2665e54" id="r_a9e4e4388c264efd467d0b166e2665e54"><td class="memTemplParams" colspan="2"><a id="a9e4e4388c264efd467d0b166e2665e54" name="a9e4e4388c264efd467d0b166e2665e54"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a9e4e4388c264efd467d0b166e2665e54"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapUIA</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u16s, T, strhashia&lt;u16s&gt;, streqlia&lt;u16s&gt;&gt;</td></tr>
<tr class="memdesc:a9e4e4388c264efd467d0b166e2665e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for char16_t strings, case-insensitive lookup for ASCII characters. <br /></td></tr>
<tr class="separator:a9e4e4388c264efd467d0b166e2665e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaf34e22c3875c278584649bac17a1d" id="r_a9aaf34e22c3875c278584649bac17a1d"><td class="memTemplParams" colspan="2"><a id="a9aaf34e22c3875c278584649bac17a1d" name="a9aaf34e22c3875c278584649bac17a1d"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a9aaf34e22c3875c278584649bac17a1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapUIU</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u16s, T, strhashiu&lt;u16s&gt;, streqliu&lt;u16s&gt;&gt;</td></tr>
<tr class="memdesc:a9aaf34e22c3875c278584649bac17a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for char16_t strings, case insensitive search for Unicode characters up to 0xFFFF. <br /></td></tr>
<tr class="separator:a9aaf34e22c3875c278584649bac17a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af867baf0fff130ca193369781ccd7c02" id="r_af867baf0fff130ca193369781ccd7c02"><td class="memTemplParams" colspan="2"><a id="af867baf0fff130ca193369781ccd7c02" name="af867baf0fff130ca193369781ccd7c02"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:af867baf0fff130ca193369781ccd7c02"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapUU</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u32s, T, strhash&lt;u32s&gt;, streql&lt;u32s&gt;&gt;</td></tr>
<tr class="memdesc:af867baf0fff130ca193369781ccd7c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for char32_t strings, case sensitive search. <br /></td></tr>
<tr class="separator:af867baf0fff130ca193369781ccd7c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c04ab386fa351971da18cf50a7d1c0c" id="r_a2c04ab386fa351971da18cf50a7d1c0c"><td class="memTemplParams" colspan="2"><a id="a2c04ab386fa351971da18cf50a7d1c0c" name="a2c04ab386fa351971da18cf50a7d1c0c"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2c04ab386fa351971da18cf50a7d1c0c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapUUIA</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u32s, T, strhashia&lt;u32s&gt;, streqlia&lt;u32s&gt;&gt;</td></tr>
<tr class="memdesc:a2c04ab386fa351971da18cf50a7d1c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for char32_t strings, case-insensitive lookup for ASCII characters. <br /></td></tr>
<tr class="separator:a2c04ab386fa351971da18cf50a7d1c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aa45c8506e69c74ce109617d892e69" id="r_a23aa45c8506e69c74ce109617d892e69"><td class="memTemplParams" colspan="2"><a id="a23aa45c8506e69c74ce109617d892e69" name="a23aa45c8506e69c74ce109617d892e69"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a23aa45c8506e69c74ce109617d892e69"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hashStrMapUUIU</b> = <a class="el" href="classsimstr_1_1hash_str_map.html">hashStrMap</a>&lt;u32s, T, strhashiu&lt;u32s&gt;, streqliu&lt;u32s&gt;&gt;</td></tr>
<tr class="memdesc:a23aa45c8506e69c74ce109617d892e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash dictionary type for char32_t strings, case insensitive search for Unicode characters up to 0xFFFF. <br /></td></tr>
<tr class="separator:a23aa45c8506e69c74ce109617d892e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga680097382d9bc271c361f85828ac741f" id="r_ga680097382d9bc271c361f85828ac741f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga680097382d9bc271c361f85828ac741f">HexFlags</a> : unsigned { <a class="el" href="group___str_exprs.html#gga680097382d9bc271c361f85828ac741fad4ddbe11a4c8e3daca5795ad268df0c4">Short</a> = 1
, <b>No0x</b> = 2
, <b>Lcase</b> = 4
 }</td></tr>
<tr class="memdesc:ga680097382d9bc271c361f85828ac741f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for the e_hex function.  <a href="group___str_exprs.html#ga680097382d9bc271c361f85828ac741f">More...</a><br /></td></tr>
<tr class="separator:ga680097382d9bc271c361f85828ac741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4b1f04b733739606d97f79caa02dd9" id="r_a1b4b1f04b733739606d97f79caa02dd9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b4b1f04b733739606d97f79caa02dd9">IntConvertResult</a> : char { <a class="el" href="#a1b4b1f04b733739606d97f79caa02dd9a505a83f220c02df2f85c3810cd9ceb38">Success</a>
, <a class="el" href="#a1b4b1f04b733739606d97f79caa02dd9aeaa263ad0ebb3a51a496116be8b354b2">BadSymbolAtTail</a>
, <a class="el" href="#a1b4b1f04b733739606d97f79caa02dd9a129e8109f319870e328cc7a1d5b5cae3">Overflow</a>
, <a class="el" href="#a1b4b1f04b733739606d97f79caa02dd9ac15b8c76611746ee6c491a03f31855df">NotNumber</a>
 }</td></tr>
<tr class="memdesc:a1b4b1f04b733739606d97f79caa02dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration with possible results of converting a string to an integer.  <a href="#a1b4b1f04b733739606d97f79caa02dd9">More...</a><br /></td></tr>
<tr class="separator:a1b4b1f04b733739606d97f79caa02dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68179a3d25c85c1bab488b570df3b1f2" id="r_a68179a3d25c85c1bab488b570df3b1f2"><td class="memTemplParams" colspan="2">template&lt;typename To, typename From&gt; <br />
requires (!std::is_same_v&lt;From, To&gt;)</td></tr>
<tr class="memitem:a68179a3d25c85c1bab488b570df3b1f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsimstr_1_1expr__utf.html">expr_utf</a>&lt; From, To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68179a3d25c85c1bab488b570df3b1f2">e_utf</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; From &gt; from)</td></tr>
<tr class="memdesc:a68179a3d25c85c1bab488b570df3b1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string expression that converts a string of one character type to another type, via UTF conversion.  <br /></td></tr>
<tr class="separator:a68179a3d25c85c1bab488b570df3b1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5742ba39f28a4548415df9fb55bc2458" id="r_a5742ba39f28a4548415df9fb55bc2458"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5742ba39f28a4548415df9fb55bc2458">operator&quot;&quot;_ss</a> (const u8s *ptr, size_t l)</td></tr>
<tr class="memdesc:a5742ba39f28a4548415df9fb55bc2458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>.  <br /></td></tr>
<tr class="separator:a5742ba39f28a4548415df9fb55bc2458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef2c1311000244db8b0089eb74f3797" id="r_a9ef2c1311000244db8b0089eb74f3797"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; ubs &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ef2c1311000244db8b0089eb74f3797">operator&quot;&quot;_ss</a> (const ubs *ptr, size_t l)</td></tr>
<tr class="memdesc:a9ef2c1311000244db8b0089eb74f3797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>.  <br /></td></tr>
<tr class="separator:a9ef2c1311000244db8b0089eb74f3797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc06eeea662fd4a5ebf98f52397fc74" id="r_a9cc06eeea662fd4a5ebf98f52397fc74"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; uws &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cc06eeea662fd4a5ebf98f52397fc74">operator&quot;&quot;_ss</a> (const uws *ptr, size_t l)</td></tr>
<tr class="memdesc:a9cc06eeea662fd4a5ebf98f52397fc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>.  <br /></td></tr>
<tr class="separator:a9cc06eeea662fd4a5ebf98f52397fc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535ff50092fb0783922615ee0d3af5a2" id="r_a535ff50092fb0783922615ee0d3af5a2"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; u16s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a535ff50092fb0783922615ee0d3af5a2">operator&quot;&quot;_ss</a> (const u16s *ptr, size_t l)</td></tr>
<tr class="memdesc:a535ff50092fb0783922615ee0d3af5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>.  <br /></td></tr>
<tr class="separator:a535ff50092fb0783922615ee0d3af5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b1772b2228c5234e1906e6c879c983" id="r_a20b1772b2228c5234e1906e6c879c983"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; u32s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b1772b2228c5234e1906e6c879c983">operator&quot;&quot;_ss</a> (const u32s *ptr, size_t l)</td></tr>
<tr class="memdesc:a20b1772b2228c5234e1906e6c879c983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>.  <br /></td></tr>
<tr class="separator:a20b1772b2228c5234e1906e6c879c983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df8d5833d6274ee7d071c21374a5bf0" id="r_a0df8d5833d6274ee7d071c21374a5bf0"><td class="memItemLeft" align="right" valign="top">consteval HashKey&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0df8d5833d6274ee7d071c21374a5bf0">operator&quot;&quot;_h</a> (const u8s *ptr, size_t l)</td></tr>
<tr class="memdesc:a0df8d5833d6274ee7d071c21374a5bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-sensitive hash calculated at compile time.  <br /></td></tr>
<tr class="separator:a0df8d5833d6274ee7d071c21374a5bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fe7e669051cea6d5406e8b61ba10fa" id="r_a46fe7e669051cea6d5406e8b61ba10fa"><td class="memItemLeft" align="right" valign="top">consteval HashKeyIA&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46fe7e669051cea6d5406e8b61ba10fa">operator&quot;&quot;_ia</a> (const u8s *ptr, size_t l)</td></tr>
<tr class="memdesc:a46fe7e669051cea6d5406e8b61ba10fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-insensitive ASCII hash calculated at compile time.  <br /></td></tr>
<tr class="separator:a46fe7e669051cea6d5406e8b61ba10fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc78c99c32c394aa4bcb4ef5a52aed0e" id="r_abc78c99c32c394aa4bcb4ef5a52aed0e"><td class="memItemLeft" align="right" valign="top">HashKeyIU&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc78c99c32c394aa4bcb4ef5a52aed0e">operator&quot;&quot;_iu</a> (const u8s *ptr, size_t l)</td></tr>
<tr class="memdesc:abc78c99c32c394aa4bcb4ef5a52aed0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a simple unicode case-insensitive hash calculated at compile time.  <br /></td></tr>
<tr class="separator:abc78c99c32c394aa4bcb4ef5a52aed0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6365fc9cbc877e83333d71c9387bf92" id="r_ab6365fc9cbc877e83333d71c9387bf92"><td class="memItemLeft" align="right" valign="top">consteval HashKey&lt; u16s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6365fc9cbc877e83333d71c9387bf92">operator&quot;&quot;_h</a> (const u16s *ptr, size_t l)</td></tr>
<tr class="memdesc:ab6365fc9cbc877e83333d71c9387bf92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-sensitive hash calculated at compile time.  <br /></td></tr>
<tr class="separator:ab6365fc9cbc877e83333d71c9387bf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9eb8724ed875305019a64d0522706a" id="r_a5e9eb8724ed875305019a64d0522706a"><td class="memItemLeft" align="right" valign="top">consteval HashKeyIA&lt; u16s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e9eb8724ed875305019a64d0522706a">operator&quot;&quot;_ia</a> (const u16s *ptr, size_t l)</td></tr>
<tr class="memdesc:a5e9eb8724ed875305019a64d0522706a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-insensitive ASCII hash calculated at compile time.  <br /></td></tr>
<tr class="separator:a5e9eb8724ed875305019a64d0522706a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd96a341dde656e2a1ffb25d4fd6986" id="r_a6dd96a341dde656e2a1ffb25d4fd6986"><td class="memItemLeft" align="right" valign="top">HashKeyIU&lt; u16s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd96a341dde656e2a1ffb25d4fd6986">operator&quot;&quot;_iu</a> (const u16s *ptr, size_t l)</td></tr>
<tr class="memdesc:a6dd96a341dde656e2a1ffb25d4fd6986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a simple unicode case-insensitive hash calculated at compile time.  <br /></td></tr>
<tr class="separator:a6dd96a341dde656e2a1ffb25d4fd6986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075447008b510f5cbaad22257445c54c" id="r_a075447008b510f5cbaad22257445c54c"><td class="memItemLeft" align="right" valign="top">consteval HashKey&lt; u32s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075447008b510f5cbaad22257445c54c">operator&quot;&quot;_h</a> (const u32s *ptr, size_t l)</td></tr>
<tr class="memdesc:a075447008b510f5cbaad22257445c54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-sensitive hash calculated at compile time.  <br /></td></tr>
<tr class="separator:a075447008b510f5cbaad22257445c54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f61d4a6ce1333dde5ff06f4b31c86b" id="r_a06f61d4a6ce1333dde5ff06f4b31c86b"><td class="memItemLeft" align="right" valign="top">consteval HashKeyIA&lt; u32s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06f61d4a6ce1333dde5ff06f4b31c86b">operator&quot;&quot;_ia</a> (const u32s *ptr, size_t l)</td></tr>
<tr class="memdesc:a06f61d4a6ce1333dde5ff06f4b31c86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-insensitive ASCII hash calculated at compile time.  <br /></td></tr>
<tr class="separator:a06f61d4a6ce1333dde5ff06f4b31c86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485db8e1e2e6c369f85beae0a266d0e4" id="r_a485db8e1e2e6c369f85beae0a266d0e4"><td class="memItemLeft" align="right" valign="top">HashKeyIU&lt; u32s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485db8e1e2e6c369f85beae0a266d0e4">operator&quot;&quot;_iu</a> (const u32s *ptr, size_t l)</td></tr>
<tr class="memdesc:a485db8e1e2e6c369f85beae0a266d0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a simple unicode case-insensitive hash calculated at compile time.  <br /></td></tr>
<tr class="separator:a485db8e1e2e6c369f85beae0a266d0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cc28c7a70e77941cb1c163ddec8fff" id="r_ae2cc28c7a70e77941cb1c163ddec8fff"><td class="memItemLeft" align="right" valign="top">consteval HashKey&lt; uws &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2cc28c7a70e77941cb1c163ddec8fff">operator&quot;&quot;_h</a> (const uws *ptr, size_t l)</td></tr>
<tr class="memdesc:ae2cc28c7a70e77941cb1c163ddec8fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-sensitive hash calculated at compile time.  <br /></td></tr>
<tr class="separator:ae2cc28c7a70e77941cb1c163ddec8fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30a46e01c92348cb1dc730ff3679ae5" id="r_ab30a46e01c92348cb1dc730ff3679ae5"><td class="memItemLeft" align="right" valign="top">consteval HashKeyIA&lt; uws &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab30a46e01c92348cb1dc730ff3679ae5">operator&quot;&quot;_ia</a> (const uws *ptr, size_t l)</td></tr>
<tr class="memdesc:ab30a46e01c92348cb1dc730ff3679ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-insensitive ASCII hash calculated at compile time.  <br /></td></tr>
<tr class="separator:ab30a46e01c92348cb1dc730ff3679ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71bc810203bd9bb837c020dd9122b15" id="r_ac71bc810203bd9bb837c020dd9122b15"><td class="memItemLeft" align="right" valign="top">HashKeyIU&lt; uws &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac71bc810203bd9bb837c020dd9122b15">operator&quot;&quot;_iu</a> (const uws *ptr, size_t l)</td></tr>
<tr class="memdesc:ac71bc810203bd9bb837c020dd9122b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a simple unicode case-insensitive hash calculated at compile time.  <br /></td></tr>
<tr class="separator:ac71bc810203bd9bb837c020dd9122b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec8b1404f8ee83332539ea640710923" id="r_adec8b1404f8ee83332539ea640710923"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adec8b1404f8ee83332539ea640710923">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="structsimstr_1_1simple__str.html">ssa</a> text)</td></tr>
<tr class="memdesc:adec8b1404f8ee83332539ea640710923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>.  <br /></td></tr>
<tr class="separator:adec8b1404f8ee83332539ea640710923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc7e400f9544bc71a6b79c3da039e77" id="r_a6cc7e400f9544bc71a6b79c3da039e77"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cc7e400f9544bc71a6b79c3da039e77">operator&lt;&lt;</a> (std::wostream &amp;stream, <a class="el" href="structsimstr_1_1simple__str.html">ssw</a> text)</td></tr>
<tr class="memdesc:a6cc7e400f9544bc71a6b79c3da039e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>.  <br /></td></tr>
<tr class="separator:a6cc7e400f9544bc71a6b79c3da039e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aeed74b1eb9b24bd41903ca7a5238d" id="r_a90aeed74b1eb9b24bd41903ca7a5238d"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90aeed74b1eb9b24bd41903ca7a5238d">operator&lt;&lt;</a> (std::wostream &amp;stream, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; wchar_type &gt; text)</td></tr>
<tr class="memdesc:a90aeed74b1eb9b24bd41903ca7a5238d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>.  <br /></td></tr>
<tr class="separator:a90aeed74b1eb9b24bd41903ca7a5238d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64483fa53db4a67555fa56584b2981d" id="r_ae64483fa53db4a67555fa56584b2981d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae64483fa53db4a67555fa56584b2981d">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classsimstr_1_1sstring.html">stringa</a> &amp;text)</td></tr>
<tr class="memdesc:ae64483fa53db4a67555fa56584b2981d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for outputting sstring to stream.  <br /></td></tr>
<tr class="separator:ae64483fa53db4a67555fa56584b2981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0021c8208ba6a30e7427d88dd7d47dea" id="r_a0021c8208ba6a30e7427d88dd7d47dea"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0021c8208ba6a30e7427d88dd7d47dea">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="classsimstr_1_1sstring.html">stringw</a> &amp;text)</td></tr>
<tr class="memdesc:a0021c8208ba6a30e7427d88dd7d47dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for outputting sstring to stream.  <br /></td></tr>
<tr class="separator:a0021c8208ba6a30e7427d88dd7d47dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9452b3a1fd08defda01e6ce0275e1d" id="r_a8d9452b3a1fd08defda01e6ce0275e1d"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d9452b3a1fd08defda01e6ce0275e1d">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; wchar_type &gt; &amp;text)</td></tr>
<tr class="memdesc:a8d9452b3a1fd08defda01e6ce0275e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for outputting sstring to stream.  <br /></td></tr>
<tr class="separator:a8d9452b3a1fd08defda01e6ce0275e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fd8761a377379d4ce6712c3f144e18" id="r_a73fd8761a377379d4ce6712c3f144e18"><td class="memTemplParams" colspan="2">template&lt;size_t N, bool S, <a class="el" href="conceptsimstr_1_1_allocatorable.html">simstr::Allocatorable</a> A&gt; </td></tr>
<tr class="memitem:a73fd8761a377379d4ce6712c3f144e18"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73fd8761a377379d4ce6712c3f144e18">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; u8s, N, S, A &gt; &amp;text)</td></tr>
<tr class="memdesc:a73fd8761a377379d4ce6712c3f144e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to output lstring to stream.  <br /></td></tr>
<tr class="separator:a73fd8761a377379d4ce6712c3f144e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20affd543e17b6c0300871dc61c5556c" id="r_a20affd543e17b6c0300871dc61c5556c"><td class="memTemplParams" colspan="2">template&lt;size_t N, bool S, <a class="el" href="conceptsimstr_1_1_allocatorable.html">simstr::Allocatorable</a> A&gt; </td></tr>
<tr class="memitem:a20affd543e17b6c0300871dc61c5556c"><td class="memTemplItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a20affd543e17b6c0300871dc61c5556c">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; uws, N, S, A &gt; &amp;text)</td></tr>
<tr class="memdesc:a20affd543e17b6c0300871dc61c5556c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to output lstring to stream.  <br /></td></tr>
<tr class="separator:a20affd543e17b6c0300871dc61c5556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ef820122a9828d0c3a4f77b676298f" id="r_a17ef820122a9828d0c3a4f77b676298f"><td class="memTemplParams" colspan="2">template&lt;size_t N, bool S, <a class="el" href="conceptsimstr_1_1_allocatorable.html">simstr::Allocatorable</a> A&gt; </td></tr>
<tr class="memitem:a17ef820122a9828d0c3a4f77b676298f"><td class="memTemplItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17ef820122a9828d0c3a4f77b676298f">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; wchar_type, N, S, A &gt; &amp;text)</td></tr>
<tr class="memdesc:a17ef820122a9828d0c3a4f77b676298f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to output lstring to stream.  <br /></td></tr>
<tr class="separator:a17ef820122a9828d0c3a4f77b676298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9742e8cdcccc67c0746578f3579127e2" id="r_ga9742e8cdcccc67c0746578f3579127e2"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </td></tr>
<tr class="memitem:ga9742e8cdcccc67c0746578f3579127e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin.html">strexprjoin</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga9742e8cdcccc67c0746578f3579127e2">operator+</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:ga9742e8cdcccc67c0746578f3579127e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An addition operator for two arbitrary string expressions of the same character type.  <br /></td></tr>
<tr class="separator:ga9742e8cdcccc67c0746578f3579127e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab120d6f74296c2e55f8c1a5fcf4521d2" id="r_ab120d6f74296c2e55f8c1a5fcf4521d2"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, convertible_to_strexpr&lt; typename A::symb_type &gt; B&gt; </td></tr>
<tr class="memitem:ab120d6f74296c2e55f8c1a5fcf4521d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, convert_to_strexpr_t&lt; typename A::symb_type, B &gt;, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab120d6f74296c2e55f8c1a5fcf4521d2">operator+</a> (const A &amp;a, B &amp;&amp;b)</td></tr>
<tr class="memdesc:ab120d6f74296c2e55f8c1a5fcf4521d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for string expressions and types for which there is a conversion to string expressions.  <br /></td></tr>
<tr class="separator:ab120d6f74296c2e55f8c1a5fcf4521d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c157cbd5d5a19c0014f9ebf2f4454c" id="r_ae3c157cbd5d5a19c0014f9ebf2f4454c"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, convertible_to_strexpr&lt; typename A::symb_type &gt; B&gt; </td></tr>
<tr class="memitem:ae3c157cbd5d5a19c0014f9ebf2f4454c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, convert_to_strexpr_t&lt; typename A::symb_type, B &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3c157cbd5d5a19c0014f9ebf2f4454c">operator+</a> (B &amp;&amp;b, const A &amp;a)</td></tr>
<tr class="memdesc:ae3c157cbd5d5a19c0014f9ebf2f4454c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for types for which there is a conversion to string expressions and string expressions.  <br /></td></tr>
<tr class="separator:ae3c157cbd5d5a19c0014f9ebf2f4454c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8bc7652fac165ad43ae054fb083616" id="r_ga9d8bc7652fac165ad43ae054fb083616"><td class="memTemplParams" colspan="2">template&lt;typename K, StrExprForType&lt; K &gt; A&gt; </td></tr>
<tr class="memitem:ga9d8bc7652fac165ad43ae054fb083616"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_char&lt; K &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga9d8bc7652fac165ad43ae054fb083616">operator+</a> (const A &amp;a, K s)</td></tr>
<tr class="memdesc:ga9d8bc7652fac165ad43ae054fb083616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator of a string expression and one character.  <br /></td></tr>
<tr class="separator:ga9d8bc7652fac165ad43ae054fb083616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d62d117c726329b31a3ab6b35e8153" id="r_gab0d62d117c726329b31a3ab6b35e8153"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:gab0d62d117c726329b31a3ab6b35e8153"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_char&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gab0d62d117c726329b31a3ab6b35e8153">e_char</a> (K s)</td></tr>
<tr class="memdesc:gab0d62d117c726329b31a3ab6b35e8153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of 1 given character.  <br /></td></tr>
<tr class="separator:gab0d62d117c726329b31a3ab6b35e8153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9c377a32a2cc243efce977c4adffe3" id="r_ga9e9c377a32a2cc243efce977c4adffe3"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit&lt;T&gt;::Count&gt; </td></tr>
<tr class="memitem:ga9e9c377a32a2cc243efce977c4adffe3"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal&lt; typename const_lit&lt; T &gt;::symb_type, static_cast&lt; size_t &gt;(N - 1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga9e9c377a32a2cc243efce977c4adffe3">e_t</a> (T &amp;&amp;s)</td></tr>
<tr class="memdesc:ga9e9c377a32a2cc243efce977c4adffe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string literal to a string expression.  <br /></td></tr>
<tr class="separator:ga9e9c377a32a2cc243efce977c4adffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426dd6edd38c382f64fb4cc547896c80" id="r_ga426dd6edd38c382f64fb4cc547896c80"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename T, typename P = typename const_lit&lt;T&gt;::symb_type, size_t N = const_lit&lt;T&gt;::Count&gt; <br />
requires is_equal_str_type_v&lt;typename A::symb_type, P&gt;</td></tr>
<tr class="memitem:ga426dd6edd38c382f64fb4cc547896c80"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal_join&lt; false, P,(N - 1), A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga426dd6edd38c382f64fb4cc547896c80">operator+</a> (const A &amp;a, T &amp;&amp;s)</td></tr>
<tr class="memdesc:ga426dd6edd38c382f64fb4cc547896c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator for a string expression and a string literal of the same character type.  <br /></td></tr>
<tr class="separator:ga426dd6edd38c382f64fb4cc547896c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c35bc9eecc1509118d73ef5e27d303" id="r_ga07c35bc9eecc1509118d73ef5e27d303"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename T, typename P = typename const_lit&lt;T&gt;::symb_type, size_t N = const_lit&lt;T&gt;::Count&gt; <br />
requires is_equal_str_type_v&lt;typename A::symb_type, P&gt;</td></tr>
<tr class="memitem:ga07c35bc9eecc1509118d73ef5e27d303"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal_join&lt; true, P,(N - 1), A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga07c35bc9eecc1509118d73ef5e27d303">operator+</a> (T &amp;&amp;s, const A &amp;a)</td></tr>
<tr class="memdesc:ga07c35bc9eecc1509118d73ef5e27d303"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator for a string literal of the same character type and string expression.  <br /></td></tr>
<tr class="separator:ga07c35bc9eecc1509118d73ef5e27d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e02268e25a635b4b7e14d0744b46c1" id="r_ga33e02268e25a635b4b7e14d0744b46c1"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ga33e02268e25a635b4b7e14d0744b46c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; u8s, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga33e02268e25a635b4b7e14d0744b46c1">e_spca</a> ()</td></tr>
<tr class="memdesc:ga33e02268e25a635b4b7e14d0744b46c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of N char spaces.  <br /></td></tr>
<tr class="separator:ga33e02268e25a635b4b7e14d0744b46c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b5d15132fcc706d1edc1364673a4ab" id="r_ga23b5d15132fcc706d1edc1364673a4ab"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ga23b5d15132fcc706d1edc1364673a4ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; uws, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga23b5d15132fcc706d1edc1364673a4ab">e_spcw</a> ()</td></tr>
<tr class="memdesc:ga23b5d15132fcc706d1edc1364673a4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of N wchar_t spaces.  <br /></td></tr>
<tr class="separator:ga23b5d15132fcc706d1edc1364673a4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54b64072b9629a32837d9197dfe51b5" id="r_gab54b64072b9629a32837d9197dfe51b5"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:gab54b64072b9629a32837d9197dfe51b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__pad.html">expr_pad</a>&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gab54b64072b9629a32837d9197dfe51b5">e_c</a> (size_t l, K s)</td></tr>
<tr class="memdesc:gab54b64072b9629a32837d9197dfe51b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of l characters s of type K.  <br /></td></tr>
<tr class="separator:gab54b64072b9629a32837d9197dfe51b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d17e531ba0aa5e62e0480fa8b1a1497" id="r_ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memTemplParams" colspan="2">template&lt;typename T, typename K = const_lit&lt;T&gt;::symb_type, size_t M = const_lit&lt;T&gt;::Count&gt; <br />
requires (M &gt; 0)</td></tr>
<tr class="memitem:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_repeat_lit&lt; K, M - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga9d17e531ba0aa5e62e0480fa8b1a1497">e_repeat</a> (T &amp;&amp;s, size_t l)</td></tr>
<tr class="memdesc:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string from l string constants s of type K.  <br /></td></tr>
<tr class="separator:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110a07b71eab2b667f78afc1068df0a9" id="r_ga110a07b71eab2b667f78afc1068df0a9"><td class="memTemplParams" colspan="2">template&lt;StrExpr A&gt; </td></tr>
<tr class="memitem:ga110a07b71eab2b667f78afc1068df0a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_repeat_expr&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga110a07b71eab2b667f78afc1068df0a9">e_repeat</a> (const A &amp;s, size_t l)</td></tr>
<tr class="memdesc:ga110a07b71eab2b667f78afc1068df0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string from l string expressions s of type K.  <br /></td></tr>
<tr class="separator:ga110a07b71eab2b667f78afc1068df0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab058a69a654cf3a0fce197e862a7400e" id="r_gab058a69a654cf3a0fce197e862a7400e"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </td></tr>
<tr class="memitem:gab058a69a654cf3a0fce197e862a7400e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice.html">expr_choice</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gab058a69a654cf3a0fce197e862a7400e">e_choice</a> (bool c, const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:gab058a69a654cf3a0fce197e862a7400e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a conditional string expression <a class="el" href="structsimstr_1_1expr__choice.html" title="Conditional selection string expression.">expr_choice</a>.  <br /></td></tr>
<tr class="separator:gab058a69a654cf3a0fce197e862a7400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83da2cba80aa8121f4a43727a2914a35" id="r_ga83da2cba80aa8121f4a43727a2914a35"><td class="memTemplParams" colspan="2">
template&lt;StrExpr A, typename T, size_t N = const_lit_for&lt;typename A::symb_type, T&gt;::Count&gt; </td></tr>
<tr class="memitem:ga83da2cba80aa8121f4a43727a2914a35"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__one__lit.html">expr_choice_one_lit</a>&lt; typename const_lit&lt; T &gt;::symb_type, A, N - 1, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>e_choice</b> (bool c, const A &amp;a, T &amp;&amp;str)</td></tr>
<tr class="memdesc:ga83da2cba80aa8121f4a43727a2914a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the third argument is a string literal. <br /></td></tr>
<tr class="separator:ga83da2cba80aa8121f4a43727a2914a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad305cec2225b216a16282ce343ef4162" id="r_gad305cec2225b216a16282ce343ef4162"><td class="memTemplParams" colspan="2">
template&lt;StrExpr A, typename T, size_t N = const_lit_for&lt;typename A::symb_type, T&gt;::Count&gt; </td></tr>
<tr class="memitem:gad305cec2225b216a16282ce343ef4162"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__one__lit.html">expr_choice_one_lit</a>&lt; typename const_lit&lt; T &gt;::symb_type, A, N - 1, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>e_choice</b> (bool c, T &amp;&amp;str, const A &amp;a)</td></tr>
<tr class="memdesc:gad305cec2225b216a16282ce343ef4162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the second argument is a string literal. <br /></td></tr>
<tr class="separator:gad305cec2225b216a16282ce343ef4162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081bd71800edf88c06cbfbbd9aba4107" id="r_ga081bd71800edf88c06cbfbbd9aba4107"><td class="memTemplParams" colspan="2">
template&lt;typename T, typename L, typename K = typename const_lit&lt;T&gt;::symb_type, typename P = typename const_lit&lt;L&gt;::symb_type, size_t N = const_lit&lt;T&gt;::Count, size_t M = const_lit_for&lt;typename const_lit&lt;T&gt;::symb_type, L&gt;::Count&gt; <br />
requires is_equal_str_type_v&lt;K, P&gt;</td></tr>
<tr class="memitem:ga081bd71800edf88c06cbfbbd9aba4107"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__two__lit.html">expr_choice_two_lit</a>&lt; K, N -1, P, M - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>e_choice</b> (bool c, T &amp;&amp;str_a, L &amp;&amp;str_b)</td></tr>
<tr class="memdesc:ga081bd71800edf88c06cbfbbd9aba4107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the second and third arguments are string literals. <br /></td></tr>
<tr class="separator:ga081bd71800edf88c06cbfbbd9aba4107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2bd93f7c79b2c59ddf5adb18246751" id="r_ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memTemplParams" colspan="2">template&lt;StrExpr A&gt; </td></tr>
<tr class="memitem:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__if.html">expr_if</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a> (bool c, const A &amp;a)</td></tr>
<tr class="memdesc:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a conditional string expression <a class="el" href="structsimstr_1_1expr__if.html" title="Conditional selection string expression.">expr_if</a>.  <br /></td></tr>
<tr class="separator:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaea41c25b6dc26662221fd1c5fb705c" id="r_gacaea41c25b6dc26662221fd1c5fb705c"><td class="memTemplParams" colspan="2">
template&lt;typename T, size_t N = const_lit&lt;T&gt;::Count&gt; </td></tr>
<tr class="memitem:gacaea41c25b6dc26662221fd1c5fb705c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>e_if</b> (bool c, T &amp;&amp;str)</td></tr>
<tr class="memdesc:gacaea41c25b6dc26662221fd1c5fb705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_if when the second argument is a string literal. <br /></td></tr>
<tr class="separator:gacaea41c25b6dc26662221fd1c5fb705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd001ccf59de81ceb1493eff2d2214f" id="r_ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memTemplParams" colspan="2">template&lt;typename K, FromIntNumber T&gt; </td></tr>
<tr class="memitem:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_num&lt; K, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga4bd001ccf59de81ceb1493eff2d2214f">e_num</a> (T t)</td></tr>
<tr class="memdesc:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a string expression.  <br /></td></tr>
<tr class="separator:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac127100019d8bb5561ca5c3f9ecb7c90" id="r_gac127100019d8bb5561ca5c3f9ecb7c90"><td class="memTemplParams" colspan="2">template&lt;unsigned R, auto fp = f::df, FromIntNumber T&gt; <br />
requires good_int_flags&lt;flags_checker&lt;R, T, decltype(fp)&gt;, false&gt;</td></tr>
<tr class="memitem:gac127100019d8bb5561ca5c3f9ecb7c90"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gac127100019d8bb5561ca5c3f9ecb7c90">e_int</a> (T v)</td></tr>
<tr class="memdesc:gac127100019d8bb5561ca5c3f9ecb7c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object that is converted to a string expression that generates a string representation of a number.  <br /></td></tr>
<tr class="separator:gac127100019d8bb5561ca5c3f9ecb7c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc601d33cf7721d2e7000c0f5957a999" id="r_adc601d33cf7721d2e7000c0f5957a999"><td class="memTemplParams" colspan="2"><a id="adc601d33cf7721d2e7000c0f5957a999" name="adc601d33cf7721d2e7000c0f5957a999"></a>
template&lt;unsigned R, auto fp = f::df, FromIntNumber T&gt; <br />
requires good_int_flags&lt;flags_checker&lt;R, T, decltype(fp)&gt;, true&gt;</td></tr>
<tr class="memitem:adc601d33cf7721d2e7000c0f5957a999"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>e_int</b> (T v, unsigned w)</td></tr>
<tr class="memdesc:adc601d33cf7721d2e7000c0f5957a999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>e_int(num)</code>, only the field width is additionally specified. <br /></td></tr>
<tr class="separator:adc601d33cf7721d2e7000c0f5957a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea7fe28fcd6fdb6dcae8035eb3b8744" id="r_gacea7fe28fcd6fdb6dcae8035eb3b8744"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires is_one_of_char_v&lt;K&gt;</td></tr>
<tr class="memitem:gacea7fe28fcd6fdb6dcae8035eb3b8744"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_real&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gacea7fe28fcd6fdb6dcae8035eb3b8744">e_num</a> (double t)</td></tr>
<tr class="memdesc:gacea7fe28fcd6fdb6dcae8035eb3b8744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <code>double</code> number to a string expression.  <br /></td></tr>
<tr class="separator:gacea7fe28fcd6fdb6dcae8035eb3b8744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae75ae56c754403fbf9f5b610a3326b" id="r_ga6ae75ae56c754403fbf9f5b610a3326b"><td class="memTemplParams" colspan="2">template&lt;unsigned Flags = 0, FromIntNumber T&gt; </td></tr>
<tr class="memitem:ga6ae75ae56c754403fbf9f5b610a3326b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga6ae75ae56c754403fbf9f5b610a3326b">e_hex</a> (T v)</td></tr>
<tr class="memdesc:ga6ae75ae56c754403fbf9f5b610a3326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to concatenate text and a unsigned number in hexadecimal.  <br /></td></tr>
<tr class="separator:ga6ae75ae56c754403fbf9f5b610a3326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29b819f35d451888d14bae0217478561" id="r_ga29b819f35d451888d14bae0217478561"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename K = typename A::symb_type&gt; </td></tr>
<tr class="memitem:ga29b819f35d451888d14bae0217478561"><td class="memTemplItemLeft" align="right" valign="top">expr_fill&lt; K, A, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga29b819f35d451888d14bae0217478561">e_fill_left</a> (const A &amp;a, size_t width, K symbol=K(' '))</td></tr>
<tr class="memdesc:ga29b819f35d451888d14bae0217478561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expression that expands the specified string expression to the specified length given character to the left.  <br /></td></tr>
<tr class="separator:ga29b819f35d451888d14bae0217478561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35d4285042cb44083773109576055f7" id="r_gaa35d4285042cb44083773109576055f7"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename K = typename A::symb_type&gt; </td></tr>
<tr class="memitem:gaa35d4285042cb44083773109576055f7"><td class="memTemplItemLeft" align="right" valign="top">expr_fill&lt; K, A, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gaa35d4285042cb44083773109576055f7">e_fill_right</a> (const A &amp;a, size_t width, K symbol=K(' '))</td></tr>
<tr class="memdesc:gaa35d4285042cb44083773109576055f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expression that expands the specified string expression to the specified length given character to the right.  <br /></td></tr>
<tr class="separator:gaa35d4285042cb44083773109576055f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2e6b8a52bfe20c0b86d25f9f78cb52" id="r_gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memTemplParams" colspan="2">template&lt;bool tail = false, bool skip_empty = false, typename L, typename K = typename const_lit&lt;L&gt;::symb_type, size_t I = const_lit&lt;L&gt;::Count, typename T&gt; </td></tr>
<tr class="memitem:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gafd2e6b8a52bfe20c0b86d25f9f78cb52">e_join</a> (const T &amp;s, L &amp;&amp;d)</td></tr>
<tr class="memdesc:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression concatenating the strings in the container into a single string with the given delimiter.limiter.limiter.  <br /></td></tr>
<tr class="separator:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf15a081168adaeea745b16a254c0230c" id="r_gaf15a081168adaeea745b16a254c0230c"><td class="memTemplParams" colspan="2">template&lt;char... Chars&gt; </td></tr>
<tr class="memitem:gaf15a081168adaeea745b16a254c0230c"><td class="memTemplItemLeft" align="right" valign="top">SS_CONSTEVAL auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gaf15a081168adaeea745b16a254c0230c">operator&quot;&quot;_fmt</a> ()</td></tr>
<tr class="memdesc:gaf15a081168adaeea745b16a254c0230c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a set of radix and flags that can be applied to integers numbers to set formatting parameters using the division operator: <code>num / 0xFormatOptions_fmt</code>. Formatting parameters are set as follows: first comes <code>0x</code>, then the radix written in decimal form. Next may be symbols indicating various flags:  <br /></td></tr>
<tr class="separator:gaf15a081168adaeea745b16a254c0230c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16991abbc007bfa3e438caed37dc780d" id="r_a16991abbc007bfa3e438caed37dc780d"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16991abbc007bfa3e438caed37dc780d">operator&quot;&quot;_ss</a> (const u8s *ptr, size_t l)</td></tr>
<tr class="memdesc:a16991abbc007bfa3e438caed37dc780d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>.  <br /></td></tr>
<tr class="separator:a16991abbc007bfa3e438caed37dc780d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6e82a93c7e4e97c679e434db944312" id="r_a1d6e82a93c7e4e97c679e434db944312"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; ubs &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d6e82a93c7e4e97c679e434db944312">operator&quot;&quot;_ss</a> (const ubs *ptr, size_t l)</td></tr>
<tr class="memdesc:a1d6e82a93c7e4e97c679e434db944312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>.  <br /></td></tr>
<tr class="separator:a1d6e82a93c7e4e97c679e434db944312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e554a52f8477123e525ba4d7dbf830" id="r_a99e554a52f8477123e525ba4d7dbf830"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; uws &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99e554a52f8477123e525ba4d7dbf830">operator&quot;&quot;_ss</a> (const uws *ptr, size_t l)</td></tr>
<tr class="memdesc:a99e554a52f8477123e525ba4d7dbf830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>.  <br /></td></tr>
<tr class="separator:a99e554a52f8477123e525ba4d7dbf830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838531eb886d848a05d3108e668179b7" id="r_a838531eb886d848a05d3108e668179b7"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; u16s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838531eb886d848a05d3108e668179b7">operator&quot;&quot;_ss</a> (const u16s *ptr, size_t l)</td></tr>
<tr class="memdesc:a838531eb886d848a05d3108e668179b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>.  <br /></td></tr>
<tr class="separator:a838531eb886d848a05d3108e668179b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958d3bdbd716bb600b7a22100e38cc47" id="r_a958d3bdbd716bb600b7a22100e38cc47"><td class="memItemLeft" align="right" valign="top">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; u32s &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a958d3bdbd716bb600b7a22100e38cc47">operator&quot;&quot;_ss</a> (const u32s *ptr, size_t l)</td></tr>
<tr class="memdesc:a958d3bdbd716bb600b7a22100e38cc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>.  <br /></td></tr>
<tr class="separator:a958d3bdbd716bb600b7a22100e38cc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb0987b3c98cd839334c33bc1c94bead" id="r_gafb0987b3c98cd839334c33bc1c94bead"><td class="memTemplParams" colspan="2">template&lt;StrSource A, typename K = symb_type_from_src_t&lt;A&gt;, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename X, size_t L = const_lit_for&lt;K, X&gt;::Count&gt; <br />
requires (N &gt; 1)</td></tr>
<tr class="memitem:gafb0987b3c98cd839334c33bc1c94bead"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gafb0987b3c98cd839334c33bc1c94bead">e_repl</a> (A &amp;&amp;w, T &amp;&amp;p, X &amp;&amp;r)</td></tr>
<tr class="memdesc:gafb0987b3c98cd839334c33bc1c94bead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that generates a string with all occurrences of a given substring replaced.  <br /></td></tr>
<tr class="separator:gafb0987b3c98cd839334c33bc1c94bead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc0ac8162caa4ae9c808b435397704a" id="r_ga6cc0ac8162caa4ae9c808b435397704a"><td class="memTemplParams" colspan="2">template&lt;StrSource A, typename K = symb_type_from_src_t&lt;A&gt;, typename T, typename X&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, T&gt; &amp;&amp; std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, X&gt; &amp;&amp; (!is_const_lit_v&lt;T&gt; || !is_const_lit_v&lt;X&gt;))</td></tr>
<tr class="memitem:ga6cc0ac8162caa4ae9c808b435397704a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#ga6cc0ac8162caa4ae9c808b435397704a">e_repl</a> (A &amp;&amp;w, T &amp;&amp;p, X &amp;&amp;r)</td></tr>
<tr class="memdesc:ga6cc0ac8162caa4ae9c808b435397704a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that generates a string with all occurrences of a given substring replaced.  <br /></td></tr>
<tr class="separator:ga6cc0ac8162caa4ae9c808b435397704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d0c57d07e6546628ca08398c5ebee6" id="r_gad6d0c57d07e6546628ca08398c5ebee6"><td class="memTemplParams" colspan="2">template&lt;StrSource A, typename K = symb_type_from_src_t&lt;A&gt;, typename T, StrExprForType&lt; K &gt; E&gt; <br />
requires std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, T&gt;</td></tr>
<tr class="memitem:gad6d0c57d07e6546628ca08398c5ebee6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gad6d0c57d07e6546628ca08398c5ebee6">e_repl</a> (A &amp;&amp;w, T &amp;&amp;p, const E &amp;expr)</td></tr>
<tr class="memdesc:gad6d0c57d07e6546628ca08398c5ebee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that generates a string with all occurrences of a given substring replaced.  <br /></td></tr>
<tr class="separator:gad6d0c57d07e6546628ca08398c5ebee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d4ca53513bcc0d1c0730940ec8a8a1" id="r_gac0d4ca53513bcc0d1c0730940ec8a8a1"><td class="memTemplParams" colspan="2">template&lt;bool UseVector = false, StrSource A, typename K = symb_type_from_src_t&lt;A&gt;, typename ... Repl&gt; <br />
requires (sizeof...(Repl) % 2 == 0)</td></tr>
<tr class="memitem:gac0d4ca53513bcc0d1c0730940ec8a8a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___str_exprs.html#gac0d4ca53513bcc0d1c0730940ec8a8a1">e_repl_const_symbols</a> (A &amp;&amp;src, Repl &amp;&amp;... other)</td></tr>
<tr class="memdesc:gac0d4ca53513bcc0d1c0730940ec8a8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string expression that generates a string containing the given characters replaced with given substrings.  <br /></td></tr>
<tr class="separator:gac0d4ca53513bcc0d1c0730940ec8a8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab19693e574a384f42220cf115ec86c75" id="r_gab19693e574a384f42220cf115ec86c75"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eea</b> {}</td></tr>
<tr class="memdesc:gab19693e574a384f42220cf115ec86c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char. <br /></td></tr>
<tr class="separator:gab19693e574a384f42220cf115ec86c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54de64d6d9cf03f0186e944c924350f" id="r_gac54de64d6d9cf03f0186e944c924350f"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eeb</b> {}</td></tr>
<tr class="memdesc:gac54de64d6d9cf03f0186e944c924350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char8_t. <br /></td></tr>
<tr class="separator:gac54de64d6d9cf03f0186e944c924350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ebc01b80560370b2f318d897bb6000a" id="r_ga2ebc01b80560370b2f318d897bb6000a"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; uws &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eew</b> {}</td></tr>
<tr class="memdesc:ga2ebc01b80560370b2f318d897bb6000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type wchar_t. <br /></td></tr>
<tr class="separator:ga2ebc01b80560370b2f318d897bb6000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96ac61f552b627d623bf4958337242a" id="r_gab96ac61f552b627d623bf4958337242a"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u16s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eeu</b> {}</td></tr>
<tr class="memdesc:gab96ac61f552b627d623bf4958337242a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char16_t. <br /></td></tr>
<tr class="separator:gab96ac61f552b627d623bf4958337242a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470627498bd16d6b5337607650d1c699" id="r_ga470627498bd16d6b5337607650d1c699"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u32s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eeuu</b> {}</td></tr>
<tr class="memdesc:ga470627498bd16d6b5337607650d1c699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char32_t. <br /></td></tr>
<tr class="separator:ga470627498bd16d6b5337607650d1c699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Library namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1b4b1f04b733739606d97f79caa02dd9" name="a1b4b1f04b733739606d97f79caa02dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4b1f04b733739606d97f79caa02dd9">&#9670;&#160;</a></span>IntConvertResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a1b4b1f04b733739606d97f79caa02dd9">simstr::IntConvertResult</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration with possible results of converting a string to an integer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b4b1f04b733739606d97f79caa02dd9a505a83f220c02df2f85c3810cd9ceb38" name="a1b4b1f04b733739606d97f79caa02dd9a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"><p>Успешно </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b4b1f04b733739606d97f79caa02dd9aeaa263ad0ebb3a51a496116be8b354b2" name="a1b4b1f04b733739606d97f79caa02dd9aeaa263ad0ebb3a51a496116be8b354b2"></a>BadSymbolAtTail&#160;</td><td class="fielddoc"><p>Число закончилось не числовым символом </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b4b1f04b733739606d97f79caa02dd9a129e8109f319870e328cc7a1d5b5cae3" name="a1b4b1f04b733739606d97f79caa02dd9a129e8109f319870e328cc7a1d5b5cae3"></a>Overflow&#160;</td><td class="fielddoc"><p>Переполнение, число не помещается в заданный тип </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b4b1f04b733739606d97f79caa02dd9ac15b8c76611746ee6c491a03f31855df" name="a1b4b1f04b733739606d97f79caa02dd9ac15b8c76611746ee6c491a03f31855df"></a>NotNumber&#160;</td><td class="fielddoc"><p>Вообще не число </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a68179a3d25c85c1bab488b570df3b1f2" name="a68179a3d25c85c1bab488b570df3b1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68179a3d25c85c1bab488b570df3b1f2">&#9670;&#160;</a></span>e_utf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To, typename From&gt; <br />
requires (!std::is_same_v&lt;From, To&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__utf.html">expr_utf</a>&lt; From, To &gt; simstr::e_utf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; From &gt;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string expression that converts a string of one character type to another type, via UTF conversion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>- the type of string to convert to. </td></tr>
    <tr><td class="paramname">From</td><td>- the type of string to convert from. Derived from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- the string from which to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6365fc9cbc877e83333d71c9387bf92" name="ab6365fc9cbc877e83333d71c9387bf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6365fc9cbc877e83333d71c9387bf92">&#9670;&#160;</a></span>operator&quot;&quot;_h() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKey&lt; u16s &gt; simstr::literals::operator&quot;&quot;_h </td>
          <td>(</td>
          <td class="paramtype">const u16s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-sensitive hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="a075447008b510f5cbaad22257445c54c" name="a075447008b510f5cbaad22257445c54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075447008b510f5cbaad22257445c54c">&#9670;&#160;</a></span>operator&quot;&quot;_h() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKey&lt; u32s &gt; simstr::literals::operator&quot;&quot;_h </td>
          <td>(</td>
          <td class="paramtype">const u32s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-sensitive hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="a0df8d5833d6274ee7d071c21374a5bf0" name="a0df8d5833d6274ee7d071c21374a5bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df8d5833d6274ee7d071c21374a5bf0">&#9670;&#160;</a></span>operator&quot;&quot;_h() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKey&lt; u8s &gt; simstr::literals::operator&quot;&quot;_h </td>
          <td>(</td>
          <td class="paramtype">const u8s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-sensitive hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="ae2cc28c7a70e77941cb1c163ddec8fff" name="ae2cc28c7a70e77941cb1c163ddec8fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cc28c7a70e77941cb1c163ddec8fff">&#9670;&#160;</a></span>operator&quot;&quot;_h() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKey&lt; uws &gt; simstr::literals::operator&quot;&quot;_h </td>
          <td>(</td>
          <td class="paramtype">const uws *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-sensitive hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="a5e9eb8724ed875305019a64d0522706a" name="a5e9eb8724ed875305019a64d0522706a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9eb8724ed875305019a64d0522706a">&#9670;&#160;</a></span>operator&quot;&quot;_ia() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKeyIA&lt; u16s &gt; simstr::literals::operator&quot;&quot;_ia </td>
          <td>(</td>
          <td class="paramtype">const u16s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-insensitive ASCII hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="a06f61d4a6ce1333dde5ff06f4b31c86b" name="a06f61d4a6ce1333dde5ff06f4b31c86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f61d4a6ce1333dde5ff06f4b31c86b">&#9670;&#160;</a></span>operator&quot;&quot;_ia() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKeyIA&lt; u32s &gt; simstr::literals::operator&quot;&quot;_ia </td>
          <td>(</td>
          <td class="paramtype">const u32s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-insensitive ASCII hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="a46fe7e669051cea6d5406e8b61ba10fa" name="a46fe7e669051cea6d5406e8b61ba10fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fe7e669051cea6d5406e8b61ba10fa">&#9670;&#160;</a></span>operator&quot;&quot;_ia() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKeyIA&lt; u8s &gt; simstr::literals::operator&quot;&quot;_ia </td>
          <td>(</td>
          <td class="paramtype">const u8s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-insensitive ASCII hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="ab30a46e01c92348cb1dc730ff3679ae5" name="ab30a46e01c92348cb1dc730ff3679ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30a46e01c92348cb1dc730ff3679ae5">&#9670;&#160;</a></span>operator&quot;&quot;_ia() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKeyIA&lt; uws &gt; simstr::literals::operator&quot;&quot;_ia </td>
          <td>(</td>
          <td class="paramtype">const uws *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a case-insensitive ASCII hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="a6dd96a341dde656e2a1ffb25d4fd6986" name="a6dd96a341dde656e2a1ffb25d4fd6986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd96a341dde656e2a1ffb25d4fd6986">&#9670;&#160;</a></span>operator&quot;&quot;_iu() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKeyIU&lt; u16s &gt; simstr::literals::operator&quot;&quot;_iu </td>
          <td>(</td>
          <td class="paramtype">const u16s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a simple unicode case-insensitive hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="a485db8e1e2e6c369f85beae0a266d0e4" name="a485db8e1e2e6c369f85beae0a266d0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485db8e1e2e6c369f85beae0a266d0e4">&#9670;&#160;</a></span>operator&quot;&quot;_iu() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKeyIU&lt; u32s &gt; simstr::literals::operator&quot;&quot;_iu </td>
          <td>(</td>
          <td class="paramtype">const u32s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a simple unicode case-insensitive hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="abc78c99c32c394aa4bcb4ef5a52aed0e" name="abc78c99c32c394aa4bcb4ef5a52aed0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc78c99c32c394aa4bcb4ef5a52aed0e">&#9670;&#160;</a></span>operator&quot;&quot;_iu() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKeyIU&lt; u8s &gt; simstr::literals::operator&quot;&quot;_iu </td>
          <td>(</td>
          <td class="paramtype">const u8s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a simple unicode case-insensitive hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="ac71bc810203bd9bb837c020dd9122b15" name="ac71bc810203bd9bb837c020dd9122b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71bc810203bd9bb837c020dd9122b15">&#9670;&#160;</a></span>operator&quot;&quot;_iu() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HashKeyIU&lt; uws &gt; simstr::literals::operator&quot;&quot;_iu </td>
          <td>(</td>
          <td class="paramtype">const uws *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key literal operator for <a class="el" href="classsimstr_1_1hash_str_map.html" title="Container for more efficient searching by string keys.">hashStrMap</a> with a simple unicode case-insensitive hash calculated at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StoreType. </dd></dl>

</div>
</div>
<a id="a535ff50092fb0783922615ee0d3af5a2" name="a535ff50092fb0783922615ee0d3af5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535ff50092fb0783922615ee0d3af5a2">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; u16s &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const u16s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </dd></dl>

</div>
</div>
<a id="a838531eb886d848a05d3108e668179b7" name="a838531eb886d848a05d3108e668179b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838531eb886d848a05d3108e668179b7">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; u16s &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const u16s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a20b1772b2228c5234e1906e6c879c983" name="a20b1772b2228c5234e1906e6c879c983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b1772b2228c5234e1906e6c879c983">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; u32s &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const u32s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </dd></dl>

</div>
</div>
<a id="a958d3bdbd716bb600b7a22100e38cc47" name="a958d3bdbd716bb600b7a22100e38cc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958d3bdbd716bb600b7a22100e38cc47">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; u32s &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const u32s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a5742ba39f28a4548415df9fb55bc2458" name="a5742ba39f28a4548415df9fb55bc2458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5742ba39f28a4548415df9fb55bc2458">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; u8s &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const u8s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </dd></dl>

</div>
</div>
<a id="a16991abbc007bfa3e438caed37dc780d" name="a16991abbc007bfa3e438caed37dc780d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16991abbc007bfa3e438caed37dc780d">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; u8s &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const u8s *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a9ef2c1311000244db8b0089eb74f3797" name="a9ef2c1311000244db8b0089eb74f3797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef2c1311000244db8b0089eb74f3797">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; ubs &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const ubs *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </dd></dl>

</div>
</div>
<a id="a1d6e82a93c7e4e97c679e434db944312" name="a1d6e82a93c7e4e97c679e434db944312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6e82a93c7e4e97c679e434db944312">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; ubs &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const ubs *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a9cc06eeea662fd4a5ebf98f52397fc74" name="a9cc06eeea662fd4a5ebf98f52397fc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc06eeea662fd4a5ebf98f52397fc74">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a>&lt; uws &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const uws *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>. </dd></dl>

</div>
</div>
<a id="a99e554a52f8477123e525ba4d7dbf830" name="a99e554a52f8477123e525ba4d7dbf830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e554a52f8477123e525ba4d7dbf830">&#9670;&#160;</a></span>operator&quot;&quot;_ss() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SS_CONSTEVAL <a class="el" href="structsimstr_1_1str__src__nt.html">str_src_nt</a>&lt; uws &gt; simstr::literals::operator&quot;&quot;_ss </td>
          <td>(</td>
          <td class="paramtype">const uws *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator literal in <a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to a string. </td></tr>
    <tr><td class="paramname">l</td><td>- string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1str__src.html" title="The simplest class of an immutable non-owning string.">str_src</a>. </dd></dl>

</div>
</div>
<a id="ae3c157cbd5d5a19c0014f9ebf2f4454c" name="ae3c157cbd5d5a19c0014f9ebf2f4454c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c157cbd5d5a19c0014f9ebf2f4454c">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, convertible_to_strexpr&lt; typename A::symb_type &gt; B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, convert_to_strexpr_t&lt; typename A::symb_type, B &gt;, false &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">B &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for types for which there is a conversion to string expressions and string expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- the type of the string expression. </td></tr>
    <tr><td class="paramname">B</td><td>- the type of the addend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>- the addend. </td></tr>
    <tr><td class="paramname">a</td><td>- the string expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html" title="Concatenation of a reference to a string expression and the value of the string expression.">strexprjoin_c</a>&lt;A, convert_to_strexpr_t&lt;typename A::symb_type, B&gt;, false&gt; </dd></dl>

</div>
</div>
<a id="ab120d6f74296c2e55f8c1a5fcf4521d2" name="ab120d6f74296c2e55f8c1a5fcf4521d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab120d6f74296c2e55f8c1a5fcf4521d2">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, convertible_to_strexpr&lt; typename A::symb_type &gt; B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, convert_to_strexpr_t&lt; typename A::symb_type, B &gt;, true &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for string expressions and types for which there is a conversion to string expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- the type of the string expression. </td></tr>
    <tr><td class="paramname">B</td><td>- the type of the addend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- the string expression. </td></tr>
    <tr><td class="paramname">b</td><td>- the addend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html" title="Concatenation of a reference to a string expression and the value of the string expression.">strexprjoin_c</a>&lt;A, convert_to_strexpr_t&lt;typename A::symb_type, B&gt;, true&gt; </dd></dl>

</div>
</div>
<a id="a73fd8761a377379d4ce6712c3f144e18" name="a73fd8761a377379d4ce6712c3f144e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fd8761a377379d4ce6712c3f144e18">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, bool S, <a class="el" href="conceptsimstr_1_1_allocatorable.html">simstr::Allocatorable</a> A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; u8s, N, S, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator to output lstring to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
<a id="ae64483fa53db4a67555fa56584b2981d" name="ae64483fa53db4a67555fa56584b2981d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64483fa53db4a67555fa56584b2981d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1sstring.html">stringa</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for outputting sstring to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
<a id="adec8b1404f8ee83332539ea640710923" name="adec8b1404f8ee83332539ea640710923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec8b1404f8ee83332539ea640710923">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">ssa</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream output operator <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
<a id="a20affd543e17b6c0300871dc61c5556c" name="a20affd543e17b6c0300871dc61c5556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20affd543e17b6c0300871dc61c5556c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, bool S, <a class="el" href="conceptsimstr_1_1_allocatorable.html">simstr::Allocatorable</a> A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; uws, N, S, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator to output lstring to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
<a id="a17ef820122a9828d0c3a4f77b676298f" name="a17ef820122a9828d0c3a4f77b676298f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ef820122a9828d0c3a4f77b676298f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, bool S, <a class="el" href="conceptsimstr_1_1_allocatorable.html">simstr::Allocatorable</a> A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; wchar_type, N, S, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator to output lstring to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
<a id="a8d9452b3a1fd08defda01e6ce0275e1d" name="a8d9452b3a1fd08defda01e6ce0275e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9452b3a1fd08defda01e6ce0275e1d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1sstring.html">sstring</a>&lt; wchar_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for outputting sstring to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
<a id="a0021c8208ba6a30e7427d88dd7d47dea" name="a0021c8208ba6a30e7427d88dd7d47dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0021c8208ba6a30e7427d88dd7d47dea">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1sstring.html">stringw</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for outputting sstring to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
<a id="a90aeed74b1eb9b24bd41903ca7a5238d" name="a90aeed74b1eb9b24bd41903ca7a5238d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aeed74b1eb9b24bd41903ca7a5238d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; wchar_type &gt;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream output operator <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
<a id="a6cc7e400f9544bc71a6b79c3da039e77" name="a6cc7e400f9544bc71a6b79c3da039e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc7e400f9544bc71a6b79c3da039e77">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream &amp; simstr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">ssw</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream output operator <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>- output stream. </td></tr>
    <tr><td class="paramname">text</td><td>- text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp;. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimstr.html">simstr</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: Шаблон класса simstr::lstring&lt; K, N, forShared, Allocator &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.6.7</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsimstr_1_1lstring.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Открытые типы</a> &#124;
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="#pub-static-methods">Открытые статические члены</a> &#124;
<a href="#pro-methods">Защищенные члены</a> &#124;
<a href="classsimstr_1_1lstring-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle"><div class="title">Шаблон класса simstr::lstring&lt; K, N, forShared, Allocator &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>Класс мутабельной, владеющей строки. Содержит внутренний буфер для строк заданного размера.  
 <a href="#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="sstring_8h_source.html">sstring.h</a>&gt;</code></p>
<div class="dynheader">
Граф наследования:simstr::lstring&lt; K, N, forShared, Allocator &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsimstr_1_1lstring.png" usemap="#simstr::lstring_3C_20K_2C_20N_2C_20forShared_2C_20Allocator_20_3E_map" alt=""/>
  <map id="simstr::lstring_3C_20K_2C_20N_2C_20forShared_2C_20Allocator_20_3E_map" name="simstr::lstring_3C_20K_2C_20N_2C_20forShared_2C_20Allocator_20_3E_map">
<area href="classsimstr_1_1str__algs.html" alt="simstr::str_algs&lt; K, simple_str&lt; K &gt;, lstring&lt; K, N, false, allocator_string &gt;, true &gt;" shape="rect" coords="0,56,527,80"/>
<area href="classsimstr_1_1str__mutable.html" alt="simstr::str_mutable&lt; K, lstring&lt; K, N, false, allocator_string &gt; &gt;" shape="rect" coords="537,56,1064,80"/>
<area href="classsimstr_1_1str__storable.html" alt="simstr::str_storable&lt; K, lstring&lt; K, N, false, allocator_string &gt;, allocator_string &gt;" shape="rect" coords="1074,56,1601,80"/>
<area href="classsimstr_1_1from__utf__convertible.html" alt="simstr::from_utf_convertible&lt; K, lstring&lt; K, N, false, allocator_string &gt; &gt;" shape="rect" coords="1611,56,2138,80"/>
<area href="classsimstr_1_1str__src__algs.html" alt="simstr::str_src_algs&lt; K, simple_str&lt; K &gt;, lstring&lt; K, N, false, allocator_string &gt;, Mutable &gt;" shape="rect" coords="0,0,527,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Открытые типы</h2></td></tr>
<tr class="memitem:a2be8d42ca8175c4b1a92e27b980909a0" id="r_a2be8d42ca8175c4b1a92e27b980909a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: size_t { <a class="el" href="#a2be8d42ca8175c4b1a92e27b980909a0ae0156729d0c9b54b6917deaf5b6c30c0">LocalCapacity</a> = N | (sizeof(void*) / sizeof(K) - 1)
 }</td></tr>
<tr class="separator:a2be8d42ca8175c4b1a92e27b980909a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:afdd649b8fc867ee9b324691920680575" id="r_afdd649b8fc867ee9b324691920680575"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (std::is_constructible_v&lt;allocator_t, Args...&gt; &amp;&amp; sizeof...(Args) &gt; 0)</td></tr>
<tr class="memitem:afdd649b8fc867ee9b324691920680575"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdd649b8fc867ee9b324691920680575">lstring</a> (Args &amp;&amp;... args) noexcept(std::is_nothrow_constructible_v&lt; allocator_t, Args... &gt;)</td></tr>
<tr class="memdesc:afdd649b8fc867ee9b324691920680575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создать пустой объект.  <br /></td></tr>
<tr class="separator:afdd649b8fc867ee9b324691920680575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5503d97a198725d593e3518d159d3e" id="r_a5e5503d97a198725d593e3518d159d3e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a5e5503d97a198725d593e3518d159d3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e5503d97a198725d593e3518d159d3e">lstring</a> (<a class="el" href="structsimstr_1_1simple__str.html">s_str</a> other, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5e5503d97a198725d593e3518d159d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор из другого строкового объекта.  <br /></td></tr>
<tr class="separator:a5e5503d97a198725d593e3518d159d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a16988e9dffa98991caca6d5a9d99b" id="r_a70a16988e9dffa98991caca6d5a9d99b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a70a16988e9dffa98991caca6d5a9d99b"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70a16988e9dffa98991caca6d5a9d99b">lstring</a> (size_t repeat, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a70a16988e9dffa98991caca6d5a9d99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор повторения строки.  <br /></td></tr>
<tr class="separator:a70a16988e9dffa98991caca6d5a9d99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fcf7732a4c93309d5ba65e131e8e94" id="r_ac8fcf7732a4c93309d5ba65e131e8e94"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:ac8fcf7732a4c93309d5ba65e131e8e94"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8fcf7732a4c93309d5ba65e131e8e94">lstring</a> (size_t count, K pad, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac8fcf7732a4c93309d5ba65e131e8e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор повторения символа.  <br /></td></tr>
<tr class="separator:ac8fcf7732a4c93309d5ba65e131e8e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0896628d4b9c09f66c524431218d07" id="r_acb0896628d4b9c09f66c524431218d07"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:acb0896628d4b9c09f66c524431218d07"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb0896628d4b9c09f66c524431218d07">lstring</a> (const StrExprForType&lt; K &gt; auto &amp;expr, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acb0896628d4b9c09f66c524431218d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор из строкового выражения.  <br /></td></tr>
<tr class="separator:acb0896628d4b9c09f66c524431218d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce0cd4e01e1fa526be905447e5913ea" id="r_a6ce0cd4e01e1fa526be905447e5913ea"><td class="memTemplParams" colspan="2">template&lt;StrType&lt; K &gt; From, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a6ce0cd4e01e1fa526be905447e5913ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ce0cd4e01e1fa526be905447e5913ea">lstring</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6ce0cd4e01e1fa526be905447e5913ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор из строкового источника с заменой.  <br /></td></tr>
<tr class="separator:a6ce0cd4e01e1fa526be905447e5913ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b7f519594ae1b6a50b4b977cdd7969" id="r_a71b7f519594ae1b6a50b4b977cdd7969"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71b7f519594ae1b6a50b4b977cdd7969">lstring</a> (const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;other)</td></tr>
<tr class="memdesc:a71b7f519594ae1b6a50b4b977cdd7969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Копирование из другой строки такого же типа.  <br /></td></tr>
<tr class="separator:a71b7f519594ae1b6a50b4b977cdd7969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b8a2a5ca5a73407148cf67efac0e69" id="r_a71b8a2a5ca5a73407148cf67efac0e69"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (sizeof...(Args) &gt; 0 &amp;&amp; std::is_convertible_v&lt;allocator_t, Args...&gt;)</td></tr>
<tr class="memitem:a71b8a2a5ca5a73407148cf67efac0e69"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71b8a2a5ca5a73407148cf67efac0e69">lstring</a> (const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;other, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a71b8a2a5ca5a73407148cf67efac0e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Копирование из другой строки такого же типа, но с другим аллокатором.  <br /></td></tr>
<tr class="separator:a71b8a2a5ca5a73407148cf67efac0e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233aaa30d88d5c157f6f4a4dec31f499" id="r_a233aaa30d88d5c157f6f4a4dec31f499"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t I = const_lit_for&lt;K, T&gt;::Count, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</td></tr>
<tr class="memitem:a233aaa30d88d5c157f6f4a4dec31f499"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a233aaa30d88d5c157f6f4a4dec31f499">lstring</a> (T &amp;&amp;value, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a233aaa30d88d5c157f6f4a4dec31f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор из строкового литерала.  <br /></td></tr>
<tr class="separator:a233aaa30d88d5c157f6f4a4dec31f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae595139d39bbb592c5e83139bef914cc" id="r_ae595139d39bbb592c5e83139bef914cc"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae595139d39bbb592c5e83139bef914cc">lstring</a> (<a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ae595139d39bbb592c5e83139bef914cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор перемещения из строки такого же типа.  <br /></td></tr>
<tr class="separator:ae595139d39bbb592c5e83139bef914cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8590b10bbfc4eb95a53a575bff2221f" id="r_ab8590b10bbfc4eb95a53a575bff2221f"><td class="memTemplParams" colspan="2">template&lt;typename Op, typename... Args&gt; <br />
requires (std::is_constructible_v&lt;Allocator, Args...&gt; &amp;&amp; (std::is_invocable_v&lt;Op, <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&amp;&gt; || std::is_invocable_v&lt;Op, K*, size_t&gt;))</td></tr>
<tr class="memitem:ab8590b10bbfc4eb95a53a575bff2221f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8590b10bbfc4eb95a53a575bff2221f">lstring</a> (const Op &amp;op, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab8590b10bbfc4eb95a53a575bff2221f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор заполнения с помощью функтора (см. <a class="el" href="classsimstr_1_1str__mutable.html#a53aa57efa783f3d9484a4c9b09bd4f70" title="Заполнение буфера строки с помощью функтора.">str_mutable::fill</a>).  <br /></td></tr>
<tr class="separator:ab8590b10bbfc4eb95a53a575bff2221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19f351477923bb3ca090955866e4315" id="r_ab19f351477923bb3ca090955866e4315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19f351477923bb3ca090955866e4315">operator=</a> (const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;other)</td></tr>
<tr class="memdesc:ab19f351477923bb3ca090955866e4315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор присваивания копией из строки такого же типа.  <br /></td></tr>
<tr class="separator:ab19f351477923bb3ca090955866e4315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dda5e47ad2a1aba0861c7b1179a2e0" id="r_a44dda5e47ad2a1aba0861c7b1179a2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44dda5e47ad2a1aba0861c7b1179a2e0">operator=</a> (<a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a44dda5e47ad2a1aba0861c7b1179a2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор присваивания перемещением из строки такого же типа.  <br /></td></tr>
<tr class="separator:a44dda5e47ad2a1aba0861c7b1179a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dbdd5c648b4b399b4b8c147fc99d43" id="r_ad1dbdd5c648b4b399b4b8c147fc99d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1dbdd5c648b4b399b4b8c147fc99d43">operator=</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt; other)</td></tr>
<tr class="memdesc:ad1dbdd5c648b4b399b4b8c147fc99d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор присваивания из <a class="el" href="structsimstr_1_1simple__str.html" title="Простейший класс иммутабельной не владеющей строки.">simple_str</a>.  <br /></td></tr>
<tr class="separator:ad1dbdd5c648b4b399b4b8c147fc99d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2731727eb853928098f7051a0dca8995" id="r_a2731727eb853928098f7051a0dca8995"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t S = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:a2731727eb853928098f7051a0dca8995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2731727eb853928098f7051a0dca8995">operator=</a> (T &amp;&amp;other)</td></tr>
<tr class="memdesc:a2731727eb853928098f7051a0dca8995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор присваивания строкового литерала.  <br /></td></tr>
<tr class="separator:a2731727eb853928098f7051a0dca8995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895f17a8dd5ef18c2ea0120f785d84cb" id="r_a895f17a8dd5ef18c2ea0120f785d84cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a895f17a8dd5ef18c2ea0120f785d84cb">operator=</a> (const StrExprForType&lt; K &gt; auto &amp;expr)</td></tr>
<tr class="memdesc:a895f17a8dd5ef18c2ea0120f785d84cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор присваивания строкового выражения.  <br /></td></tr>
<tr class="separator:a895f17a8dd5ef18c2ea0120f785d84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9a64c776ee14ef49bb01e84eb87889" id="r_a4e9a64c776ee14ef49bb01e84eb87889"><td class="memItemLeft" align="right" valign="top"><a id="a4e9a64c776ee14ef49bb01e84eb87889" name="a4e9a64c776ee14ef49bb01e84eb87889"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> () const noexcept</td></tr>
<tr class="memdesc:a4e9a64c776ee14ef49bb01e84eb87889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Длина строки. <br /></td></tr>
<tr class="separator:a4e9a64c776ee14ef49bb01e84eb87889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc14bfdba77dd4027af118f6f52a5a93" id="r_acc14bfdba77dd4027af118f6f52a5a93"><td class="memItemLeft" align="right" valign="top"><a id="acc14bfdba77dd4027af118f6f52a5a93" name="acc14bfdba77dd4027af118f6f52a5a93"></a>
constexpr const K *&#160;</td><td class="memItemRight" valign="bottom"><b>symbols</b> () const noexcept</td></tr>
<tr class="memdesc:acc14bfdba77dd4027af118f6f52a5a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Указатель на константные символы. <br /></td></tr>
<tr class="separator:acc14bfdba77dd4027af118f6f52a5a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2deb75dd3dd26b43f363c7f3ac3bd7" id="r_aee2deb75dd3dd26b43f363c7f3ac3bd7"><td class="memItemLeft" align="right" valign="top"><a id="aee2deb75dd3dd26b43f363c7f3ac3bd7" name="aee2deb75dd3dd26b43f363c7f3ac3bd7"></a>
constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><b>str</b> () noexcept</td></tr>
<tr class="memdesc:aee2deb75dd3dd26b43f363c7f3ac3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Указатель на буфер строки. <br /></td></tr>
<tr class="separator:aee2deb75dd3dd26b43f363c7f3ac3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c7ea2f2356a1a299814a418949fdcc" id="r_ab3c7ea2f2356a1a299814a418949fdcc"><td class="memItemLeft" align="right" valign="top"><a id="ab3c7ea2f2356a1a299814a418949fdcc" name="ab3c7ea2f2356a1a299814a418949fdcc"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const noexcept</td></tr>
<tr class="memdesc:ab3c7ea2f2356a1a299814a418949fdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Пустая ли строка. <br /></td></tr>
<tr class="separator:ab3c7ea2f2356a1a299814a418949fdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd7ce10d5ec5fda052efe8d7ab6827" id="r_ae2cd7ce10d5ec5fda052efe8d7ab6827"><td class="memItemLeft" align="right" valign="top"><a id="ae2cd7ce10d5ec5fda052efe8d7ab6827" name="ae2cd7ce10d5ec5fda052efe8d7ab6827"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:ae2cd7ce10d5ec5fda052efe8d7ab6827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Пустая ли строка, для совместимости с std::string. <br /></td></tr>
<tr class="separator:ae2cd7ce10d5ec5fda052efe8d7ab6827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeea9e8d11fee04982ac6df01b4f6a7c" id="r_aeeea9e8d11fee04982ac6df01b4f6a7c"><td class="memItemLeft" align="right" valign="top"><a id="aeeea9e8d11fee04982ac6df01b4f6a7c" name="aeeea9e8d11fee04982ac6df01b4f6a7c"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const noexcept</td></tr>
<tr class="memdesc:aeeea9e8d11fee04982ac6df01b4f6a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Текущая ёмкость буфера строки. <br /></td></tr>
<tr class="separator:aeeea9e8d11fee04982ac6df01b4f6a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c80a142e77e0927ab5a17a17ff5ef7" id="r_aa0c80a142e77e0927ab5a17a17ff5ef7"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0c80a142e77e0927ab5a17a17ff5ef7">reserve_no_preserve</a> (size_t newSize)</td></tr>
<tr class="memdesc:aa0c80a142e77e0927ab5a17a17ff5ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Выделить буфер, достаточный для размещения newSize символов плюс завершающий ноль.  <br /></td></tr>
<tr class="separator:aa0c80a142e77e0927ab5a17a17ff5ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8b36c694de6015158b41d597e7551" id="r_ae9b8b36c694de6015158b41d597e7551"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9b8b36c694de6015158b41d597e7551">reserve</a> (size_t newSize)</td></tr>
<tr class="memdesc:ae9b8b36c694de6015158b41d597e7551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Выделить буфер, достаточный для размещения newSize символов плюс завершающий ноль.  <br /></td></tr>
<tr class="separator:ae9b8b36c694de6015158b41d597e7551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc32346401f3c9db8cee093b193524e7" id="r_abc32346401f3c9db8cee093b193524e7"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc32346401f3c9db8cee093b193524e7">set_size</a> (size_t newSize)</td></tr>
<tr class="memdesc:abc32346401f3c9db8cee093b193524e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Устанавливает размер текущей строки, при необходимости выделяя место.  <br /></td></tr>
<tr class="separator:abc32346401f3c9db8cee093b193524e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4289d6b43caed9e13a78c13bf12c4794" id="r_a4289d6b43caed9e13a78c13bf12c4794"><td class="memItemLeft" align="right" valign="top"><a id="a4289d6b43caed9e13a78c13bf12c4794" name="a4289d6b43caed9e13a78c13bf12c4794"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_local</b> () const noexcept</td></tr>
<tr class="memdesc:a4289d6b43caed9e13a78c13bf12c4794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Узнать, локальный или внешний буфер используется для символов. <br /></td></tr>
<tr class="separator:a4289d6b43caed9e13a78c13bf12c4794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1567876cf258412f403b78241c242fd8" id="r_a1567876cf258412f403b78241c242fd8"><td class="memItemLeft" align="right" valign="top"><a id="a1567876cf258412f403b78241c242fd8" name="a1567876cf258412f403b78241c242fd8"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>define_size</b> ()</td></tr>
<tr class="memdesc:a1567876cf258412f403b78241c242fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Определить длину строки. Ищет символ 0 в буфере строки до его ёмкости, после чего устаналивает длину строки по найденному 0. <br /></td></tr>
<tr class="separator:a1567876cf258412f403b78241c242fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e76a8afbb51ac9ebcf4bf91e7d8331" id="r_ae3e76a8afbb51ac9ebcf4bf91e7d8331"><td class="memItemLeft" align="right" valign="top"><a id="ae3e76a8afbb51ac9ebcf4bf91e7d8331" name="ae3e76a8afbb51ac9ebcf4bf91e7d8331"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="memdesc:ae3e76a8afbb51ac9ebcf4bf91e7d8331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Уменьшает размер внешнего буфера до минимально возможного для хранения строки. Если строка уместится во внутренний буфер - копирует её в него и освобождает внешний буфер. <br /></td></tr>
<tr class="separator:ae3e76a8afbb51ac9ebcf4bf91e7d8331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb855ee5e85fe5890070280d1a1a1ca" id="r_accb855ee5e85fe5890070280d1a1a1ca"><td class="memItemLeft" align="right" valign="top"><a id="accb855ee5e85fe5890070280d1a1a1ca" name="accb855ee5e85fe5890070280d1a1a1ca"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:accb855ee5e85fe5890070280d1a1a1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Делает строку пустой, не меняя буфер строки. <br /></td></tr>
<tr class="separator:accb855ee5e85fe5890070280d1a1a1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcefdd6cce80dcd8983731dafd881b4" id="r_a2bcefdd6cce80dcd8983731dafd881b4"><td class="memItemLeft" align="right" valign="top"><a id="a2bcefdd6cce80dcd8983731dafd881b4" name="a2bcefdd6cce80dcd8983731dafd881b4"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:a2bcefdd6cce80dcd8983731dafd881b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Делает строку пустой и освобождает внешний буфер, если он был. <br /></td></tr>
<tr class="separator:a2bcefdd6cce80dcd8983731dafd881b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400250ea87cc59daa152dc9ddb57491f" id="r_a400250ea87cc59daa152dc9ddb57491f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a400250ea87cc59daa152dc9ddb57491f">compare_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a400250ea87cc59daa152dc9ddb57491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение строк посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a400250ea87cc59daa152dc9ddb57491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf0990c46a280cd363da46bef12e02f" id="r_adbf0990c46a280cd363da46bef12e02f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#adbf0990c46a280cd363da46bef12e02f">equal_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:adbf0990c46a280cd363da46bef12e02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Равна ли строка другой строке посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:adbf0990c46a280cd363da46bef12e02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79e99462478b57d62873f7942ff2b6" id="r_a4e79e99462478b57d62873f7942ff2b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a4e79e99462478b57d62873f7942ff2b6">less_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a4e79e99462478b57d62873f7942ff2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Меньше ли строка другой строки посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a4e79e99462478b57d62873f7942ff2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26465c7fdac87e8d215e836bdbf6e8c3" id="r_a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a26465c7fdac87e8d215e836bdbf6e8c3">starts_with_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Начинается ли строка с заданной подстроки без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535d655a6702861b788830a1d266e48f" id="r_a535d655a6702861b788830a1d266e48f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a535d655a6702861b788830a1d266e48f">ends_with_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a535d655a6702861b788830a1d266e48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заканчивается ли строка указанной подстрокой без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a535d655a6702861b788830a1d266e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3ef69a372dab777c952f22c492689" id="r_a6ae3ef69a372dab777c952f22c492689"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a6ae3ef69a372dab777c952f22c492689">upperred</a> () const</td></tr>
<tr class="memdesc:a6ae3ef69a372dab777c952f22c492689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки в верхнем регистре Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a6ae3ef69a372dab777c952f22c492689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51ac2887746e40214eeee7d52460f4" id="r_a8d51ac2887746e40214eeee7d52460f4"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a8d51ac2887746e40214eeee7d52460f4">lowered</a> () const</td></tr>
<tr class="memdesc:a8d51ac2887746e40214eeee7d52460f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки в нижнем регистре Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a8d51ac2887746e40214eeee7d52460f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af52e61e73c687a34ff6978304edc3" id="r_aa1af52e61e73c687a34ff6978304edc3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aa1af52e61e73c687a34ff6978304edc3">to_double</a> () const noexcept</td></tr>
<tr class="memdesc:aa1af52e61e73c687a34ff6978304edc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в double.  <br /></td></tr>
<tr class="separator:aa1af52e61e73c687a34ff6978304edc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860598fca0df848662d7d8578a8f6da" id="r_af860598fca0df848662d7d8578a8f6da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af860598fca0df848662d7d8578a8f6da">as_number</a> (double &amp;t) const</td></tr>
<tr class="memdesc:af860598fca0df848662d7d8578a8f6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в double.  <br /></td></tr>
<tr class="separator:af860598fca0df848662d7d8578a8f6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17421202713ebd4d62ddf175023f535" id="r_ac17421202713ebd4d62ddf175023f535"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ac17421202713ebd4d62ddf175023f535">as_number</a> (T &amp;t) const</td></tr>
<tr class="memdesc:ac17421202713ebd4d62ddf175023f535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в целое число.  <br /></td></tr>
<tr class="separator:ac17421202713ebd4d62ddf175023f535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af893677739e0d24418f6acc0a29090cc" id="r_af893677739e0d24418f6acc0a29090cc"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place</a> (K *ptr) const noexcept</td></tr>
<tr class="memdesc:af893677739e0d24418f6acc0a29090cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Копировать строку в указанный буфер.  <br /></td></tr>
<tr class="separator:af893677739e0d24418f6acc0a29090cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2498615b426546b65e9b6c4f973264" id="r_a3c2498615b426546b65e9b6c4f973264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a3c2498615b426546b65e9b6c4f973264">copy_to</a> (K *buffer, size_t bufSize)</td></tr>
<tr class="memdesc:a3c2498615b426546b65e9b6c4f973264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Копировать строку в указанный буфер.  <br /></td></tr>
<tr class="separator:a3c2498615b426546b65e9b6c4f973264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2732ccf421fcd1ba606addcca7e6e42" id="r_aa2732ccf421fcd1ba606addcca7e6e42"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa2732ccf421fcd1ba606addcca7e6e42">size</a> () const</td></tr>
<tr class="memdesc:aa2732ccf421fcd1ba606addcca7e6e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер строки в символах.  <br /></td></tr>
<tr class="separator:aa2732ccf421fcd1ba606addcca7e6e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2af1ee80a32a77ad30cffbf6987107" id="r_a1f2af1ee80a32a77ad30cffbf6987107"><td class="memItemLeft" align="right" valign="top">constexpr std::basic_string_view&lt; D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a1f2af1ee80a32a77ad30cffbf6987107">to_sv</a> () const noexcept</td></tr>
<tr class="memdesc:a1f2af1ee80a32a77ad30cffbf6987107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конвертировать в std::basic_string_view.  <br /></td></tr>
<tr class="separator:a1f2af1ee80a32a77ad30cffbf6987107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c6b4c365f05e609a7b22cbf37b39c6" id="r_ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab4c6b4c365f05e609a7b22cbf37b39c6">operator std::basic_string_view&lt; D, Traits &gt;</a> () const</td></tr>
<tr class="memdesc:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конвертировать в std::basic_string_view.  <br /></td></tr>
<tr class="separator:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc816f095922a510dfe466db1905fc63" id="r_adc816f095922a510dfe466db1905fc63"><td class="memItemLeft" align="right" valign="top">constexpr std::basic_string&lt; D, Traits, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#adc816f095922a510dfe466db1905fc63">to_string</a> () const</td></tr>
<tr class="memdesc:adc816f095922a510dfe466db1905fc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конвертировать в std::basic_string.  <br /></td></tr>
<tr class="separator:adc816f095922a510dfe466db1905fc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9959513e8a072c51620248c4a29f4196" id="r_a9959513e8a072c51620248c4a29f4196"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9959513e8a072c51620248c4a29f4196">operator std::basic_string&lt; D, Traits, Allocator &gt;</a> () const</td></tr>
<tr class="memdesc:a9959513e8a072c51620248c4a29f4196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конвертировать в std::basic_string.  <br /></td></tr>
<tr class="separator:a9959513e8a072c51620248c4a29f4196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916218a7a75a3866a9d3d0da9334653c" id="r_a916218a7a75a3866a9d3d0da9334653c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a916218a7a75a3866a9d3d0da9334653c">operator str_piece</a> () const noexcept</td></tr>
<tr class="memdesc:a916218a7a75a3866a9d3d0da9334653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать себя в "кусок строки", включающий всю строку.  <br /></td></tr>
<tr class="separator:a916218a7a75a3866a9d3d0da9334653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d19b3fba03bfd481d2a3b3def766af" id="r_a53d19b3fba03bfd481d2a3b3def766af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a53d19b3fba03bfd481d2a3b3def766af">to_str</a> () const noexcept</td></tr>
<tr class="memdesc:a53d19b3fba03bfd481d2a3b3def766af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать себя в "кусок строки", включающий всю строку.  <br /></td></tr>
<tr class="separator:a53d19b3fba03bfd481d2a3b3def766af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8f275b33545d2491850f49ba3b7876" id="r_ace8f275b33545d2491850f49ba3b7876"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ace8f275b33545d2491850f49ba3b7876">operator()</a> (ptrdiff_t from, ptrdiff_t len=0) const noexcept</td></tr>
<tr class="memdesc:ace8f275b33545d2491850f49ba3b7876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить часть строки как "str_src".  <br /></td></tr>
<tr class="separator:ace8f275b33545d2491850f49ba3b7876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507a43e6ebcc51e6409874712abbbd63" id="r_a507a43e6ebcc51e6409874712abbbd63"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a507a43e6ebcc51e6409874712abbbd63">mid</a> (size_t from, size_t len=-1) const noexcept</td></tr>
<tr class="memdesc:a507a43e6ebcc51e6409874712abbbd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить часть строки как "кусок строки".  <br /></td></tr>
<tr class="separator:a507a43e6ebcc51e6409874712abbbd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5659e7fb47dfb6bd6736a1b454ffde92" id="r_a5659e7fb47dfb6bd6736a1b454ffde92"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a5659e7fb47dfb6bd6736a1b454ffde92">from_to</a> (size_t from, size_t to) const noexcept</td></tr>
<tr class="memdesc:a5659e7fb47dfb6bd6736a1b454ffde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить подстроку <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a> с позиции от from до позиции to (не включая её).  <br /></td></tr>
<tr class="separator:a5659e7fb47dfb6bd6736a1b454ffde92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411f3accc2e800d55e6b26c9c9220926" id="r_a411f3accc2e800d55e6b26c9c9220926"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a411f3accc2e800d55e6b26c9c9220926">until</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a411f3accc2e800d55e6b26c9c9220926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить подстроку <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a> от начала и до первого найденного вхождения указанной подстроки.  <br /></td></tr>
<tr class="separator:a411f3accc2e800d55e6b26c9c9220926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a3ed434bc8ecc755076da742f8e5b" id="r_a992a3ed434bc8ecc755076da742f8e5b"><td class="memItemLeft" align="right" valign="top"><a id="a992a3ed434bc8ecc755076da742f8e5b" name="a992a3ed434bc8ecc755076da742f8e5b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!</b> () const noexcept</td></tr>
<tr class="memdesc:a992a3ed434bc8ecc755076da742f8e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка на пустоту. <br /></td></tr>
<tr class="separator:a992a3ed434bc8ecc755076da742f8e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c053de38bf2a0eab39cf1de5b0a21a" id="r_ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="memItemLeft" align="right" valign="top">constexpr K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad2c053de38bf2a0eab39cf1de5b0a21a">at</a> (ptrdiff_t idx) const</td></tr>
<tr class="memdesc:ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить символ на заданной позиции .  <br /></td></tr>
<tr class="separator:ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d9cd0dc24f5d395e838a3ef20d846" id="r_a108d9cd0dc24f5d395e838a3ef20d846"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a108d9cd0dc24f5d395e838a3ef20d846">compare</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> o) const</td></tr>
<tr class="memdesc:a108d9cd0dc24f5d395e838a3ef20d846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение строк посимвольно.  <br /></td></tr>
<tr class="separator:a108d9cd0dc24f5d395e838a3ef20d846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d501d16ab38c3efb1427f14ea7f67" id="r_a610d501d16ab38c3efb1427f14ea7f67"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a610d501d16ab38c3efb1427f14ea7f67">strcmp</a> (const K *text) const</td></tr>
<tr class="memdesc:a610d501d16ab38c3efb1427f14ea7f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение с C-строкой посимвольно.  <br /></td></tr>
<tr class="separator:a610d501d16ab38c3efb1427f14ea7f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b0cb780c465cb9b6bd925d712ff07" id="r_a3b9b0cb780c465cb9b6bd925d712ff07"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a3b9b0cb780c465cb9b6bd925d712ff07">equal</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other) const noexcept</td></tr>
<tr class="memdesc:a3b9b0cb780c465cb9b6bd925d712ff07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение строк на равенство.  <br /></td></tr>
<tr class="separator:a3b9b0cb780c465cb9b6bd925d712ff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddd0a1f9b25247465fb55c79b58826d" id="r_a1ddd0a1f9b25247465fb55c79b58826d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a1ddd0a1f9b25247465fb55c79b58826d">operator==</a> (const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a1ddd0a1f9b25247465fb55c79b58826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор сравнение строк на равенство.  <br /></td></tr>
<tr class="separator:a1ddd0a1f9b25247465fb55c79b58826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19dc728f9d7edafbd85a52e70b46376" id="r_ac19dc728f9d7edafbd85a52e70b46376"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac19dc728f9d7edafbd85a52e70b46376">operator==</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ac19dc728f9d7edafbd85a52e70b46376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор сравнения строки и строкового литерала на равенство.  <br /></td></tr>
<tr class="separator:ac19dc728f9d7edafbd85a52e70b46376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34637c1f071ac6e6faa0237a092cc61" id="r_ac34637c1f071ac6e6faa0237a092cc61"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac34637c1f071ac6e6faa0237a092cc61">operator&lt;=&gt;</a> (const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ac34637c1f071ac6e6faa0237a092cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор сравнения строк.  <br /></td></tr>
<tr class="separator:ac34637c1f071ac6e6faa0237a092cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63f315c4a97ee6ad1e2b045b9f5f9e0" id="r_ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad63f315c4a97ee6ad1e2b045b9f5f9e0">operator&lt;=&gt;</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор сравнения строки и строкового литерала.  <br /></td></tr>
<tr class="separator:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5e10ff025504ee5d60e8c77f439003" id="r_a0e5e10ff025504ee5d60e8c77f439003"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0e5e10ff025504ee5d60e8c77f439003">compare_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a0e5e10ff025504ee5d60e8c77f439003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение строк посимвольно без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:a0e5e10ff025504ee5d60e8c77f439003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9fca49d189fd0d760ffe8aed1485f1" id="r_afa9fca49d189fd0d760ffe8aed1485f1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#afa9fca49d189fd0d760ffe8aed1485f1">equal_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:afa9fca49d189fd0d760ffe8aed1485f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Равна ли строка другой строке посимвольно без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:afa9fca49d189fd0d760ffe8aed1485f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ede528e694988f26555e91cf9a1ca2" id="r_a44ede528e694988f26555e91cf9a1ca2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a44ede528e694988f26555e91cf9a1ca2">less_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a44ede528e694988f26555e91cf9a1ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Меньше ли строка другой строки посимвольно без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:a44ede528e694988f26555e91cf9a1ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38e5cc7893a20e69cdf03d88232b49c" id="r_ab38e5cc7893a20e69cdf03d88232b49c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab38e5cc7893a20e69cdf03d88232b49c">find</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ab38e5cc7893a20e69cdf03d88232b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало первого вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:ab38e5cc7893a20e69cdf03d88232b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129d72cc64be6029f10bbe1f8385f3ea" id="r_a129d72cc64be6029f10bbe1f8385f3ea"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a129d72cc64be6029f10bbe1f8385f3ea">find</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a129d72cc64be6029f10bbe1f8385f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти символ в этой строке.  <br /></td></tr>
<tr class="separator:a129d72cc64be6029f10bbe1f8385f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab0482ea5f02bc0c3097bed6c9a5fa" id="r_a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a40ab0482ea5f02bc0c3097bed6c9a5fa">find_or_throw</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, Args &amp;&amp;... args) const noexcept</td></tr>
<tr class="memdesc:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало первого вхождения подстроки в этой строке или выкинуть исключение.  <br /></td></tr>
<tr class="separator:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcde5878d3d7fd5138d38ff2f1df4d2" id="r_a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a8bcde5878d3d7fd5138d38ff2f1df4d2">find_end</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти конец вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029fd5412ed114bfefbdddba2c50167" id="r_ac029fd5412ed114bfefbdddba2c50167"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac029fd5412ed114bfefbdddba2c50167">find_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac029fd5412ed114bfefbdddba2c50167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало первого вхождения подстроки в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:ac029fd5412ed114bfefbdddba2c50167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762c55d09b34ba2b7b5f9f10783da662" id="r_a762c55d09b34ba2b7b5f9f10783da662"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a762c55d09b34ba2b7b5f9f10783da662">find_or_all</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a762c55d09b34ba2b7b5f9f10783da662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти символ в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:a762c55d09b34ba2b7b5f9f10783da662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c56c3345019c8d5dc20717092d52101" id="r_a2c56c3345019c8d5dc20717092d52101"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a2c56c3345019c8d5dc20717092d52101">find_end_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a2c56c3345019c8d5dc20717092d52101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти конец первого вхождения подстроки в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:a2c56c3345019c8d5dc20717092d52101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a2c0b10e857c245f67a2abd7c1a2f0" id="r_a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a72a2c0b10e857c245f67a2abd7c1a2f0">find_last</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало последнего вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0564461ab81bfbb6c5bd8b4c7e5a496e" id="r_a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0564461ab81bfbb6c5bd8b4c7e5a496e">find_last</a> (K s, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти последнее вхождения символа в этой строке.  <br /></td></tr>
<tr class="separator:a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab67ba06c8637f93984e45cf349c3eb8" id="r_aab67ba06c8637f93984e45cf349c3eb8"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aab67ba06c8637f93984e45cf349c3eb8">find_end_of_last</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:aab67ba06c8637f93984e45cf349c3eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти конец последнего вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:aab67ba06c8637f93984e45cf349c3eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5bdd0e7ab4f7e64e1e776f4dabe11c" id="r_a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6a5bdd0e7ab4f7e64e1e776f4dabe11c">find_last_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало последнего вхождения подстроки в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281c63da2d81ef8aac65a2dad77eb93" id="r_ae281c63da2d81ef8aac65a2dad77eb93"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae281c63da2d81ef8aac65a2dad77eb93">find_end_of_last_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:ae281c63da2d81ef8aac65a2dad77eb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти конец последнего вхождения подстроки в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:ae281c63da2d81ef8aac65a2dad77eb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d712294186e2e181910677ba9c3ca7" id="r_ac4d712294186e2e181910677ba9c3ca7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac4d712294186e2e181910677ba9c3ca7">contains</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac4d712294186e2e181910677ba9c3ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Содержит ли строка указанную подстроку.  <br /></td></tr>
<tr class="separator:ac4d712294186e2e181910677ba9c3ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8185ccf8fc2297b628cce3c83b6a0b4c" id="r_a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a8185ccf8fc2297b628cce3c83b6a0b4c">for_all_finded</a> (const Op &amp;op, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вызвать функтор для всех найденных вхождений подстроки в этой строке.  <br /></td></tr>
<tr class="separator:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d568443f3ed5752279098b9a488655" id="r_aa6d568443f3ed5752279098b9a488655"><td class="memItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa6d568443f3ed5752279098b9a488655">find_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:aa6d568443f3ed5752279098b9a488655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти все вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:aa6d568443f3ed5752279098b9a488655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bf839edef0abbd43c3f3654e8e700" id="r_a643bf839edef0abbd43c3f3654e8e700"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a643bf839edef0abbd43c3f3654e8e700">find_first_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a643bf839edef0abbd43c3f3654e8e700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти первое вхождение символа из заданного набора символов.  <br /></td></tr>
<tr class="separator:a643bf839edef0abbd43c3f3654e8e700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5ad9c702f21003a272469cb1edcbf3" id="r_aad5ad9c702f21003a272469cb1edcbf3"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aad5ad9c702f21003a272469cb1edcbf3">find_first_of_idx</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:aad5ad9c702f21003a272469cb1edcbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти первое вхождение символа из заданного набора символов.  <br /></td></tr>
<tr class="separator:aad5ad9c702f21003a272469cb1edcbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff5e918afcc8e1fba9a3ec19c47897" id="r_a63ff5e918afcc8e1fba9a3ec19c47897"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a63ff5e918afcc8e1fba9a3ec19c47897">find_first_not_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a63ff5e918afcc8e1fba9a3ec19c47897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти первое вхождение символа не из заданного набора символов.  <br /></td></tr>
<tr class="separator:a63ff5e918afcc8e1fba9a3ec19c47897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73806fa93c9ec619ba93d479d413ea0f" id="r_a73806fa93c9ec619ba93d479d413ea0f"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a73806fa93c9ec619ba93d479d413ea0f">find_last_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:a73806fa93c9ec619ba93d479d413ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти последнее вхождение символа из заданного набора символов.  <br /></td></tr>
<tr class="separator:a73806fa93c9ec619ba93d479d413ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab630d62252bf1210f573a8c7222942c8" id="r_ab630d62252bf1210f573a8c7222942c8"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab630d62252bf1210f573a8c7222942c8">find_last_of_idx</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:ab630d62252bf1210f573a8c7222942c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти последнее вхождение символа из заданного набора символов.  <br /></td></tr>
<tr class="separator:ab630d62252bf1210f573a8c7222942c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775a7c8e218ab3223f0248f225076b7c" id="r_a775a7c8e218ab3223f0248f225076b7c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a775a7c8e218ab3223f0248f225076b7c">find_last_not_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:a775a7c8e218ab3223f0248f225076b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти последнее вхождение символа не из заданного набора символов.  <br /></td></tr>
<tr class="separator:a775a7c8e218ab3223f0248f225076b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512eaf3c2c8736f3021a5bbe60823866" id="r_a512eaf3c2c8736f3021a5bbe60823866"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a512eaf3c2c8736f3021a5bbe60823866">substr</a> (ptrdiff_t from, ptrdiff_t len=0) const</td></tr>
<tr class="memdesc:a512eaf3c2c8736f3021a5bbe60823866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить подстроку. Работает аналогично operator(), только результат выдает того же типа, к которому применён метод.  <br /></td></tr>
<tr class="separator:a512eaf3c2c8736f3021a5bbe60823866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77c31da012cf5cc23e0a60c1888cec2" id="r_aa77c31da012cf5cc23e0a60c1888cec2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa77c31da012cf5cc23e0a60c1888cec2">str_mid</a> (size_t from, size_t len=-1) const</td></tr>
<tr class="memdesc:aa77c31da012cf5cc23e0a60c1888cec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить часть строки объектом того же типа, к которому применён метод, аналогично mid.  <br /></td></tr>
<tr class="separator:aa77c31da012cf5cc23e0a60c1888cec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4213df62c3208dd26ae540122dcfa45d" id="r_a4213df62c3208dd26ae540122dcfa45d"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a4213df62c3208dd26ae540122dcfa45d">as_int</a> () const noexcept</td></tr>
<tr class="memdesc:a4213df62c3208dd26ae540122dcfa45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в число заданного типа.  <br /></td></tr>
<tr class="separator:a4213df62c3208dd26ae540122dcfa45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa40ca4ad70df9ec0941599b88c443dc" id="r_afa40ca4ad70df9ec0941599b88c443dc"><td class="memItemLeft" align="right" valign="top">constexpr convert_result&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#afa40ca4ad70df9ec0941599b88c443dc">to_int</a> () const noexcept</td></tr>
<tr class="memdesc:afa40ca4ad70df9ec0941599b88c443dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в число заданного типа.  <br /></td></tr>
<tr class="separator:afa40ca4ad70df9ec0941599b88c443dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037d07ad0ee024d983927cec3ee81908" id="r_a037d07ad0ee024d983927cec3ee81908"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a037d07ad0ee024d983927cec3ee81908">to_double_hex</a> () const noexcept</td></tr>
<tr class="memdesc:a037d07ad0ee024d983927cec3ee81908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в 16ричной записи в double. Пока работает только для char.  <br /></td></tr>
<tr class="separator:a037d07ad0ee024d983927cec3ee81908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffb295777b82a1475a4fc0d9754481b" id="r_adffb295777b82a1475a4fc0d9754481b"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#adffb295777b82a1475a4fc0d9754481b">splitf</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter, const Op &amp;beforeFunc, size_t offset=0) const</td></tr>
<tr class="memdesc:adffb295777b82a1475a4fc0d9754481b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Разделить строку на части по заданному разделителю, с возможным применением функтора к каждой подстроке.  <br /></td></tr>
<tr class="separator:adffb295777b82a1475a4fc0d9754481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad7e9416ed3abc8689034463f497e6b" id="r_a4ad7e9416ed3abc8689034463f497e6b"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a4ad7e9416ed3abc8689034463f497e6b">split</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter, size_t offset=0) const</td></tr>
<tr class="memdesc:a4ad7e9416ed3abc8689034463f497e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Разделить строку на подстроки по заданному разделителю.  <br /></td></tr>
<tr class="separator:a4ad7e9416ed3abc8689034463f497e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2febfef44dabdf863a74db2049410e9f" id="r_a2febfef44dabdf863a74db2049410e9f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a2febfef44dabdf863a74db2049410e9f">starts_with</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a2febfef44dabdf863a74db2049410e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Начинается ли строка с заданной подстроки.  <br /></td></tr>
<tr class="separator:a2febfef44dabdf863a74db2049410e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9409e48b2f182546b7f7186af2477e" id="r_a6d9409e48b2f182546b7f7186af2477e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6d9409e48b2f182546b7f7186af2477e">starts_with_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a6d9409e48b2f182546b7f7186af2477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Начинается ли строка с заданной подстроки без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:a6d9409e48b2f182546b7f7186af2477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37c68155961c5c7b1609aa1b873b8d3" id="r_ae37c68155961c5c7b1609aa1b873b8d3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae37c68155961c5c7b1609aa1b873b8d3">prefix_in</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:ae37c68155961c5c7b1609aa1b873b8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Является ли эта строка началом другой строки.  <br /></td></tr>
<tr class="separator:ae37c68155961c5c7b1609aa1b873b8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15504449e8d2a8f77832046b559ae0a8" id="r_a15504449e8d2a8f77832046b559ae0a8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a15504449e8d2a8f77832046b559ae0a8">ends_with</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a15504449e8d2a8f77832046b559ae0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заканчивается ли строка указанной подстрокой.  <br /></td></tr>
<tr class="separator:a15504449e8d2a8f77832046b559ae0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63742e2c0e55c85b0569f6a0004e5418" id="r_a63742e2c0e55c85b0569f6a0004e5418"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a63742e2c0e55c85b0569f6a0004e5418">ends_with_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a63742e2c0e55c85b0569f6a0004e5418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заканчивается ли строка указанной подстрокой без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:a63742e2c0e55c85b0569f6a0004e5418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeefcf45750a8260d5a57b3056a1521f" id="r_aaeefcf45750a8260d5a57b3056a1521f"><td class="memItemLeft" align="right" valign="top"><a id="aaeefcf45750a8260d5a57b3056a1521f" name="aaeefcf45750a8260d5a57b3056a1521f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ascii</b> () const noexcept</td></tr>
<tr class="memdesc:aaeefcf45750a8260d5a57b3056a1521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Содержит ли строка только ASCII символы. <br /></td></tr>
<tr class="separator:aaeefcf45750a8260d5a57b3056a1521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517129dd2774440cd48c401b65bcf066" id="r_a517129dd2774440cd48c401b65bcf066"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a517129dd2774440cd48c401b65bcf066">upperred_only_ascii</a> () const</td></tr>
<tr class="memdesc:a517129dd2774440cd48c401b65bcf066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки в верхнем регистре ASCII символов.  <br /></td></tr>
<tr class="separator:a517129dd2774440cd48c401b65bcf066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f36df5ff2422e43919e74d965f24a4" id="r_ad2f36df5ff2422e43919e74d965f24a4"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad2f36df5ff2422e43919e74d965f24a4">lowered_only_ascii</a> () const</td></tr>
<tr class="memdesc:ad2f36df5ff2422e43919e74d965f24a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки в нижнем регистре ASCII символов.  <br /></td></tr>
<tr class="separator:ad2f36df5ff2422e43919e74d965f24a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606b0373189a0fb89bce3801e972e46a" id="r_a606b0373189a0fb89bce3801e972e46a"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a606b0373189a0fb89bce3801e972e46a">replaced</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> repl, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a606b0373189a0fb89bce3801e972e46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки с заменёнными вхождениями подстрок.  <br /></td></tr>
<tr class="separator:a606b0373189a0fb89bce3801e972e46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bded9dcb3da163cf73d690dd63a73d4" id="r_a9bded9dcb3da163cf73d690dd63a73d4"><td class="memItemLeft" align="right" valign="top">constexpr R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9bded9dcb3da163cf73d690dd63a73d4">trimmed</a> () const</td></tr>
<tr class="memdesc:a9bded9dcb3da163cf73d690dd63a73d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением пробельных символов слева и справа.  <br /></td></tr>
<tr class="separator:a9bded9dcb3da163cf73d690dd63a73d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9958a7ba764ec2ee03fd5f205e3bcd" id="r_a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9b9958a7ba764ec2ee03fd5f205e3bcd">trimmed</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, слева и справа.  <br /></td></tr>
<tr class="separator:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e8b3bad27529f5033fee8985dbec7d" id="r_a16e8b3bad27529f5033fee8985dbec7d"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a16e8b3bad27529f5033fee8985dbec7d">trimmed</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a16e8b3bad27529f5033fee8985dbec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, слева и справа.  <br /></td></tr>
<tr class="separator:a16e8b3bad27529f5033fee8985dbec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d2652007aef40826102fb153134c4d" id="r_a25d2652007aef40826102fb153134c4d"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a25d2652007aef40826102fb153134c4d">trimmed_left</a> () const</td></tr>
<tr class="memdesc:a25d2652007aef40826102fb153134c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением пробельных символов слева.  <br /></td></tr>
<tr class="separator:a25d2652007aef40826102fb153134c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7910e7f7cb59cad7452f79ee8f1921a" id="r_ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab7910e7f7cb59cad7452f79ee8f1921a">trimmed_left</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, слева.  <br /></td></tr>
<tr class="separator:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a1d3727d030ed34c789a1fd45a8038" id="r_a17a1d3727d030ed34c789a1fd45a8038"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a17a1d3727d030ed34c789a1fd45a8038">trimmed_left</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a17a1d3727d030ed34c789a1fd45a8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, слева.  <br /></td></tr>
<tr class="separator:a17a1d3727d030ed34c789a1fd45a8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3af5eab221e4645e6e91b7b1a6e7d2" id="r_a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0b3af5eab221e4645e6e91b7b1a6e7d2">trimmed_right</a> () const</td></tr>
<tr class="memdesc:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением пробельных символов справа.  <br /></td></tr>
<tr class="separator:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82f1096d596015340377b58704030cf" id="r_ac82f1096d596015340377b58704030cf"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac82f1096d596015340377b58704030cf">trimmed_right</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ac82f1096d596015340377b58704030cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, справа.  <br /></td></tr>
<tr class="separator:ac82f1096d596015340377b58704030cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a49ba436dd8d11037216dc97efcd4c" id="r_aa5a49ba436dd8d11037216dc97efcd4c"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa5a49ba436dd8d11037216dc97efcd4c">trimmed_right</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:aa5a49ba436dd8d11037216dc97efcd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, справа.  <br /></td></tr>
<tr class="separator:aa5a49ba436dd8d11037216dc97efcd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab950f20c494e2c60b22dfe95e410ec25" id="r_ab950f20c494e2c60b22dfe95e410ec25"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab950f20c494e2c60b22dfe95e410ec25">trimmed_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab950f20c494e2c60b22dfe95e410ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, слева и справа.  <br /></td></tr>
<tr class="separator:ab950f20c494e2c60b22dfe95e410ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2541095cb5e5a262b8e20c4dc8428b" id="r_a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6c2541095cb5e5a262b8e20c4dc8428b">trimmed_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, слева и справа.  <br /></td></tr>
<tr class="separator:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e7c2822c67cc2ea9a0b8c8ed9e0280" id="r_ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae0e7c2822c67cc2ea9a0b8c8ed9e0280">trimmed_left_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, слева.  <br /></td></tr>
<tr class="separator:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b80529d46935202969c279de481cda" id="r_ae9b80529d46935202969c279de481cda"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae9b80529d46935202969c279de481cda">trimmed_left_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:ae9b80529d46935202969c279de481cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, слева.  <br /></td></tr>
<tr class="separator:ae9b80529d46935202969c279de481cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41853e3d4d2579fe7557873592e7302" id="r_ad41853e3d4d2579fe7557873592e7302"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad41853e3d4d2579fe7557873592e7302">trimmed_right_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ad41853e3d4d2579fe7557873592e7302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, справа.  <br /></td></tr>
<tr class="separator:ad41853e3d4d2579fe7557873592e7302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21bff9dca83968de291faa2b6d59fa8" id="r_ac21bff9dca83968de291faa2b6d59fa8"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac21bff9dca83968de291faa2b6d59fa8">trimmed_right_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:ac21bff9dca83968de291faa2b6d59fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, справа.  <br /></td></tr>
<tr class="separator:ac21bff9dca83968de291faa2b6d59fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6c202d1c1723297d46a45d82c5808" id="r_ab3f6c202d1c1723297d46a45d82c5808"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab3f6c202d1c1723297d46a45d82c5808">splitter</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimiter) const</td></tr>
<tr class="memdesc:ab3f6c202d1c1723297d46a45d82c5808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить объект <code>Splitter</code> по заданному разделителю, который позволяет последовательно получать подстроки методом <code>next()</code>, пока <code>is_done()</code> false.  <br /></td></tr>
<tr class="separator:ab3f6c202d1c1723297d46a45d82c5808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb440524f81da0e00cfa303cb4fab6" id="r_a32cb440524f81da0e00cfa303cb4fab6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a32cb440524f81da0e00cfa303cb4fab6">operator K*</a> () noexcept</td></tr>
<tr class="memdesc:a32cb440524f81da0e00cfa303cb4fab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить указатель на буфер строки.  <br /></td></tr>
<tr class="separator:a32cb440524f81da0e00cfa303cb4fab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab697bf9b655f0ed7762ee830efb25b18" id="r_ab697bf9b655f0ed7762ee830efb25b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ab697bf9b655f0ed7762ee830efb25b18">trim</a> ()</td></tr>
<tr class="memdesc:ab697bf9b655f0ed7762ee830efb25b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить пробельные символы в начале и в конце строки.  <br /></td></tr>
<tr class="separator:ab697bf9b655f0ed7762ee830efb25b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25c5f127c99392c53470f0a9919b504" id="r_af25c5f127c99392c53470f0a9919b504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#af25c5f127c99392c53470f0a9919b504">trim</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:af25c5f127c99392c53470f0a9919b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в строковый литерал, в начале и в конце строки.  <br /></td></tr>
<tr class="separator:af25c5f127c99392c53470f0a9919b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ae0d5f1aef083fc2c84274cd794c74" id="r_a14ae0d5f1aef083fc2c84274cd794c74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a14ae0d5f1aef083fc2c84274cd794c74">trim</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a14ae0d5f1aef083fc2c84274cd794c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в переданную строку, в начале и в конце строки.  <br /></td></tr>
<tr class="separator:a14ae0d5f1aef083fc2c84274cd794c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244334bd105c03fa510804b31707996f" id="r_a244334bd105c03fa510804b31707996f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a244334bd105c03fa510804b31707996f">trim_left</a> ()</td></tr>
<tr class="memdesc:a244334bd105c03fa510804b31707996f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить пробельные символы в начале строки.  <br /></td></tr>
<tr class="separator:a244334bd105c03fa510804b31707996f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b013501c10698abf323333d17ab2ac" id="r_a65b013501c10698abf323333d17ab2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a65b013501c10698abf323333d17ab2ac">trim_left</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a65b013501c10698abf323333d17ab2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в строковый литерал, в начале строки.  <br /></td></tr>
<tr class="separator:a65b013501c10698abf323333d17ab2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26d84497e19b7bbfd83da9cc593310" id="r_a2e26d84497e19b7bbfd83da9cc593310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a2e26d84497e19b7bbfd83da9cc593310">trim_left</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a2e26d84497e19b7bbfd83da9cc593310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в переданную строку, в начале строки.  <br /></td></tr>
<tr class="separator:a2e26d84497e19b7bbfd83da9cc593310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8daf67d09761a0834881d00562596f" id="r_a8a8daf67d09761a0834881d00562596f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a8a8daf67d09761a0834881d00562596f">trim_right</a> ()</td></tr>
<tr class="memdesc:a8a8daf67d09761a0834881d00562596f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить пробельные символы в конце строки.  <br /></td></tr>
<tr class="separator:a8a8daf67d09761a0834881d00562596f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73083ad3987d977364c90a9a80a1509f" id="r_a73083ad3987d977364c90a9a80a1509f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a73083ad3987d977364c90a9a80a1509f">trim_right</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a73083ad3987d977364c90a9a80a1509f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в строковый литерал, в конце строки.  <br /></td></tr>
<tr class="separator:a73083ad3987d977364c90a9a80a1509f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c100b87423b8c6261c8c2d16cd82194" id="r_a8c100b87423b8c6261c8c2d16cd82194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a8c100b87423b8c6261c8c2d16cd82194">trim_right</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a8c100b87423b8c6261c8c2d16cd82194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в переданную строку, в конце строки.  <br /></td></tr>
<tr class="separator:a8c100b87423b8c6261c8c2d16cd82194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3240c4342cc4fa0de4126d1446501647" id="r_a3240c4342cc4fa0de4126d1446501647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a3240c4342cc4fa0de4126d1446501647">trim_with_spaces</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a3240c4342cc4fa0de4126d1446501647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в строковый литерал, а также пробельные символы, в начале и в конце строки.  <br /></td></tr>
<tr class="separator:a3240c4342cc4fa0de4126d1446501647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8bfc1561a193de117800effb3bbc7d" id="r_a8e8bfc1561a193de117800effb3bbc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a8e8bfc1561a193de117800effb3bbc7d">trim_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a8e8bfc1561a193de117800effb3bbc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в переданную строку, а также пробельные символы, в начале и в конце строки.  <br /></td></tr>
<tr class="separator:a8e8bfc1561a193de117800effb3bbc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f668bb7ec9de3acf40727167787e630" id="r_a5f668bb7ec9de3acf40727167787e630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a5f668bb7ec9de3acf40727167787e630">trim_left_with_spaces</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a5f668bb7ec9de3acf40727167787e630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в строковый литерал, а также пробельные символы, в начале строки.  <br /></td></tr>
<tr class="separator:a5f668bb7ec9de3acf40727167787e630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff45375785f56489e1e6d8f9d978120" id="r_a7ff45375785f56489e1e6d8f9d978120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a7ff45375785f56489e1e6d8f9d978120">trim_left_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a7ff45375785f56489e1e6d8f9d978120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в переданную строку, а также пробельные символы, в начале строки.  <br /></td></tr>
<tr class="separator:a7ff45375785f56489e1e6d8f9d978120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c59b83d60ff726a3ec9a9aeb1ae404b" id="r_a2c59b83d60ff726a3ec9a9aeb1ae404b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a2c59b83d60ff726a3ec9a9aeb1ae404b">trim_right_with_wpaces</a> (T &amp;&amp;pattern)</td></tr>
<tr class="memdesc:a2c59b83d60ff726a3ec9a9aeb1ae404b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в строковый литерал, а также пробельные символы, в конце строки.  <br /></td></tr>
<tr class="separator:a2c59b83d60ff726a3ec9a9aeb1ae404b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73428dd849aa12f674ece721e067ccb9" id="r_a73428dd849aa12f674ece721e067ccb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a73428dd849aa12f674ece721e067ccb9">trim_right_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern)</td></tr>
<tr class="memdesc:a73428dd849aa12f674ece721e067ccb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить символы, входящие в переданную строку, а также пробельные символы, в конце строки.  <br /></td></tr>
<tr class="separator:a73428dd849aa12f674ece721e067ccb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7b47cfc00189c51a5683fd34095192" id="r_a1c7b47cfc00189c51a5683fd34095192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a1c7b47cfc00189c51a5683fd34095192">upper_only_ascii</a> ()</td></tr>
<tr class="memdesc:a1c7b47cfc00189c51a5683fd34095192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать в верхний регистр ASCII символы.  <br /></td></tr>
<tr class="separator:a1c7b47cfc00189c51a5683fd34095192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f5a8e01bd18d94b873390bdd5eee8d" id="r_a21f5a8e01bd18d94b873390bdd5eee8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a21f5a8e01bd18d94b873390bdd5eee8d">lower_only_ascii</a> ()</td></tr>
<tr class="memdesc:a21f5a8e01bd18d94b873390bdd5eee8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать в нижний регистр ASCII символы.  <br /></td></tr>
<tr class="separator:a21f5a8e01bd18d94b873390bdd5eee8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b975226e92b0e57796dd14fed5248f" id="r_ad1b975226e92b0e57796dd14fed5248f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ad1b975226e92b0e57796dd14fed5248f">upper</a> ()</td></tr>
<tr class="memdesc:ad1b975226e92b0e57796dd14fed5248f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать в верхний регистр Unicode символы первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:ad1b975226e92b0e57796dd14fed5248f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c4239efb3b35bfcb99b61feff08156" id="r_ac0c4239efb3b35bfcb99b61feff08156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ac0c4239efb3b35bfcb99b61feff08156">lower</a> ()</td></tr>
<tr class="memdesc:ac0c4239efb3b35bfcb99b61feff08156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать в нижний регистр Unicode символы первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:ac0c4239efb3b35bfcb99b61feff08156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb338bd949c276a8bd4b9bbc8f9ef5a" id="r_a8bb338bd949c276a8bd4b9bbc8f9ef5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a8bb338bd949c276a8bd4b9bbc8f9ef5a">append</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a8bb338bd949c276a8bd4b9bbc8f9ef5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить другую строку в конец строки.  <br /></td></tr>
<tr class="separator:a8bb338bd949c276a8bd4b9bbc8f9ef5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0275b9ec5edad56807286a9eabd613ff" id="r_a0275b9ec5edad56807286a9eabd613ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a0275b9ec5edad56807286a9eabd613ff">append</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:a0275b9ec5edad56807286a9eabd613ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить строковое выражение в конец строки.  <br /></td></tr>
<tr class="separator:a0275b9ec5edad56807286a9eabd613ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885c6a5a9ecf6417993824dbb4425af6" id="r_a885c6a5a9ecf6417993824dbb4425af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a885c6a5a9ecf6417993824dbb4425af6">operator+=</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a885c6a5a9ecf6417993824dbb4425af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить другую строку в конец строки.  <br /></td></tr>
<tr class="separator:a885c6a5a9ecf6417993824dbb4425af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5514cee68803e4a0a18e648cb5cfc0" id="r_afa5514cee68803e4a0a18e648cb5cfc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#afa5514cee68803e4a0a18e648cb5cfc0">operator+=</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:afa5514cee68803e4a0a18e648cb5cfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить строковое выражение в конец строки.  <br /></td></tr>
<tr class="separator:afa5514cee68803e4a0a18e648cb5cfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740d3b2e75a7ad8c08a8363cbfa9b4df" id="r_a740d3b2e75a7ad8c08a8363cbfa9b4df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a740d3b2e75a7ad8c08a8363cbfa9b4df">append_in</a> (size_t pos, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a740d3b2e75a7ad8c08a8363cbfa9b4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить другую строку, начиная с заданной позиции.  <br /></td></tr>
<tr class="separator:a740d3b2e75a7ad8c08a8363cbfa9b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66589c8ea0f96cc3dd33ca9bba3a65e" id="r_ae66589c8ea0f96cc3dd33ca9bba3a65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ae66589c8ea0f96cc3dd33ca9bba3a65e">append_in</a> (size_t pos, const A &amp;expr)</td></tr>
<tr class="memdesc:ae66589c8ea0f96cc3dd33ca9bba3a65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить строковое выражение, начиная с заданной позиции.  <br /></td></tr>
<tr class="separator:ae66589c8ea0f96cc3dd33ca9bba3a65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a03860f5d616ab4850daa1778e13f57" id="r_a5a03860f5d616ab4850daa1778e13f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a5a03860f5d616ab4850daa1778e13f57">change</a> (size_t from, size_t len, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a5a03860f5d616ab4850daa1778e13f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заменить кусок строки на другую строку.  <br /></td></tr>
<tr class="separator:a5a03860f5d616ab4850daa1778e13f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537880538e549f94a3ce137d7cf33064" id="r_a537880538e549f94a3ce137d7cf33064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a537880538e549f94a3ce137d7cf33064">change</a> (size_t from, size_t len, const A &amp;expr)</td></tr>
<tr class="memdesc:a537880538e549f94a3ce137d7cf33064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заменить кусок строки на строковое выражение.  <br /></td></tr>
<tr class="separator:a537880538e549f94a3ce137d7cf33064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a87ca9286d27c944b0453df89e7f92" id="r_a81a87ca9286d27c944b0453df89e7f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a81a87ca9286d27c944b0453df89e7f92">insert</a> (size_t to, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a81a87ca9286d27c944b0453df89e7f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вставить строку в указанную позицию.  <br /></td></tr>
<tr class="separator:a81a87ca9286d27c944b0453df89e7f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01abc4c1daa39bb99451be642dc86f48" id="r_a01abc4c1daa39bb99451be642dc86f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a01abc4c1daa39bb99451be642dc86f48">insert</a> (size_t to, const A &amp;expr)</td></tr>
<tr class="memdesc:a01abc4c1daa39bb99451be642dc86f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вставить строковое выражение в указанную позицию.  <br /></td></tr>
<tr class="separator:a01abc4c1daa39bb99451be642dc86f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb2a4a250dc0fe4c7c71ecd51745259" id="r_a5eb2a4a250dc0fe4c7c71ecd51745259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a5eb2a4a250dc0fe4c7c71ecd51745259">remove</a> (size_t from, size_t len)</td></tr>
<tr class="memdesc:a5eb2a4a250dc0fe4c7c71ecd51745259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удалить часть строки.  <br /></td></tr>
<tr class="separator:a5eb2a4a250dc0fe4c7c71ecd51745259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c3fa40f6a3f82eb83e0b7c61f1a0fd" id="r_a37c3fa40f6a3f82eb83e0b7c61f1a0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a37c3fa40f6a3f82eb83e0b7c61f1a0fd">prepend</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other)</td></tr>
<tr class="memdesc:a37c3fa40f6a3f82eb83e0b7c61f1a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить другую строку в начало строки.  <br /></td></tr>
<tr class="separator:a37c3fa40f6a3f82eb83e0b7c61f1a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f039d8eb7f384b96ceb0d7f55cf7c" id="r_aab2f039d8eb7f384b96ceb0d7f55cf7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#aab2f039d8eb7f384b96ceb0d7f55cf7c">prepend</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:aab2f039d8eb7f384b96ceb0d7f55cf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавить строковое выражение в начало строки.  <br /></td></tr>
<tr class="separator:aab2f039d8eb7f384b96ceb0d7f55cf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ee55594becb6b2c2b98df722cc7a33" id="r_ac0ee55594becb6b2c2b98df722cc7a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ac0ee55594becb6b2c2b98df722cc7a33">replace</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> repl, size_t offset=0, size_t maxCount=0)</td></tr>
<tr class="memdesc:ac0ee55594becb6b2c2b98df722cc7a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заменить вхождения подстроки на другую строку.  <br /></td></tr>
<tr class="separator:ac0ee55594becb6b2c2b98df722cc7a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86b3a4c468f51e3ab3f7ba9e8786f9f" id="r_ad86b3a4c468f51e3ab3f7ba9e8786f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ad86b3a4c468f51e3ab3f7ba9e8786f9f">replace_from</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> repl, size_t offset=0, size_t maxCount=0)</td></tr>
<tr class="memdesc:ad86b3a4c468f51e3ab3f7ba9e8786f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Скопировать строку-источник, заменив вхождения подстрок на другую строку.  <br /></td></tr>
<tr class="separator:ad86b3a4c468f51e3ab3f7ba9e8786f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53aa57efa783f3d9484a4c9b09bd4f70" id="r_a53aa57efa783f3d9484a4c9b09bd4f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a53aa57efa783f3d9484a4c9b09bd4f70">fill</a> (size_t from, const Op &amp;fillFunction)</td></tr>
<tr class="memdesc:a53aa57efa783f3d9484a4c9b09bd4f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заполнение буфера строки с помощью функтора.  <br /></td></tr>
<tr class="separator:a53aa57efa783f3d9484a4c9b09bd4f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1cad4ba4af2bdd831580151cb32962" id="r_a4a1cad4ba4af2bdd831580151cb32962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a4a1cad4ba4af2bdd831580151cb32962">operator&lt;&lt;</a> (const Op &amp;fillFunction)</td></tr>
<tr class="memdesc:a4a1cad4ba4af2bdd831580151cb32962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заполняет строку методом fill с нулевой позиции.  <br /></td></tr>
<tr class="separator:a4a1cad4ba4af2bdd831580151cb32962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5d59fd9e97d25cc5a9940c19ab796c" id="r_a0a5d59fd9e97d25cc5a9940c19ab796c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a0a5d59fd9e97d25cc5a9940c19ab796c">operator&lt;&lt;</a> (const Op &amp;fillFunction)</td></tr>
<tr class="memdesc:a0a5d59fd9e97d25cc5a9940c19ab796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вызывает переданный функтор, передав ссылку на себя.  <br /></td></tr>
<tr class="separator:a0a5d59fd9e97d25cc5a9940c19ab796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b1fdf213da8dc5cdaf6211904ee690" id="r_a01b1fdf213da8dc5cdaf6211904ee690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a01b1fdf213da8dc5cdaf6211904ee690">operator&lt;&lt;=</a> (const Op &amp;fillFunction)</td></tr>
<tr class="memdesc:a01b1fdf213da8dc5cdaf6211904ee690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заполняет строку методом fill после конца строки.  <br /></td></tr>
<tr class="separator:a01b1fdf213da8dc5cdaf6211904ee690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875205d5df5bc2d8b825ba8edd79b22a" id="r_a875205d5df5bc2d8b825ba8edd79b22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a875205d5df5bc2d8b825ba8edd79b22a">printf_from</a> (size_t from, const K *<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a875205d5df5bc2d8b825ba8edd79b22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавляет отформатированный с помощью sprintf вывод, начиная с указанной позиции.  <br /></td></tr>
<tr class="separator:a875205d5df5bc2d8b825ba8edd79b22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4c37cfab5e6a48dd47c8e7754e6530" id="r_a3f4c37cfab5e6a48dd47c8e7754e6530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a3f4c37cfab5e6a48dd47c8e7754e6530">printf</a> (const K *<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3f4c37cfab5e6a48dd47c8e7754e6530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Форматирует строку помощью sprintf.  <br /></td></tr>
<tr class="separator:a3f4c37cfab5e6a48dd47c8e7754e6530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256725807b06cfe2009cf378c4a687f5" id="r_a256725807b06cfe2009cf378c4a687f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a256725807b06cfe2009cf378c4a687f5">append_printf</a> (const K *<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a256725807b06cfe2009cf378c4a687f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавляет отформатированный с помощью sprintf вывод в конец строки.  <br /></td></tr>
<tr class="separator:a256725807b06cfe2009cf378c4a687f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ca9bf60dd607b6b8721ec84abba5d5" id="r_ae8ca9bf60dd607b6b8721ec84abba5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#ae8ca9bf60dd607b6b8721ec84abba5d5">format_from</a> (size_t from, const FmtString&lt; fmt_type, T... &gt; &amp;<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae8ca9bf60dd607b6b8721ec84abba5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавляет отформатированный с помощью std::format вывод, начиная с указанной позиции.  <br /></td></tr>
<tr class="separator:ae8ca9bf60dd607b6b8721ec84abba5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf2545d9002b51989700a64d7aaff0e" id="r_a7cf2545d9002b51989700a64d7aaff0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a7cf2545d9002b51989700a64d7aaff0e">vformat_from</a> (size_t from, size_t max_write, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7cf2545d9002b51989700a64d7aaff0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавляет отформатированный с помощью std::vformat вывод, начиная с указанной позиции.  <br /></td></tr>
<tr class="separator:a7cf2545d9002b51989700a64d7aaff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfceeaa8961165845fa25fc652e31b0" id="r_a3bfceeaa8961165845fa25fc652e31b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a> (const FmtString&lt; fmt_type, T... &gt; &amp;pattern, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3bfceeaa8961165845fa25fc652e31b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Форматирует строку с помощью std::format.  <br /></td></tr>
<tr class="separator:a3bfceeaa8961165845fa25fc652e31b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39acae07e8fa0b0f40721cf7b7aa9129" id="r_a39acae07e8fa0b0f40721cf7b7aa9129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a39acae07e8fa0b0f40721cf7b7aa9129">append_formatted</a> (const FmtString&lt; fmt_type, T... &gt; &amp;<a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a39acae07e8fa0b0f40721cf7b7aa9129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавляет отформатированный с помощью std::format вывод в конец строки.  <br /></td></tr>
<tr class="separator:a39acae07e8fa0b0f40721cf7b7aa9129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ab4a1d48cbf3b7c3474a4bf28569c" id="r_a4c0ab4a1d48cbf3b7c3474a4bf28569c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a4c0ab4a1d48cbf3b7c3474a4bf28569c">vformat</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4c0ab4a1d48cbf3b7c3474a4bf28569c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Форматирует строку с помощью std::vformat.  <br /></td></tr>
<tr class="separator:a4c0ab4a1d48cbf3b7c3474a4bf28569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3c063949d1d48ca056085eef1dccc3" id="r_adc3c063949d1d48ca056085eef1dccc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#adc3c063949d1d48ca056085eef1dccc3">append_vformatted</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:adc3c063949d1d48ca056085eef1dccc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавляет отформатированный с помощью std::vformat вывод в конец строки.  <br /></td></tr>
<tr class="separator:adc3c063949d1d48ca056085eef1dccc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85893478637a79c79321e5c15cab9763" id="r_a85893478637a79c79321e5c15cab9763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a85893478637a79c79321e5c15cab9763">vformat_n</a> (size_t max_write, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a85893478637a79c79321e5c15cab9763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Форматирует строку с помощью std::vformat не более указанного размера.  <br /></td></tr>
<tr class="separator:a85893478637a79c79321e5c15cab9763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d3c0afd02f09b0f9d32f2a7f52522a" id="r_a48d3c0afd02f09b0f9d32f2a7f52522a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a48d3c0afd02f09b0f9d32f2a7f52522a">append_vformatted_n</a> (size_t max_write, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__mutable.html#a3bfceeaa8961165845fa25fc652e31b0">format</a>, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48d3c0afd02f09b0f9d32f2a7f52522a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавляет отформатированный с помощью std::vformat вывод в конец строки, записывая не более указанного количества символов.  <br /></td></tr>
<tr class="separator:a48d3c0afd02f09b0f9d32f2a7f52522a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a9104a71b1593fea01f6eff162fec4" id="r_a43a9104a71b1593fea01f6eff162fec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__mutable.html#a43a9104a71b1593fea01f6eff162fec4">with</a> (const Op &amp;fillFunction, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a43a9104a71b1593fea01f6eff162fec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вызов функтора со строкой и переданными аргументами.  <br /></td></tr>
<tr class="separator:a43a9104a71b1593fea01f6eff162fec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93a700258bc7492e53ceb2acf414315" id="r_af93a700258bc7492e53ceb2acf414315"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#af93a700258bc7492e53ceb2acf414315">operator const K *</a> () const noexcept</td></tr>
<tr class="memdesc:af93a700258bc7492e53ceb2acf414315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор преобразования в нуль-терминированную C-строку.  <br /></td></tr>
<tr class="separator:af93a700258bc7492e53ceb2acf414315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed242dbe057042c9f72f9514aaf861ee" id="r_aed242dbe057042c9f72f9514aaf861ee"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#aed242dbe057042c9f72f9514aaf861ee">to_nts</a> (size_t from=0) const</td></tr>
<tr class="memdesc:aed242dbe057042c9f72f9514aaf861ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить <a class="el" href="structsimstr_1_1simple__str__nt.html" title="Класс, заявляющий, что ссылается на нуль-терминированную строку.">simple_str_nt</a>, начиная с заданного символа.  <br /></td></tr>
<tr class="separator:aed242dbe057042c9f72f9514aaf861ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcae77eab91707d4b3fa578dde83d34a" id="r_abcae77eab91707d4b3fa578dde83d34a"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#abcae77eab91707d4b3fa578dde83d34a">operator s_str_nt</a> () const</td></tr>
<tr class="memdesc:abcae77eab91707d4b3fa578dde83d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать в <a class="el" href="structsimstr_1_1simple__str__nt.html" title="Класс, заявляющий, что ссылается на нуль-терминированную строку.">simple_str_nt</a>.  <br /></td></tr>
<tr class="separator:abcae77eab91707d4b3fa578dde83d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476d90d2e02d4e72e99f4b4e40f3fec" id="r_ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="memItemLeft" align="right" valign="top">constexpr const K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1null__terminated.html#ac476d90d2e02d4e72e99f4b4e40f3fec">c_str</a> () const</td></tr>
<tr class="memdesc:ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить указатель на константный буфер символов строки  <br /></td></tr>
<tr class="separator:ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Открытые статические члены</h2></td></tr>
<tr class="memitem:a9b002a3618bbfcebc945cef197a397a1" id="r_a9b002a3618bbfcebc945cef197a397a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">join</a> (const T &amp;strings, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> delimiter, bool tail=false, bool skip_empty=false, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9b002a3618bbfcebc945cef197a397a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конкатенация строк из контейнера в одну строку.  <br /></td></tr>
<tr class="separator:a9b002a3618bbfcebc945cef197a397a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb647956eba06372b0cef5328a0bc91" id="r_a6cb647956eba06372b0cef5328a0bc91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a6cb647956eba06372b0cef5328a0bc91">upperred_only_ascii_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6cb647956eba06372b0cef5328a0bc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создать строку, копию переданной в верхнем регистре символов ASCII.  <br /></td></tr>
<tr class="separator:a6cb647956eba06372b0cef5328a0bc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c800534b214e4473b6f59c3d761dc4" id="r_a95c800534b214e4473b6f59c3d761dc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a95c800534b214e4473b6f59c3d761dc4">lowered_only_ascii_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a95c800534b214e4473b6f59c3d761dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создать копию переданной строки в нижнем регистре символов ASCII.  <br /></td></tr>
<tr class="separator:a95c800534b214e4473b6f59c3d761dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c53f8d59e980315bc0d44b5cf6b1e6d" id="r_a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a3c53f8d59e980315bc0d44b5cf6b1e6d">upperred_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создать копию переданной строки в верхнем регистре символов Unicode первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a3c53f8d59e980315bc0d44b5cf6b1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7946e4e405f908fd85c896bd75f67d72" id="r_a7946e4e405f908fd85c896bd75f67d72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a7946e4e405f908fd85c896bd75f67d72">lowered_from</a> (const From &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7946e4e405f908fd85c896bd75f67d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создать копию переданной строки в нижнем регистре символов Unicode первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a7946e4e405f908fd85c896bd75f67d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdcc9ae62c73be2c37e4a40c3366ded" id="r_aafdcc9ae62c73be2c37e4a40c3366ded"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#aafdcc9ae62c73be2c37e4a40c3366ded">replaced_from</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aafdcc9ae62c73be2c37e4a40c3366ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создать копию переданной строки с заменой подстрок.  <br /></td></tr>
<tr class="separator:aafdcc9ae62c73be2c37e4a40c3366ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Защищенные члены</h2></td></tr>
<tr class="memitem:a458697f089f5d3f2aba985e0c707a577" id="r_a458697f089f5d3f2aba985e0c707a577"><td class="memItemLeft" align="right" valign="top"><a id="a458697f089f5d3f2aba985e0c707a577" name="a458697f089f5d3f2aba985e0c707a577"></a>
constexpr allocator_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>allocator</b> ()</td></tr>
<tr class="memdesc:a458697f089f5d3f2aba985e0c707a577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить аллокатор. <br /></td></tr>
<tr class="separator:a458697f089f5d3f2aba985e0c707a577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4116dbd55a53014cef88f4f571cb0c64" id="r_a4116dbd55a53014cef88f4f571cb0c64"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a4116dbd55a53014cef88f4f571cb0c64">init_from_str_other</a> (<a class="el" href="structsimstr_1_1simple__str.html">s_str</a> other)</td></tr>
<tr class="memdesc:a4116dbd55a53014cef88f4f571cb0c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Инициализация из другого строкового объекта.  <br /></td></tr>
<tr class="separator:a4116dbd55a53014cef88f4f571cb0c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e0afaaca95e435c77ecc4ab3f26b8d" id="r_a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a92e0afaaca95e435c77ecc4ab3f26b8d">init_str_repeat</a> (size_t repeat, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern)</td></tr>
<tr class="memdesc:a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Инициализация повторением строки.  <br /></td></tr>
<tr class="separator:a92e0afaaca95e435c77ecc4ab3f26b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d5032575e4c90cdb9a8bcd0aa8c735" id="r_a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a47d5032575e4c90cdb9a8bcd0aa8c735">init_symb_repeat</a> (size_t count, K pad)</td></tr>
<tr class="memdesc:a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Инициализация повторением символа.  <br /></td></tr>
<tr class="separator:a47d5032575e4c90cdb9a8bcd0aa8c735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6ca99606646e8a2fb07f5808dae999" id="r_a5d6ca99606646e8a2fb07f5808dae999"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a5d6ca99606646e8a2fb07f5808dae999">init_str_expr</a> (const A &amp;expr)</td></tr>
<tr class="memdesc:a5d6ca99606646e8a2fb07f5808dae999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Инициализация из строкового выражения.  <br /></td></tr>
<tr class="separator:a5d6ca99606646e8a2fb07f5808dae999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1090a808b0e761a7ecff753d80faebba" id="r_a1090a808b0e761a7ecff753d80faebba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__storable.html#a1090a808b0e761a7ecff753d80faebba">init_replaced</a> (const From &amp;f, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">s_str</a> repl, size_t offset=0, size_t maxCount=0)</td></tr>
<tr class="memdesc:a1090a808b0e761a7ecff753d80faebba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Инициализация из строкового источника с заменой.  <br /></td></tr>
<tr class="separator:a1090a808b0e761a7ecff753d80faebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt;<br />
class simstr::lstring&lt; K, N, forShared, Allocator &gt;</div><p>Класс мутабельной, владеющей строки. Содержит внутренний буфер для строк заданного размера. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- тип символа. </td></tr>
    <tr><td class="paramname">N</td><td>- размер внутреннего строкового буфера не менее N. </td></tr>
    <tr><td class="paramname">forShared</td><td>- аллоцировать внешний буфер в формате, совместимом с sstring. </td></tr>
    <tr><td class="paramname">Allocator</td><td>- тип аллокатора.</td></tr>
  </table>
  </dd>
</dl>
<p>"Локальная" строка. Хранит в себе указатель на символы и длину строки, а за ней либо сами данные до N символов + нуль, либо если данные длиннее N, то размер выделенного буфера. При этом, если планируется потом результат переместить в sstring, то для динамического буфера выделяется +n байтов, чтобы потом не копировать данные. </p>
</div><h2 class="groupheader">Перечисления</h2>
<a id="a2be8d42ca8175c4b1a92e27b980909a0" name="a2be8d42ca8175c4b1a92e27b980909a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be8d42ca8175c4b1a92e27b980909a0">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : size_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Элементы перечислений</th></tr><tr><td class="fieldname"><a id="a2be8d42ca8175c4b1a92e27b980909a0ae0156729d0c9b54b6917deaf5b6c30c0" name="a2be8d42ca8175c4b1a92e27b980909a0ae0156729d0c9b54b6917deaf5b6c30c0"></a>LocalCapacity&#160;</td><td class="fielddoc"><p>Размер внутреннего буфера в символах </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Конструктор(ы)</h2>
<a id="afdd649b8fc867ee9b324691920680575" name="afdd649b8fc867ee9b324691920680575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd649b8fc867ee9b324691920680575">&#9670;&#160;</a></span>lstring() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (std::is_constructible_v&lt;allocator_t, Args...&gt; &amp;&amp; sizeof...(Args) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Создать пустой объект. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e5503d97a198725d593e3518d159d3e" name="a5e5503d97a198725d593e3518d159d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5503d97a198725d593e3518d159d3e">&#9670;&#160;</a></span>lstring() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор из другого строкового объекта. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другой строковый объект, <a class="el" href="structsimstr_1_1simple__str.html" title="Простейший класс иммутабельной не владеющей строки.">simple_str</a>. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70a16988e9dffa98991caca6d5a9d99b" name="a70a16988e9dffa98991caca6d5a9d99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a16988e9dffa98991caca6d5a9d99b">&#9670;&#160;</a></span>lstring() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>repeat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор повторения строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeat</td><td>- количество повторов. </td></tr>
    <tr><td class="paramname">pattern</td><td>- строка, которую надо повторить. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8fcf7732a4c93309d5ba65e131e8e94" name="ac8fcf7732a4c93309d5ba65e131e8e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fcf7732a4c93309d5ba65e131e8e94">&#9670;&#160;</a></span>lstring() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>pad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор повторения символа. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- количество повторов. </td></tr>
    <tr><td class="paramname">pad</td><td>- символ, который надо повторить. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb0896628d4b9c09f66c524431218d07" name="acb0896628d4b9c09f66c524431218d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0896628d4b9c09f66c524431218d07">&#9670;&#160;</a></span>lstring() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const StrExprForType&lt; K &gt; auto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор из строкового выражения. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- строковое выражение. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора.</td></tr>
  </table>
  </dd>
</dl>
<p>Конструктор запрашивает у строкового выражения <code><a class="el" href="#a4e9a64c776ee14ef49bb01e84eb87889" title="Длина строки.">length()</a></code>, выделяет память нужного размера, и вызывает метод <code><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place()</a></code> для размещения результата в буфере. </p>

</div>
</div>
<a id="a6ce0cd4e01e1fa526be905447e5913ea" name="a6ce0cd4e01e1fa526be905447e5913ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce0cd4e01e1fa526be905447e5913ea">&#9670;&#160;</a></span>lstring() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;StrType&lt; K &gt; From, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор из строкового источника с заменой. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- строковый объект, из которого берётся исходная строка. </td></tr>
    <tr><td class="paramname">pattern</td><td>- подстрока, которую надо заменить. </td></tr>
    <tr><td class="paramname">repl</td><td>- строка, на которую надо заменить. </td></tr>
    <tr><td class="paramname">offset</td><td>- начальная позиция для поиска подстрок. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество замен, 0 - без ограничений. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71b7f519594ae1b6a50b4b977cdd7969" name="a71b7f519594ae1b6a50b4b977cdd7969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b7f519594ae1b6a50b4b977cdd7969">&#9670;&#160;</a></span>lstring() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Копирование из другой строки такого же типа. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71b8a2a5ca5a73407148cf67efac0e69" name="a71b8a2a5ca5a73407148cf67efac0e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b8a2a5ca5a73407148cf67efac0e69">&#9670;&#160;</a></span>lstring() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (sizeof...(Args) &gt; 0 &amp;&amp; std::is_convertible_v&lt;allocator_t, Args...&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Копирование из другой строки такого же типа, но с другим аллокатором. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a233aaa30d88d5c157f6f4a4dec31f499" name="a233aaa30d88d5c157f6f4a4dec31f499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233aaa30d88d5c157f6f4a4dec31f499">&#9670;&#160;</a></span>lstring() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t I = const_lit_for&lt;K, T&gt;::Count, typename... Args&gt; <br />
requires std::is_constructible_v&lt;allocator_t, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор из строкового литерала. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- строковый литерал. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae595139d39bbb592c5e83139bef914cc" name="ae595139d39bbb592c5e83139bef914cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae595139d39bbb592c5e83139bef914cc">&#9670;&#160;</a></span>lstring() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор перемещения из строки такого же типа. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8590b10bbfc4eb95a53a575bff2221f" name="ab8590b10bbfc4eb95a53a575bff2221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8590b10bbfc4eb95a53a575bff2221f">&#9670;&#160;</a></span>lstring() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename Op, typename... Args&gt; <br />
requires (std::is_constructible_v&lt;Allocator, Args...&gt; &amp;&amp; (std::is_invocable_v&lt;Op, <a class="el" href="classsimstr_1_1lstring.html">my_type</a>&amp;&gt; || std::is_invocable_v&lt;Op, K*, size_t&gt;))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::lstring </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор заполнения с помощью функтора (см. <a class="el" href="classsimstr_1_1str__mutable.html#a53aa57efa783f3d9484a4c9b09bd4f70" title="Заполнение буфера строки с помощью функтора.">str_mutable::fill</a>). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>- функтов заполнения. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Методы</h2>
<a id="a0275b9ec5edad56807286a9eabd613ff" name="a0275b9ec5edad56807286a9eabd613ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0275b9ec5edad56807286a9eabd613ff">&#9670;&#160;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавить строковое выражение в конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- строковое выражение. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a8bb338bd949c276a8bd4b9bbc8f9ef5a" name="a8bb338bd949c276a8bd4b9bbc8f9ef5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb338bd949c276a8bd4b9bbc8f9ef5a">&#9670;&#160;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавить другую строку в конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a39acae07e8fa0b0f40721cf7b7aa9129" name="a39acae07e8fa0b0f40721cf7b7aa9129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39acae07e8fa0b0f40721cf7b7aa9129">&#9670;&#160;</a></span>append_formatted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_formatted </td>
          <td>(</td>
          <td class="paramtype">const FmtString&lt; fmt_type, T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавляет отформатированный с помощью std::format вывод в конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- форматная строка, константная. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для std::format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="ae66589c8ea0f96cc3dd33ca9bba3a65e" name="ae66589c8ea0f96cc3dd33ca9bba3a65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66589c8ea0f96cc3dd33ca9bba3a65e">&#9670;&#160;</a></span>append_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_in </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавить строковое выражение, начиная с заданной позиции. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- позиция, с которой добавлять. Сначала строка укорачивается до заданного размера, а потом добавляется строковое выражение. </td></tr>
    <tr><td class="paramname">expr</td><td>- строковое выражение. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>Если строка длиннее<code>pos</code>, то она укорачивается до этого размера, а потом добавляется <code>expr</code>. </p>

</div>
</div>
<a id="a740d3b2e75a7ad8c08a8363cbfa9b4df" name="a740d3b2e75a7ad8c08a8363cbfa9b4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740d3b2e75a7ad8c08a8363cbfa9b4df">&#9670;&#160;</a></span>append_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_in </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавить другую строку, начиная с заданной позиции. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- позиция, с которой добавлять. Сначала строка укорачивается до заданного размера, а потом добавляется другая строка. </td></tr>
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>Если строка длиинее<code>pos</code>, то она укорачивается до этого размера, а потом добавляется <code>other</code>. </p>

</div>
</div>
<a id="a256725807b06cfe2009cf378c4a687f5" name="a256725807b06cfe2009cf378c4a687f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256725807b06cfe2009cf378c4a687f5">&#9670;&#160;</a></span>append_printf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_printf </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавляет отформатированный с помощью sprintf вывод в конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- форматная строка. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для sprintf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="adc3c063949d1d48ca056085eef1dccc3" name="adc3c063949d1d48ca056085eef1dccc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3c063949d1d48ca056085eef1dccc3">&#9670;&#160;</a></span>append_vformatted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_vformatted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавляет отформатированный с помощью std::vformat вывод в конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- форматная строка. </td></tr>
    <tr><td class="paramname">...</td><td>- аргументы для std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="a48d3c0afd02f09b0f9d32f2a7f52522a" name="a48d3c0afd02f09b0f9d32f2a7f52522a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d3c0afd02f09b0f9d32f2a7f52522a">&#9670;&#160;</a></span>append_vformatted_n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::append_vformatted_n </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавляет отформатированный с помощью std::vformat вывод в конец строки, записывая не более указанного количества символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_write</td><td>- максимальное количество записываемых символов. </td></tr>
    <tr><td class="paramname">format</td><td>- форматная строка. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="a4213df62c3208dd26ae540122dcfa45d" name="a4213df62c3208dd26ae540122dcfa45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4213df62c3208dd26ae540122dcfa45d">&#9670;&#160;</a></span>as_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::as_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в число заданного типа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- желаемый тип числа. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- проверять на переполнение. </td></tr>
    <tr><td class="paramname">Base</td><td>- основание счисления числа, от -1 до 36, кроме 1.<ul>
<li>Если 0: то пытается определить основание по префиксу 0[xX] как 16, 0 как 8, иначе 10.</li>
<li>Если -1: то пытается определить основание по префиксам:<ul>
<li>0 или 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
<li>в остальных случаях 10. </li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- пропускать пробельные символы в начале строки. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- допустим ли знак '+' перед числом. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>T - число, результат преобразования, насколько оно получилось, или 0 при переполнении. </dd></dl>

</div>
</div>
<a id="af860598fca0df848662d7d8578a8f6da" name="af860598fca0df848662d7d8578a8f6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af860598fca0df848662d7d8578a8f6da">&#9670;&#160;</a></span>as_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в double. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- переменная, в которую записывается результат. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17421202713ebd4d62ddf175023f535" name="ac17421202713ebd4d62ddf175023f535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17421202713ebd4d62ddf175023f535">&#9670;&#160;</a></span>as_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в целое число. </p>
<p>Так как <code>as_number(double&amp; t)</code> перекрывает видимость <code>as_number</code> из базового класса, придётся добавить его ещё раз. </p><dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- тип числа, выводится из аргумента. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- переменная, в которую записывается результат. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c053de38bf2a0eab39cf1de5b0a21a" name="ad2c053de38bf2a0eab39cf1de5b0a21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c053de38bf2a0eab39cf1de5b0a21a">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::at </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить символ на заданной позиции . </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- индекс символа. Для отрицательных значений отсчитывается от конца строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>K - символ.</dd></dl>
<p>Не производит проверку на выход за границы строки. </p>

</div>
</div>
<a id="ac476d90d2e02d4e72e99f4b4e40f3fec" name="ac476d90d2e02d4e72e99f4b4e40f3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac476d90d2e02d4e72e99f4b4e40f3fec">&#9670;&#160;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename Impl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const K * simstr::null_terminated&lt; K, Impl &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить указатель на константный буфер символов строки </p>
<dl class="section return"><dt>Возвращает</dt><dd>const K* - указатель на константный буфер символов строки </dd></dl>

</div>
</div>
<a id="a537880538e549f94a3ce137d7cf33064" name="a537880538e549f94a3ce137d7cf33064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537880538e549f94a3ce137d7cf33064">&#9670;&#160;</a></span>change() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::change </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заменить кусок строки на строковое выражение. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- начальная позиция для замены. </td></tr>
    <tr><td class="paramname">len</td><td>- длина заменяемой части. </td></tr>
    <tr><td class="paramname">expr</td><td>- строковое выражение. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a5a03860f5d616ab4850daa1778e13f57" name="a5a03860f5d616ab4850daa1778e13f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a03860f5d616ab4850daa1778e13f57">&#9670;&#160;</a></span>change() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::change </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заменить кусок строки на другую строку. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- начальная позиция для замены. </td></tr>
    <tr><td class="paramname">len</td><td>- длина заменяемой части. </td></tr>
    <tr><td class="paramname">other</td><td>- строка, на которую эта часть меняется . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a108d9cd0dc24f5d395e838a3ef20d846" name="a108d9cd0dc24f5d395e838a3ef20d846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d9cd0dc24f5d395e838a3ef20d846">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение строк посимвольно. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>&lt;0 эта строка меньше, ==0 - строки равны, &gt;0 - эта строка больше. </dd></dl>

</div>
</div>
<a id="a0e5e10ff025504ee5d60e8c77f439003" name="a0e5e10ff025504ee5d60e8c77f439003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5e10ff025504ee5d60e8c77f439003">&#9670;&#160;</a></span>compare_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::compare_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение строк посимвольно без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>&lt;0 эта строка меньше, ==0 - строки равны, &gt;0 - эта строка больше. </dd></dl>

</div>
</div>
<a id="a400250ea87cc59daa152dc9ddb57491f" name="a400250ea87cc59daa152dc9ddb57491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400250ea87cc59daa152dc9ddb57491f">&#9670;&#160;</a></span>compare_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::compare_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение строк посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>&lt;0 эта строка меньше, ==0 - строки равны, &gt;0 - эта строка больше. </dd></dl>

</div>
</div>
<a id="ac4d712294186e2e181910677ba9c3ca7" name="ac4d712294186e2e181910677ba9c3ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d712294186e2e181910677ba9c3ca7">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Содержит ли строка указанную подстроку. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>bool. </dd></dl>

</div>
</div>
<a id="a3c2498615b426546b65e9b6c4f973264" name="a3c2498615b426546b65e9b6c4f973264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2498615b426546b65e9b6c4f973264">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Копировать строку в указанный буфер. </p>
<p>Метод добавляет <code>\0</code> после скопированных символов. Не выходит за границы буфера. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- указатель на буфер </td></tr>
    <tr><td class="paramname">bufSize</td><td>- размер буфера в символах. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15504449e8d2a8f77832046b559ae0a8" name="a15504449e8d2a8f77832046b559ae0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15504449e8d2a8f77832046b559ae0a8">&#9670;&#160;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заканчивается ли строка указанной подстрокой. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63742e2c0e55c85b0569f6a0004e5418" name="a63742e2c0e55c85b0569f6a0004e5418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63742e2c0e55c85b0569f6a0004e5418">&#9670;&#160;</a></span>ends_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::ends_with_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заканчивается ли строка указанной подстрокой без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a535d655a6702861b788830a1d266e48f" name="a535d655a6702861b788830a1d266e48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535d655a6702861b788830a1d266e48f">&#9670;&#160;</a></span>ends_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::ends_with_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заканчивается ли строка указанной подстрокой без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b9b0cb780c465cb9b6bd925d712ff07" name="a3b9b0cb780c465cb9b6bd925d712ff07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9b0cb780c465cb9b6bd925d712ff07">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение строк на равенство. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>равны ли строки. </dd></dl>

</div>
</div>
<a id="afa9fca49d189fd0d760ffe8aed1485f1" name="afa9fca49d189fd0d760ffe8aed1485f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9fca49d189fd0d760ffe8aed1485f1">&#9670;&#160;</a></span>equal_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::equal_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Равна ли строка другой строке посимвольно без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>равны ли строки. </dd></dl>

</div>
</div>
<a id="adbf0990c46a280cd363da46bef12e02f" name="adbf0990c46a280cd363da46bef12e02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf0990c46a280cd363da46bef12e02f">&#9670;&#160;</a></span>equal_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::equal_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Равна ли строка другой строке посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>равны ли строки. </dd></dl>

</div>
</div>
<a id="a53aa57efa783f3d9484a4c9b09bd4f70" name="a53aa57efa783f3d9484a4c9b09bd4f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53aa57efa783f3d9484a4c9b09bd4f70">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заполнение буфера строки с помощью функтора. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- начальная позиция для заполнения. </td></tr>
    <tr><td class="paramname">fillFunction</td><td>- size_t(K*, size_t) функтор, получающий адрес буфера строки и его ёмкость, возвращающий необходимый размер строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>Функция вызывает функтор, передавая ему адрес буфера строки и его ёмкость. Функтор может изменять буфер в пределах выделенной ёмкости, и должен вернуть размер итоговой строки. Пока возвращаемый размер больше ёмкости (т.е. строка не может поместиться в буфер), выделятся память как минимум возвращенного размера, и функтор вызывается снова. До тех пор, пока возвращённый размер не будет помещаться в буфер строки. Этот размер и становится длиной строки. </p>

</div>
</div>
<a id="a129d72cc64be6029f10bbe1f8385f3ea" name="a129d72cc64be6029f10bbe1f8385f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129d72cc64be6029f10bbe1f8385f3ea">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти символ в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- искомый символ. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного символа, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="ab38e5cc7893a20e69cdf03d88232b49c" name="ab38e5cc7893a20e69cdf03d88232b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38e5cc7893a20e69cdf03d88232b49c">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало первого вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или -1, если не найдена. </dd></dl>

</div>
</div>
<a id="aa6d568443f3ed5752279098b9a488655" name="aa6d568443f3ed5752279098b9a488655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d568443f3ed5752279098b9a488655">&#9670;&#160;</a></span>find_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти все вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая подстрока. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество обрабатываемых вхождений, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::vector&lt;size_t&gt; - вектор с позициями начал найденных вхождений. </dd></dl>

</div>
</div>
<a id="a8bcde5878d3d7fd5138d38ff2f1df4d2" name="a8bcde5878d3d7fd5138d38ff2f1df4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcde5878d3d7fd5138d38ff2f1df4d2">&#9670;&#160;</a></span>find_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти конец вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию сразу за вхождением подстроки, или -1, если не найдена. </dd></dl>

</div>
</div>
<a id="aab67ba06c8637f93984e45cf349c3eb8" name="aab67ba06c8637f93984e45cf349c3eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab67ba06c8637f93984e45cf349c3eb8">&#9670;&#160;</a></span>find_end_of_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_end_of_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти конец последнего вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию сразу за последним вхождением подстроки, или -1, если не найдена. </dd></dl>

</div>
</div>
<a id="ae281c63da2d81ef8aac65a2dad77eb93" name="ae281c63da2d81ef8aac65a2dad77eb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae281c63da2d81ef8aac65a2dad77eb93">&#9670;&#160;</a></span>find_end_of_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_end_of_last_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти конец последнего вхождения подстроки в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию сразу за последним вхождением подстроки, или длину строки, если не найдена. </dd></dl>

</div>
</div>
<a id="a2c56c3345019c8d5dc20717092d52101" name="a2c56c3345019c8d5dc20717092d52101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c56c3345019c8d5dc20717092d52101">&#9670;&#160;</a></span>find_end_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_end_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти конец первого вхождения подстроки в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию сразу за вхождением подстроки, или длину строки, если не найдена. </dd></dl>

</div>
</div>
<a id="a63ff5e918afcc8e1fba9a3ec19c47897" name="a63ff5e918afcc8e1fba9a3ec19c47897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff5e918afcc8e1fba9a3ec19c47897">&#9670;&#160;</a></span>find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти первое вхождение символа не из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного вхождения, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a643bf839edef0abbd43c3f3654e8e700" name="a643bf839edef0abbd43c3f3654e8e700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bf839edef0abbd43c3f3654e8e700">&#9670;&#160;</a></span>find_first_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти первое вхождение символа из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор искомых символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного вхождения, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="aad5ad9c702f21003a272469cb1edcbf3" name="aad5ad9c702f21003a272469cb1edcbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5ad9c702f21003a272469cb1edcbf3">&#9670;&#160;</a></span>find_first_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_first_of_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти первое вхождение символа из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор искомых символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::pair&lt;size_t, size_t&gt; - пару из позиции найденного вхождения и номера найденного символа в наборе, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a0564461ab81bfbb6c5bd8b4c7e5a496e" name="a0564461ab81bfbb6c5bd8b4c7e5a496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0564461ab81bfbb6c5bd8b4c7e5a496e">&#9670;&#160;</a></span>find_last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти последнее вхождения символа в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- искомый символ. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного символа, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a72a2c0b10e857c245f67a2abd7c1a2f0" name="a72a2c0b10e857c245f67a2abd7c1a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a2c0b10e857c245f67a2abd7c1a2f0">&#9670;&#160;</a></span>find_last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало последнего вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или -1, если не найдена. </dd></dl>

</div>
</div>
<a id="a775a7c8e218ab3223f0248f225076b7c" name="a775a7c8e218ab3223f0248f225076b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775a7c8e218ab3223f0248f225076b7c">&#9670;&#160;</a></span>find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти последнее вхождение символа не из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного вхождения, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a73806fa93c9ec619ba93d479d413ea0f" name="a73806fa93c9ec619ba93d479d413ea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73806fa93c9ec619ba93d479d413ea0f">&#9670;&#160;</a></span>find_last_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти последнее вхождение символа из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор искомых символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного вхождения, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="ab630d62252bf1210f573a8c7222942c8" name="ab630d62252bf1210f573a8c7222942c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab630d62252bf1210f573a8c7222942c8">&#9670;&#160;</a></span>find_last_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last_of_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти последнее вхождение символа из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор искомых символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::pair&lt;size_t, size_t&gt; - пару из позиции найденного вхождения и номера найденного символа в наборе, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a6a5bdd0e7ab4f7e64e1e776f4dabe11c" name="a6a5bdd0e7ab4f7e64e1e776f4dabe11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5bdd0e7ab4f7e64e1e776f4dabe11c">&#9670;&#160;</a></span>find_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_last_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало последнего вхождения подстроки в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или длину строки, если не найдена. </dd></dl>

</div>
</div>
<a id="a762c55d09b34ba2b7b5f9f10783da662" name="a762c55d09b34ba2b7b5f9f10783da662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762c55d09b34ba2b7b5f9f10783da662">&#9670;&#160;</a></span>find_or_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти символ в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- искомый символ. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного символа, или длину строки, если не найден. </dd></dl>

</div>
</div>
<a id="ac029fd5412ed114bfefbdddba2c50167" name="ac029fd5412ed114bfefbdddba2c50167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac029fd5412ed114bfefbdddba2c50167">&#9670;&#160;</a></span>find_or_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало первого вхождения подстроки в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или длину строки, если не найдена. </dd></dl>

</div>
</div>
<a id="a40ab0482ea5f02bc0c3097bed6c9a5fa" name="a40ab0482ea5f02bc0c3097bed6c9a5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab0482ea5f02bc0c3097bed6c9a5fa">&#9670;&#160;</a></span>find_or_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::find_or_throw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало первого вхождения подстроки в этой строке или выкинуть исключение. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exc</td><td>- тип исключения. </td></tr>
    <tr><td class="paramname">Args...</td><td>- типы параметров для конструирования исключения, выводятся из аргументов. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
    <tr><td class="paramname">args</td><td>- аргументы для конструктора исключения. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или выбрасывает исключение Exc, если не найдена. </dd></dl>

</div>
</div>
<a id="a8185ccf8fc2297b628cce3c83b6a0b4c" name="a8185ccf8fc2297b628cce3c83b6a0b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8185ccf8fc2297b628cce3c83b6a0b4c">&#9670;&#160;</a></span>for_all_finded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::for_all_finded </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Вызвать функтор для всех найденных вхождений подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>- функтор, принимающий строку. </td></tr>
    <tr><td class="paramname">pattern</td><td>- искомая подстрока. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество обрабатываемых вхождений, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bfceeaa8961165845fa25fc652e31b0" name="a3bfceeaa8961165845fa25fc652e31b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfceeaa8961165845fa25fc652e31b0">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::format </td>
          <td>(</td>
          <td class="paramtype">const FmtString&lt; fmt_type, T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Форматирует строку с помощью std::format. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- форматная строка, константная. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для std::format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="ae8ca9bf60dd607b6b8721ec84abba5d5" name="ae8ca9bf60dd607b6b8721ec84abba5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ca9bf60dd607b6b8721ec84abba5d5">&#9670;&#160;</a></span>format_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::format_from </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FmtString&lt; fmt_type, T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавляет отформатированный с помощью std::format вывод, начиная с указанной позиции. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- начальная позиция добавления. </td></tr>
    <tr><td class="paramname">format</td><td>- форматная строка, константная. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для std::format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="a5659e7fb47dfb6bd6736a1b454ffde92" name="a5659e7fb47dfb6bd6736a1b454ffde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5659e7fb47dfb6bd6736a1b454ffde92">&#9670;&#160;</a></span>from_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::from_to </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить подстроку <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a> с позиции от from до позиции to (не включая её). </p>
<p>Для производительности метод никак не проверяет выходы за границы строки, используйте в сценариях, когда точно знаете, что это позиции внутри строки и to &gt;= from. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- начальная позиция. </td></tr>
    <tr><td class="paramname">to</td><td>- конечная позиция (не входит в результат). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Подстроку, <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a4116dbd55a53014cef88f4f571cb0c64" name="a4116dbd55a53014cef88f4f571cb0c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4116dbd55a53014cef88f4f571cb0c64">&#9670;&#160;</a></span>init_from_str_other()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_from_str_other </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Инициализация из другого строкового объекта. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другой строковый объект, <a class="el" href="structsimstr_1_1simple__str.html" title="Простейший класс иммутабельной не владеющей строки.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1090a808b0e761a7ecff753d80faebba" name="a1090a808b0e761a7ecff753d80faebba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1090a808b0e761a7ecff753d80faebba">&#9670;&#160;</a></span>init_replaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_replaced </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Инициализация из строкового источника с заменой. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- строковый объект, из которого берётся исходная строка. </td></tr>
    <tr><td class="paramname">pattern</td><td>- подстрока, которую надо заменить. </td></tr>
    <tr><td class="paramname">repl</td><td>- строка, на которую надо заменить. </td></tr>
    <tr><td class="paramname">offset</td><td>- начальная позиция для поиска подстрок. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество замен, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d6ca99606646e8a2fb07f5808dae999" name="a5d6ca99606646e8a2fb07f5808dae999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6ca99606646e8a2fb07f5808dae999">&#9670;&#160;</a></span>init_str_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_str_expr </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Инициализация из строкового выражения. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- строковое выражение.</td></tr>
  </table>
  </dd>
</dl>
<p>Запрашивает у строкового выражения <code><a class="el" href="#a4e9a64c776ee14ef49bb01e84eb87889" title="Длина строки.">length()</a></code>, выделяет память нужного размера, и вызывает метод <code><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place()</a></code> для размещения результата в буфере. </p>

</div>
</div>
<a id="a92e0afaaca95e435c77ecc4ab3f26b8d" name="a92e0afaaca95e435c77ecc4ab3f26b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e0afaaca95e435c77ecc4ab3f26b8d">&#9670;&#160;</a></span>init_str_repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_str_repeat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>repeat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Инициализация повторением строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeat</td><td>- количество повторов. </td></tr>
    <tr><td class="paramname">pattern</td><td>- строка, которую надо повторить. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d5032575e4c90cdb9a8bcd0aa8c735" name="a47d5032575e4c90cdb9a8bcd0aa8c735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d5032575e4c90cdb9a8bcd0aa8c735">&#9670;&#160;</a></span>init_symb_repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::init_symb_repeat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>pad</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Инициализация повторением символа. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>- количество повторов. </td></tr>
    <tr><td class="paramname">pad</td><td>- символ, который надо повторить. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01abc4c1daa39bb99451be642dc86f48" name="a01abc4c1daa39bb99451be642dc86f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01abc4c1daa39bb99451be642dc86f48">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Вставить строковое выражение в указанную позицию. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>- позиция для вставки. </td></tr>
    <tr><td class="paramname">expr</td><td>- строковое выражение. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a81a87ca9286d27c944b0453df89e7f92" name="a81a87ca9286d27c944b0453df89e7f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a87ca9286d27c944b0453df89e7f92">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Вставить строку в указанную позицию. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>- позиция для вставки. </td></tr>
    <tr><td class="paramname">other</td><td>- вставляемая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a9b002a3618bbfcebc945cef197a397a1" name="a9b002a3618bbfcebc945cef197a397a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b002a3618bbfcebc945cef197a397a1">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>strings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tail</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_empty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конкатенация строк из контейнера в одну строку. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>- контейнер со строками. </td></tr>
    <tr><td class="paramname">delimiter</td><td>- разделитель, добавляемый между строками. </td></tr>
    <tr><td class="paramname">tail</td><td>- добавить разделитель после последней строки. </td></tr>
    <tr><td class="paramname">skip_empty</td><td>- пропускать пустые строки без добавления разделителя. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора.</td></tr>
  </table>
  </dd>
</dl>
<p>Функция служит для слияния контейнера строк в одну строку с разделителем. </p><div class="fragment"><div class="line">std::vector&lt;ssa&gt; strings = get_strings();</div>
<div class="line">ssa delim = get_current_delimiter();</div>
<div class="line"><span class="keyword">auto</span> line = <a class="code hl_function" href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">lstringa&lt;200&gt;::join</a>(strings, delimiter);</div>
<div class="ttc" id="aclasssimstr_1_1str__storable_html_a9b002a3618bbfcebc945cef197a397a1"><div class="ttname"><a href="classsimstr_1_1str__storable.html#a9b002a3618bbfcebc945cef197a397a1">simstr::lstring&lt; u8s, N &gt;::join</a></div><div class="ttdeci">static my_type join(const T &amp;strings, s_str delimiter, bool tail=false, bool skip_empty=false, Args &amp;&amp;... args)</div><div class="ttdef"><b>Определения</b> sstring.h:1106</div></div>
</div><!-- fragment --><p> Стоит отметить, что при заранее известном разделителе лучше пользоваться строковым выражением <code>e_join</code>. </p><div class="fragment"><div class="line">std::vector&lt;ssa&gt; strings = get_strings();</div>
<div class="line">lstringa&lt;200&gt; line{<a class="code hl_function" href="group___str_exprs.html#gafd2e6b8a52bfe20c0b86d25f9f78cb52">e_join</a>(strings, <span class="stringliteral">&quot;/&quot;</span>)};</div>
<div class="ttc" id="agroup___str_exprs_html_gafd2e6b8a52bfe20c0b86d25f9f78cb52"><div class="ttname"><a href="group___str_exprs.html#gafd2e6b8a52bfe20c0b86d25f9f78cb52">simstr::e_join</a></div><div class="ttdeci">constexpr auto e_join(const T &amp;s, L &amp;&amp;d)</div><div class="ttdoc">Получить строковое выражение, конкатенирующее строки в контейнере в одну строку с заданным разделител...</div><div class="ttdef"><b>Определения</b> strexpr.h:2801</div></div>
</div><!-- fragment --><p> В этом случае компилятор может лучше оптимизировать код слияния строк. </p>

</div>
</div>
<a id="a44ede528e694988f26555e91cf9a1ca2" name="a44ede528e694988f26555e91cf9a1ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ede528e694988f26555e91cf9a1ca2">&#9670;&#160;</a></span>less_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::less_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Меньше ли строка другой строки посимвольно без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>меньше ли строка. </dd></dl>

</div>
</div>
<a id="a4e79e99462478b57d62873f7942ff2b6" name="a4e79e99462478b57d62873f7942ff2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79e99462478b57d62873f7942ff2b6">&#9670;&#160;</a></span>less_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::less_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Меньше ли строка другой строки посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>меньше ли строка. </dd></dl>

</div>
</div>
<a id="ac0c4239efb3b35bfcb99b61feff08156" name="ac0c4239efb3b35bfcb99b61feff08156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c4239efb3b35bfcb99b61feff08156">&#9670;&#160;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать в нижний регистр Unicode символы первой плоскости (&lt;0xFFFF). </p>
<p>Регистр меняется упрощенными таблицами, где один code_point всегда меняется в один code_point (но для UTF-8 возможно, что длина в code unit'ах изменится). </p><dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a21f5a8e01bd18d94b873390bdd5eee8d" name="a21f5a8e01bd18d94b873390bdd5eee8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f5a8e01bd18d94b873390bdd5eee8d">&#9670;&#160;</a></span>lower_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::lower_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать в нижний регистр ASCII символы. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a8d51ac2887746e40214eeee7d52460f4" name="a8d51ac2887746e40214eeee7d52460f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d51ac2887746e40214eeee7d52460f4">&#9670;&#160;</a></span>lowered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::lowered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки в нижнем регистре Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - копию строки в нижнем регистре. </dd></dl>

</div>
</div>
<a id="a7946e4e405f908fd85c896bd75f67d72" name="a7946e4e405f908fd85c896bd75f67d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7946e4e405f908fd85c896bd75f67d72">&#9670;&#160;</a></span>lowered_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::lowered_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Создать копию переданной строки в нижнем регистре символов Unicode первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- строка источник. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора.</td></tr>
  </table>
  </dd>
</dl>
<p>Регистр меняется упрощенными таблицами, где один code_point всегда меняется в один code_point (но для UTF-8 возможно, что длина в code unit'ах изменится). </p>

</div>
</div>
<a id="ad2f36df5ff2422e43919e74d965f24a4" name="ad2f36df5ff2422e43919e74d965f24a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f36df5ff2422e43919e74d965f24a4">&#9670;&#160;</a></span>lowered_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::lowered_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки в нижнем регистре ASCII символов. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - копию строки в нижнем регистре. </dd></dl>

</div>
</div>
<a id="a95c800534b214e4473b6f59c3d761dc4" name="a95c800534b214e4473b6f59c3d761dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c800534b214e4473b6f59c3d761dc4">&#9670;&#160;</a></span>lowered_only_ascii_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::lowered_only_ascii_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Создать копию переданной строки в нижнем регистре символов ASCII. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- строка источник. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a507a43e6ebcc51e6409874712abbbd63" name="a507a43e6ebcc51e6409874712abbbd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507a43e6ebcc51e6409874712abbbd63">&#9670;&#160;</a></span>mid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить часть строки как "кусок строки". </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- количество символов от начала строки. При превышении размера строки вернёт пустую строку. </td></tr>
    <tr><td class="paramname">len</td><td>- количество символов в получаемом "куске". При выходе за пределы строки вернёт всё до конца строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Подстроку, <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </dd></dl>

</div>
</div>
<a id="af93a700258bc7492e53ceb2acf414315" name="af93a700258bc7492e53ceb2acf414315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93a700258bc7492e53ceb2acf414315">&#9670;&#160;</a></span>operator const K *()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::operator const K * </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор преобразования в нуль-терминированную C-строку. </p>
<dl class="section return"><dt>Возвращает</dt><dd>const K* - указатель на начало строки. </dd></dl>

</div>
</div>
<a id="a32cb440524f81da0e00cfa303cb4fab6" name="a32cb440524f81da0e00cfa303cb4fab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cb440524f81da0e00cfa303cb4fab6">&#9670;&#160;</a></span>operator K*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator K* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить указатель на буфер строки. </p>
<dl class="section return"><dt>Возвращает</dt><dd>K* - указатель на буфер строки. </dd></dl>

</div>
</div>
<a id="abcae77eab91707d4b3fa578dde83d34a" name="abcae77eab91707d4b3fa578dde83d34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcae77eab91707d4b3fa578dde83d34a">&#9670;&#160;</a></span>operator s_str_nt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::operator <a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать в <a class="el" href="structsimstr_1_1simple__str__nt.html" title="Класс, заявляющий, что ссылается на нуль-терминированную строку.">simple_str_nt</a>. </p>
<dl class="section return"><dt>Возвращает</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="Класс, заявляющий, что ссылается на нуль-терминированную строку.">simple_str_nt</a>. </dd></dl>

</div>
</div>
<a id="a9959513e8a072c51620248c4a29f4196" name="a9959513e8a072c51620248c4a29f4196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9959513e8a072c51620248c4a29f4196">&#9670;&#160;</a></span>operator std::basic_string&lt; D, Traits, Allocator &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator std::basic_string&lt; D, Traits, Allocator &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конвертировать в std::basic_string. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="ab4c6b4c365f05e609a7b22cbf37b39c6" name="ab4c6b4c365f05e609a7b22cbf37b39c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c6b4c365f05e609a7b22cbf37b39c6">&#9670;&#160;</a></span>operator std::basic_string_view&lt; D, Traits &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator std::basic_string_view&lt; D, Traits &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конвертировать в std::basic_string_view. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a916218a7a75a3866a9d3d0da9334653c" name="a916218a7a75a3866a9d3d0da9334653c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916218a7a75a3866a9d3d0da9334653c">&#9670;&#160;</a></span>operator str_piece()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать себя в "кусок строки", включающий всю строку. </p>
<dl class="section return"><dt>Возвращает</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="ace8f275b33545d2491850f49ba3b7876" name="ace8f275b33545d2491850f49ba3b7876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8f275b33545d2491850f49ba3b7876">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить часть строки как "str_src". </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- количество символов от начала строки. </td></tr>
    <tr><td class="paramname">len</td><td>- количество символов в получаемом "куске". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Подстроку, <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>.</dd></dl>
<p>Если <code>from</code> меньше нуля, то отсчитывается <code>-from</code> символов от конца строки в сторону начала. Если <code>len</code> меньше или равно нулю, то отсчитать <code>-len</code> символов от конца строки</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, 2) == <span class="stringliteral">&quot;56&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5) == <span class="stringliteral">&quot;56789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, -1) == <span class="stringliteral">&quot;5678&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3) == <span class="stringliteral">&quot;789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3, 2) == <span class="stringliteral">&quot;78&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-4, -1) == <span class="stringliteral">&quot;678&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afa5514cee68803e4a0a18e648cb5cfc0" name="afa5514cee68803e4a0a18e648cb5cfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5514cee68803e4a0a18e648cb5cfc0">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавить строковое выражение в конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- строковое выражение. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a885c6a5a9ecf6417993824dbb4425af6" name="a885c6a5a9ecf6417993824dbb4425af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885c6a5a9ecf6417993824dbb4425af6">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавить другую строку в конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a4a1cad4ba4af2bdd831580151cb32962" name="a4a1cad4ba4af2bdd831580151cb32962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1cad4ba4af2bdd831580151cb32962">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заполняет строку методом fill с нулевой позиции. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillFunction</td><td>- функтор заполнения строки, size_t(K*, size_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a0a5d59fd9e97d25cc5a9940c19ab796c" name="a0a5d59fd9e97d25cc5a9940c19ab796c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5d59fd9e97d25cc5a9940c19ab796c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Вызывает переданный функтор, передав ссылку на себя. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillFunction</td><td>- фуктор void(my_type&amp;). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a01b1fdf213da8dc5cdaf6211904ee690" name="a01b1fdf213da8dc5cdaf6211904ee690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b1fdf213da8dc5cdaf6211904ee690">&#9670;&#160;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заполняет строку методом fill после конца строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillFunction</td><td>- функтор заполнения строки, size_t(K*, size_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="ac34637c1f071ac6e6faa0237a092cc61" name="ac34637c1f071ac6e6faa0237a092cc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34637c1f071ac6e6faa0237a092cc61">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор сравнения строк. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad63f315c4a97ee6ad1e2b045b9f5f9e0" name="ad63f315c4a97ee6ad1e2b045b9f5f9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63f315c4a97ee6ad1e2b045b9f5f9e0">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор сравнения строки и строкового литерала. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- строковый литерал. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19f351477923bb3ca090955866e4315" name="ab19f351477923bb3ca090955866e4315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19f351477923bb3ca090955866e4315">&#9670;&#160;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор присваивания копией из строки такого же типа. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>my_type&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a895f17a8dd5ef18c2ea0120f785d84cb" name="a895f17a8dd5ef18c2ea0120f785d84cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895f17a8dd5ef18c2ea0120f785d84cb">&#9670;&#160;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const StrExprForType&lt; K &gt; auto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор присваивания строкового выражения. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- строковое выражение, материализуемое в буфер строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>my_type&amp; - ссылку на себя же.</dd></dl>
<p>Если в строковом выражении что-либо ссылается на части этой же строки, то результат не определён. </p>

</div>
</div>
<a id="a44dda5e47ad2a1aba0861c7b1179a2e0" name="a44dda5e47ad2a1aba0861c7b1179a2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dda5e47ad2a1aba0861c7b1179a2e0">&#9670;&#160;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор присваивания перемещением из строки такого же типа. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>my_type&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="ad1dbdd5c648b4b399b4b8c147fc99d43" name="ad1dbdd5c648b4b399b4b8c147fc99d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dbdd5c648b4b399b4b8c147fc99d43">&#9670;&#160;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор присваивания из <a class="el" href="structsimstr_1_1simple__str.html" title="Простейший класс иммутабельной не владеющей строки.">simple_str</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>my_type&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a2731727eb853928098f7051a0dca8995" name="a2731727eb853928098f7051a0dca8995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2731727eb853928098f7051a0dca8995">&#9670;&#160;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t S = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> &amp; <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор присваивания строкового литерала. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- строковый литерал, копируется в буфер строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>my_type&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a1ddd0a1f9b25247465fb55c79b58826d" name="a1ddd0a1f9b25247465fb55c79b58826d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddd0a1f9b25247465fb55c79b58826d">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор сравнение строк на равенство. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>равны ли строки. </dd></dl>

</div>
</div>
<a id="ac19dc728f9d7edafbd85a52e70b46376" name="ac19dc728f9d7edafbd85a52e70b46376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19dc728f9d7edafbd85a52e70b46376">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор сравнения строки и строкового литерала на равенство. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- строковый литерал. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af893677739e0d24418f6acc0a29090cc" name="af893677739e0d24418f6acc0a29090cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af893677739e0d24418f6acc0a29090cc">&#9670;&#160;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::place </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Копировать строку в указанный буфер. </p>
<p>Метод предполагает, что размер выделенного буфера достаточен для всей строки, т.е. предварительно была запрошена <code><a class="el" href="#a4e9a64c776ee14ef49bb01e84eb87889" title="Длина строки.">length()</a></code>. Не добавляет <code>\0</code>. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- указатель на буфер. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>указатель на символ после конца размещённой в буфере строки. </dd></dl>

</div>
</div>
<a id="ae37c68155961c5c7b1609aa1b873b8d3" name="ae37c68155961c5c7b1609aa1b873b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37c68155961c5c7b1609aa1b873b8d3">&#9670;&#160;</a></span>prefix_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::prefix_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Является ли эта строка началом другой строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab2f039d8eb7f384b96ceb0d7f55cf7c" name="aab2f039d8eb7f384b96ceb0d7f55cf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2f039d8eb7f384b96ceb0d7f55cf7c">&#9670;&#160;</a></span>prepend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавить строковое выражение в начало строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>- строковое выражение. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a37c3fa40f6a3f82eb83e0b7c61f1a0fd" name="a37c3fa40f6a3f82eb83e0b7c61f1a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c3fa40f6a3f82eb83e0b7c61f1a0fd">&#9670;&#160;</a></span>prepend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавить другую строку в начало строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a3f4c37cfab5e6a48dd47c8e7754e6530" name="a3f4c37cfab5e6a48dd47c8e7754e6530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4c37cfab5e6a48dd47c8e7754e6530">&#9670;&#160;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::printf </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Форматирует строку помощью sprintf. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- форматная строка. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для sprintf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="a875205d5df5bc2d8b825ba8edd79b22a" name="a875205d5df5bc2d8b825ba8edd79b22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875205d5df5bc2d8b825ba8edd79b22a">&#9670;&#160;</a></span>printf_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::printf_from </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавляет отформатированный с помощью sprintf вывод, начиная с указанной позиции. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- начальная позиция добавления. </td></tr>
    <tr><td class="paramname">format</td><td>- форматная строка. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для sprintf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="a5eb2a4a250dc0fe4c7c71ecd51745259" name="a5eb2a4a250dc0fe4c7c71ecd51745259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb2a4a250dc0fe4c7c71ecd51745259">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить часть строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- позиция, с которой удалить. </td></tr>
    <tr><td class="paramname">len</td><td>- длина удаляемой части. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="ac0ee55594becb6b2c2b98df722cc7a33" name="ac0ee55594becb6b2c2b98df722cc7a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ee55594becb6b2c2b98df722cc7a33">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заменить вхождения подстроки на другую строку. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая подстрока. </td></tr>
    <tr><td class="paramname">repl</td><td>- строка замены. </td></tr>
    <tr><td class="paramname">offset</td><td>- начальная позиция для поиска. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество замен, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="ad86b3a4c468f51e3ab3f7ba9e8786f9f" name="ad86b3a4c468f51e3ab3f7ba9e8786f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86b3a4c468f51e3ab3f7ba9e8786f9f">&#9670;&#160;</a></span>replace_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::replace_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Скопировать строку-источник, заменив вхождения подстрок на другую строку. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- строка-источник. </td></tr>
    <tr><td class="paramname">pattern</td><td>- искомая подстрока. </td></tr>
    <tr><td class="paramname">repl</td><td>- строка замены. </td></tr>
    <tr><td class="paramname">offset</td><td>- начальная позиция для поиска. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество замен, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a606b0373189a0fb89bce3801e972e46a" name="a606b0373189a0fb89bce3801e972e46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606b0373189a0fb89bce3801e972e46a">&#9670;&#160;</a></span>replaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::replaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки с заменёнными вхождениями подстрок. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая подстрока. </td></tr>
    <tr><td class="paramname">repl</td><td>- строка, на которую заменять. </td></tr>
    <tr><td class="paramname">offset</td><td>- начальная позиция поиска. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество замен, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R строку заданного типа, по умолчанию того же, чей метод вызывался. </dd></dl>

</div>
</div>
<a id="aafdcc9ae62c73be2c37e4a40c3366ded" name="aafdcc9ae62c73be2c37e4a40c3366ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdcc9ae62c73be2c37e4a40c3366ded">&#9670;&#160;</a></span>replaced_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::replaced_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">s_str</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Создать копию переданной строки с заменой подстрок. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- строка источник. </td></tr>
    <tr><td class="paramname">pattern</td><td>- подстрока, которую надо заменить. </td></tr>
    <tr><td class="paramname">repl</td><td>- строка, на которую надо заменить. </td></tr>
    <tr><td class="paramname">offset</td><td>- начальная позиция для поиска подстрок. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество замен, 0 - без ограничений. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9b8b36c694de6015158b41d597e7551" name="ae9b8b36c694de6015158b41d597e7551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b8b36c694de6015158b41d597e7551">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Выделить буфер, достаточный для размещения newSize символов плюс завершающий ноль. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>- новый размер строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>K* - указатель на буфер.</dd></dl>
<p>Содержимое строки сохраняется. При увеличении буфера размер выделяется не больше запрошенного. Размер строки устанавливается в newSize. </p>

</div>
</div>
<a id="aa0c80a142e77e0927ab5a17a17ff5ef7" name="aa0c80a142e77e0927ab5a17a17ff5ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c80a142e77e0927ab5a17a17ff5ef7">&#9670;&#160;</a></span>reserve_no_preserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::reserve_no_preserve </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Выделить буфер, достаточный для размещения newSize символов плюс завершающий ноль. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>- новый размер строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>K* - указатель на буфер.</dd></dl>
<p>Содержимое буфера не определено, и не гарантируется сохранение старого содержимого. Размер строки устанавливается в newSize. </p>

</div>
</div>
<a id="abc32346401f3c9db8cee093b193524e7" name="abc32346401f3c9db8cee093b193524e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc32346401f3c9db8cee093b193524e7">&#9670;&#160;</a></span>set_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, size_t N, bool forShared = false, Allocatorable Allocator = allocator_string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1lstring.html">simstr::lstring</a>&lt; K, N, forShared, Allocator &gt;::set_size </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Устанавливает размер текущей строки, при необходимости выделяя место. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>- новый размер строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>K* - указатель на буфер.</dd></dl>
<p>Содержимое строки сохраняется. При увеличении буфера размер выделяется не менее чем 2 старого размера буфера. Размер строки устанавливается в newSize. </p>

</div>
</div>
<a id="aa2732ccf421fcd1ba606addcca7e6e42" name="aa2732ccf421fcd1ba606addcca7e6e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2732ccf421fcd1ba606addcca7e6e42">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Размер строки в символах. </p>
<dl class="section return"><dt>Возвращает</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="a4ad7e9416ed3abc8689034463f497e6b" name="a4ad7e9416ed3abc8689034463f497e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad7e9416ed3abc8689034463f497e6b">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Разделить строку на подстроки по заданному разделителю. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- тип контейнера для результата. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- разделитель. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска разделителя. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>T - контейнер с результатом. </dd></dl>

</div>
</div>
<a id="adffb295777b82a1475a4fc0d9754481b" name="adffb295777b82a1475a4fc0d9754481b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffb295777b82a1475a4fc0d9754481b">&#9670;&#160;</a></span>splitf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::splitf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>beforeFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Разделить строку на части по заданному разделителю, с возможным применением функтора к каждой подстроке. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- тип контейнера для складывания подстрок. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- подстрока разделитель. </td></tr>
    <tr><td class="paramname">beforeFunc</td><td>- функтор для применения к найденным подстрокам, перед помещением их в результат. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска разделителя. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>T - результат.</dd></dl>
<p>Для каждой найденной подстроки, если функтор может принять её, вызывается функтор, и подстрока присваивается результату функтора. Далее подстрока пытается добавиться в результат, вызывая один из его методов - <code>emplace_back</code>, <code>push_back</code>, <code>operator[]</code>. Если ни одного этого метода нет, ничего не делается, только вызов функтора. <code>operator[]</code> пытается применится, если у результата можно получить размер через <code>std::size</code> и мы не выходим за этот размер. При этом, если найденная подстрока получается совпадающей со всей строкой - в результат пытается поместить не подстроку, а весь объект строки, что позволяет, например, эффективно копировать sstring. </p>

</div>
</div>
<a id="ab3f6c202d1c1723297d46a45d82c5808" name="ab3f6c202d1c1723297d46a45d82c5808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6c202d1c1723297d46a45d82c5808">&#9670;&#160;</a></span>splitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::splitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить объект <code>Splitter</code> по заданному разделителю, который позволяет последовательно получать подстроки методом <code>next()</code>, пока <code>is_done()</code> false. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- разделитель. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Splitter&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a2febfef44dabdf863a74db2049410e9f" name="a2febfef44dabdf863a74db2049410e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2febfef44dabdf863a74db2049410e9f">&#9670;&#160;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Начинается ли строка с заданной подстроки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9409e48b2f182546b7f7186af2477e" name="a6d9409e48b2f182546b7f7186af2477e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9409e48b2f182546b7f7186af2477e">&#9670;&#160;</a></span>starts_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::starts_with_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Начинается ли строка с заданной подстроки без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26465c7fdac87e8d215e836bdbf6e8c3" name="a26465c7fdac87e8d215e836bdbf6e8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26465c7fdac87e8d215e836bdbf6e8c3">&#9670;&#160;</a></span>starts_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::starts_with_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Начинается ли строка с заданной подстроки без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa77c31da012cf5cc23e0a60c1888cec2" name="aa77c31da012cf5cc23e0a60c1888cec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77c31da012cf5cc23e0a60c1888cec2">&#9670;&#160;</a></span>str_mid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::str_mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить часть строки объектом того же типа, к которому применён метод, аналогично mid. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- количество символов от начала строки. При превышении размера строки вернёт пустую строку. </td></tr>
    <tr><td class="paramname">len</td><td>- количество символов в получаемом "куске". При выходе за пределы строки вернёт всё до конца строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Строку того же типа, к которому применён метод. </dd></dl>

</div>
</div>
<a id="a610d501d16ab38c3efb1427f14ea7f67" name="a610d501d16ab38c3efb1427f14ea7f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d501d16ab38c3efb1427f14ea7f67">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::strcmp </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение с C-строкой посимвольно. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>&lt;0 эта строка меньше, ==0 - строки равны, &gt;0 - эта строка больше. </dd></dl>

</div>
</div>
<a id="a512eaf3c2c8736f3021a5bbe60823866" name="a512eaf3c2c8736f3021a5bbe60823866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512eaf3c2c8736f3021a5bbe60823866">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить подстроку. Работает аналогично operator(), только результат выдает того же типа, к которому применён метод. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- количество символов от начала строки. Если меньше нуля, отсчитывается от конца строки в сторону начала. </td></tr>
    <tr><td class="paramname">len</td><td>- количество символов в получаемом "куске". Если меньше или равно нулю, то отсчитать len символов от конца строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>my_type - подстроку, объект того же типа, к которому применён метод. </dd></dl>

</div>
</div>
<a id="aa1af52e61e73c687a34ff6978304edc3" name="aa1af52e61e73c687a34ff6978304edc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af52e61e73c687a34ff6978304edc3">&#9670;&#160;</a></span>to_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_double </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в double. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="a037d07ad0ee024d983927cec3ee81908" name="a037d07ad0ee024d983927cec3ee81908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037d07ad0ee024d983927cec3ee81908">&#9670;&#160;</a></span>to_double_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_double_hex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в 16ричной записи в double. Пока работает только для char. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="afa40ca4ad70df9ec0941599b88c443dc" name="afa40ca4ad70df9ec0941599b88c443dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa40ca4ad70df9ec0941599b88c443dc">&#9670;&#160;</a></span>to_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">convert_result&lt; T &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в число заданного типа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- желаемый тип числа. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- проверять на переполнение. </td></tr>
    <tr><td class="paramname">Base</td><td>- основание счисления числа, от -1 до 36, кроме 1.<ul>
<li>Если 0: то пытается определить основание по префиксу 0[xX] как 16, 0 как 8, иначе 10</li>
<li>Если -1: то пытается определить основание по префиксам:<ul>
<li>0 или 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
<li>в остальных случаях 10. </li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- пропускать пробельные символы в начале строки. Пропускаются все символы с ASCII кодами &lt;= 32. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- допустим ли знак '+' перед числом. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>convert_result&lt;T&gt; - кортеж из полученного числа, успешности преобразования и количестве обработанных символов. </dd></dl>

</div>
</div>
<a id="aed242dbe057042c9f72f9514aaf861ee" name="aed242dbe057042c9f72f9514aaf861ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed242dbe057042c9f72f9514aaf861ee">&#9670;&#160;</a></span>to_nts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">s_str_nt</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::to_nts </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить <a class="el" href="structsimstr_1_1simple__str__nt.html" title="Класс, заявляющий, что ссылается на нуль-терминированную строку.">simple_str_nt</a>, начиная с заданного символа. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- позиция начального символа, по умолчанию 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd><a class="el" href="structsimstr_1_1simple__str__nt.html" title="Класс, заявляющий, что ссылается на нуль-терминированную строку.">simple_str_nt</a>, </dd></dl>

</div>
</div>
<a id="a53d19b3fba03bfd481d2a3b3def766af" name="a53d19b3fba03bfd481d2a3b3def766af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d19b3fba03bfd481d2a3b3def766af">&#9670;&#160;</a></span>to_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать себя в "кусок строки", включающий всю строку. </p>
<dl class="section return"><dt>Возвращает</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="adc816f095922a510dfe466db1905fc63" name="adc816f095922a510dfe466db1905fc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc816f095922a510dfe466db1905fc63">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; D, Traits, Allocator &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конвертировать в std::basic_string. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a1f2af1ee80a32a77ad30cffbf6987107" name="a1f2af1ee80a32a77ad30cffbf6987107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2af1ee80a32a77ad30cffbf6987107">&#9670;&#160;</a></span>to_sv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string_view&lt; D &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::to_sv </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конвертировать в std::basic_string_view. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="ab697bf9b655f0ed7762ee830efb25b18" name="ab697bf9b655f0ed7762ee830efb25b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab697bf9b655f0ed7762ee830efb25b18">&#9670;&#160;</a></span>trim() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить пробельные символы в начале и в конце строки. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a14ae0d5f1aef083fc2c84274cd794c74" name="a14ae0d5f1aef083fc2c84274cd794c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ae0d5f1aef083fc2c84274cd794c74">&#9670;&#160;</a></span>trim() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в переданную строку, в начале и в конце строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, содержащая символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="af25c5f127c99392c53470f0a9919b504" name="af25c5f127c99392c53470f0a9919b504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25c5f127c99392c53470f0a9919b504">&#9670;&#160;</a></span>trim() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в строковый литерал, в начале и в конце строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, содержащий символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a244334bd105c03fa510804b31707996f" name="a244334bd105c03fa510804b31707996f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244334bd105c03fa510804b31707996f">&#9670;&#160;</a></span>trim_left() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить пробельные символы в начале строки. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a2e26d84497e19b7bbfd83da9cc593310" name="a2e26d84497e19b7bbfd83da9cc593310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e26d84497e19b7bbfd83da9cc593310">&#9670;&#160;</a></span>trim_left() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в переданную строку, в начале строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, содержащая символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a65b013501c10698abf323333d17ab2ac" name="a65b013501c10698abf323333d17ab2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b013501c10698abf323333d17ab2ac">&#9670;&#160;</a></span>trim_left() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в строковый литерал, в начале строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, содержащий символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a7ff45375785f56489e1e6d8f9d978120" name="a7ff45375785f56489e1e6d8f9d978120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff45375785f56489e1e6d8f9d978120">&#9670;&#160;</a></span>trim_left_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в переданную строку, а также пробельные символы, в начале строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, содержащая символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a5f668bb7ec9de3acf40727167787e630" name="a5f668bb7ec9de3acf40727167787e630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f668bb7ec9de3acf40727167787e630">&#9670;&#160;</a></span>trim_left_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в строковый литерал, а также пробельные символы, в начале строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, содержащий символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a8a8daf67d09761a0834881d00562596f" name="a8a8daf67d09761a0834881d00562596f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8daf67d09761a0834881d00562596f">&#9670;&#160;</a></span>trim_right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить пробельные символы в конце строки. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a8c100b87423b8c6261c8c2d16cd82194" name="a8c100b87423b8c6261c8c2d16cd82194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c100b87423b8c6261c8c2d16cd82194">&#9670;&#160;</a></span>trim_right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в переданную строку, в конце строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, содержащая символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a73083ad3987d977364c90a9a80a1509f" name="a73083ad3987d977364c90a9a80a1509f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73083ad3987d977364c90a9a80a1509f">&#9670;&#160;</a></span>trim_right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в строковый литерал, в конце строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, содержащий символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a73428dd849aa12f674ece721e067ccb9" name="a73428dd849aa12f674ece721e067ccb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73428dd849aa12f674ece721e067ccb9">&#9670;&#160;</a></span>trim_right_with_spaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в переданную строку, а также пробельные символы, в конце строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, содержащая символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a2c59b83d60ff726a3ec9a9aeb1ae404b" name="a2c59b83d60ff726a3ec9a9aeb1ae404b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c59b83d60ff726a3ec9a9aeb1ae404b">&#9670;&#160;</a></span>trim_right_with_wpaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_right_with_wpaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в строковый литерал, а также пробельные символы, в конце строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, содержащий символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a8e8bfc1561a193de117800effb3bbc7d" name="a8e8bfc1561a193de117800effb3bbc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8bfc1561a193de117800effb3bbc7d">&#9670;&#160;</a></span>trim_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в переданную строку, а также пробельные символы, в начале и в конце строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, содержащая символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a3240c4342cc4fa0de4126d1446501647" name="a3240c4342cc4fa0de4126d1446501647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3240c4342cc4fa0de4126d1446501647">&#9670;&#160;</a></span>trim_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::trim_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Удалить символы, входящие в строковый литерал, а также пробельные символы, в начале и в конце строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, содержащий символы, которые надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a9bded9dcb3da163cf73d690dd63a73d4" name="a9bded9dcb3da163cf73d690dd63a73d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bded9dcb3da163cf73d690dd63a73d4">&#9670;&#160;</a></span>trimmed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением пробельных символов слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце пробельными символами. </dd></dl>

</div>
</div>
<a id="a16e8b3bad27529f5033fee8985dbec7d" name="a16e8b3bad27529f5033fee8985dbec7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e8b3bad27529f5033fee8985dbec7d">&#9670;&#160;</a></span>trimmed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце символами, содержащимися в шаблоне. </dd></dl>

</div>
</div>
<a id="a9b9958a7ba764ec2ee03fd5f205e3bcd" name="a9b9958a7ba764ec2ee03fd5f205e3bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9958a7ba764ec2ee03fd5f205e3bcd">&#9670;&#160;</a></span>trimmed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце символами, содержащимися в литерале. </dd></dl>

</div>
</div>
<a id="a25d2652007aef40826102fb153134c4d" name="a25d2652007aef40826102fb153134c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d2652007aef40826102fb153134c4d">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением пробельных символов слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале пробельными символами. </dd></dl>

</div>
</div>
<a id="a17a1d3727d030ed34c789a1fd45a8038" name="a17a1d3727d030ed34c789a1fd45a8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a1d3727d030ed34c789a1fd45a8038">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале символами, содержащимися в шаблоне. </dd></dl>

</div>
</div>
<a id="ab7910e7f7cb59cad7452f79ee8f1921a" name="ab7910e7f7cb59cad7452f79ee8f1921a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7910e7f7cb59cad7452f79ee8f1921a">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале символами, содержащимися в литерале. </dd></dl>

</div>
</div>
<a id="ae9b80529d46935202969c279de481cda" name="ae9b80529d46935202969c279de481cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b80529d46935202969c279de481cda">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале символами, содержащимися в шаблоне и пробельными символами. </dd></dl>

</div>
</div>
<a id="ae0e7c2822c67cc2ea9a0b8c8ed9e0280" name="ae0e7c2822c67cc2ea9a0b8c8ed9e0280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e7c2822c67cc2ea9a0b8c8ed9e0280">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале символами, содержащимися в литерале и пробельными символами. </dd></dl>

</div>
</div>
<a id="a0b3af5eab221e4645e6e91b7b1a6e7d2" name="a0b3af5eab221e4645e6e91b7b1a6e7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3af5eab221e4645e6e91b7b1a6e7d2">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением пробельных символов справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце пробельными символами. </dd></dl>

</div>
</div>
<a id="aa5a49ba436dd8d11037216dc97efcd4c" name="aa5a49ba436dd8d11037216dc97efcd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a49ba436dd8d11037216dc97efcd4c">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце символами, содержащимися в шаблоне. </dd></dl>

</div>
</div>
<a id="ac82f1096d596015340377b58704030cf" name="ac82f1096d596015340377b58704030cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82f1096d596015340377b58704030cf">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце символами, содержащимися в литерале. </dd></dl>

</div>
</div>
<a id="ac21bff9dca83968de291faa2b6d59fa8" name="ac21bff9dca83968de291faa2b6d59fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21bff9dca83968de291faa2b6d59fa8">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце символами, содержащимися в шаблоне и пробельными символами. </dd></dl>

</div>
</div>
<a id="ad41853e3d4d2579fe7557873592e7302" name="ad41853e3d4d2579fe7557873592e7302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41853e3d4d2579fe7557873592e7302">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце символами, содержащимися в литерале и пробельными символами. </dd></dl>

</div>
</div>
<a id="a6c2541095cb5e5a262b8e20c4dc8428b" name="a6c2541095cb5e5a262b8e20c4dc8428b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2541095cb5e5a262b8e20c4dc8428b">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце символами, содержащимися в шаблоне и пробельными символами. </dd></dl>

</div>
</div>
<a id="ab950f20c494e2c60b22dfe95e410ec25" name="ab950f20c494e2c60b22dfe95e410ec25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab950f20c494e2c60b22dfe95e410ec25">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце символами, содержащимися в литерале и пробельными символами. </dd></dl>

</div>
</div>
<a id="a411f3accc2e800d55e6b26c9c9220926" name="a411f3accc2e800d55e6b26c9c9220926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411f3accc2e800d55e6b26c9c9220926">&#9670;&#160;</a></span>until()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить подстроку <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a> от начала и до первого найденного вхождения указанной подстроки. </p>
<p>Если не найдено, вернёт всю строку. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>- позиция для начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Подстроку, <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </dd></dl>

</div>
</div>
<a id="ad1b975226e92b0e57796dd14fed5248f" name="ad1b975226e92b0e57796dd14fed5248f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b975226e92b0e57796dd14fed5248f">&#9670;&#160;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать в верхний регистр Unicode символы первой плоскости (&lt;0xFFFF). </p>
<p>Регистр меняется упрощенными таблицами, где один code_point всегда меняется в один code_point (но для UTF-8 возможно, что длина в code unit'ах изменится). </p><dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же </dd></dl>

</div>
</div>
<a id="a1c7b47cfc00189c51a5683fd34095192" name="a1c7b47cfc00189c51a5683fd34095192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7b47cfc00189c51a5683fd34095192">&#9670;&#160;</a></span>upper_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::upper_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать в верхний регистр ASCII символы. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<a id="a6ae3ef69a372dab777c952f22c492689" name="a6ae3ef69a372dab777c952f22c492689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3ef69a372dab777c952f22c492689">&#9670;&#160;</a></span>upperred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::upperred </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки в верхнем регистре Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - копию строки в верхнем регистре. </dd></dl>

</div>
</div>
<a id="a3c53f8d59e980315bc0d44b5cf6b1e6d" name="a3c53f8d59e980315bc0d44b5cf6b1e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c53f8d59e980315bc0d44b5cf6b1e6d">&#9670;&#160;</a></span>upperred_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::upperred_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Создать копию переданной строки в верхнем регистре символов Unicode первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- строка источник. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора.</td></tr>
  </table>
  </dd>
</dl>
<p>Регистр меняется упрощенными таблицами, где один code_point всегда меняется в один code_point (но для UTF-8 возможно, что длина в code unit'ах изменится). </p>

</div>
</div>
<a id="a517129dd2774440cd48c401b65bcf066" name="a517129dd2774440cd48c401b65bcf066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517129dd2774440cd48c401b65bcf066">&#9670;&#160;</a></span>upperred_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, Mutable &gt;::upperred_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки в верхнем регистре ASCII символов. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - копию строки в верхнем регистре. </dd></dl>

</div>
</div>
<a id="a6cb647956eba06372b0cef5328a0bc91" name="a6cb647956eba06372b0cef5328a0bc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb647956eba06372b0cef5328a0bc91">&#9670;&#160;</a></span>upperred_only_ascii_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimstr_1_1lstring.html">my_type</a> <a class="el" href="classsimstr_1_1str__storable.html">simstr::str_storable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt;, allocator_string &gt;::upperred_only_ascii_from </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Создать строку, копию переданной в верхнем регистре символов ASCII. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- строка источник. </td></tr>
    <tr><td class="paramname">...args</td><td>- параметры для инициализации аллокатора. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0ab4a1d48cbf3b7c3474a4bf28569c" name="a4c0ab4a1d48cbf3b7c3474a4bf28569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0ab4a1d48cbf3b7c3474a4bf28569c">&#9670;&#160;</a></span>vformat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::vformat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Форматирует строку с помощью std::vformat. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>- форматная строка. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="a7cf2545d9002b51989700a64d7aaff0e" name="a7cf2545d9002b51989700a64d7aaff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf2545d9002b51989700a64d7aaff0e">&#9670;&#160;</a></span>vformat_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::vformat_from </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Добавляет отформатированный с помощью std::vformat вывод, начиная с указанной позиции. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- начальная позиция добавления. </td></tr>
    <tr><td class="paramname">max_write</td><td>- максимальное количество записываемых символов. </td></tr>
    <tr><td class="paramname">format</td><td>- форматная строка. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="a85893478637a79c79321e5c15cab9763" name="a85893478637a79c79321e5c15cab9763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85893478637a79c79321e5c15cab9763">&#9670;&#160;</a></span>vformat_n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::vformat_n </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Форматирует строку с помощью std::vformat не более указанного размера. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_write</td><td>- максимальное количество записываемых символов. </td></tr>
    <tr><td class="paramname">format</td><td>- форматная строка. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы для std::vformat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же.</dd></dl>
<p>При необходимости автоматически увеличивает размер буфера строки. </p>

</div>
</div>
<a id="a43a9104a71b1593fea01f6eff162fec4" name="a43a9104a71b1593fea01f6eff162fec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a9104a71b1593fea01f6eff162fec4">&#9670;&#160;</a></span>with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &amp; <a class="el" href="classsimstr_1_1str__mutable.html">simstr::str_mutable</a>&lt; K, <a class="el" href="classsimstr_1_1lstring.html">lstring</a>&lt; K, N, false, allocator_string &gt; &gt;::with </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>fillFunction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Вызов функтора со строкой и переданными аргументами. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillFunction</td><td>- функтор, принимающий первым параметром ссылку на строку. </td></tr>
    <tr><td class="paramname">...args</td><td>- аргументы, передаваемые в функтор. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Impl&amp; - ссылку на себя же. </dd></dl>

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li><a class="el" href="sstring_8h_source.html">sstring.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimstr.html">simstr</a></li><li class="navelem"><a class="el" href="classsimstr_1_1lstring.html">lstring</a></li>
    <li class="footer">Создано системой <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

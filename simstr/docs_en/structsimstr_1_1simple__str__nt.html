<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: simstr::simple_str_nt&lt; K &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.3.1</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structsimstr_1_1simple__str__nt.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structsimstr_1_1simple__str__nt-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simstr::simple_str_nt&lt; K &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class that claims to refer to a null-terminated string.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sstring_8h_source.html">sstring.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for simstr::simple_str_nt&lt; K &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structsimstr_1_1simple__str__nt.png" usemap="#simstr::simple_5Fstr_5Fnt_3C_20K_20_3E_map" alt=""/>
  <map id="simstr::simple_5Fstr_5Fnt_3C_20K_20_3E_map" name="simstr::simple_5Fstr_5Fnt_3C_20K_20_3E_map">
<area href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class." alt="simstr::simple_str&lt; K &gt;" shape="rect" coords="0,56,356,80"/>
<area href="classsimstr_1_1str__algs.html" alt="simstr::str_algs&lt; K, simple_str&lt; K &gt;, simple_str&lt; K &gt;, false &gt;" shape="rect" coords="0,0,356,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63bd89453f2dba71fbf43d9a849ae659" id="r_a63bd89453f2dba71fbf43d9a849ae659"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires std::is_same_v&lt;std::remove_const_t&lt;std::remove_pointer_t&lt;std::remove_cvref_t&lt;T&gt;&gt;&gt;, K&gt;</td></tr>
<tr class="memitem:a63bd89453f2dba71fbf43d9a849ae659"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63bd89453f2dba71fbf43d9a849ae659">simple_str_nt</a> (T &amp;&amp;p) noexcept</td></tr>
<tr class="memdesc:a63bd89453f2dba71fbf43d9a849ae659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit constructor from C-string.  <br /></td></tr>
<tr class="separator:a63bd89453f2dba71fbf43d9a849ae659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe560c2153c95d29a3c2b1cb2b91b77" id="r_a6fe560c2153c95d29a3c2b1cb2b91b77"><td class="memTemplParams" colspan="2"><a id="a6fe560c2153c95d29a3c2b1cb2b91b77" name="a6fe560c2153c95d29a3c2b1cb2b91b77"></a>
template&lt;typename S&gt; <br />
requires (std::is_same_v&lt;S, std::string&amp;&gt; || std::is_same_v&lt;S, const std::string&amp;&gt; || std::is_same_v&lt;S, std::string_view&amp;&gt; || std::is_same_v&lt;S, const std::string_view&amp;&gt;)</td></tr>
<tr class="memitem:a6fe560c2153c95d29a3c2b1cb2b91b77"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simple_str_nt</b> (S &amp;&amp;s) noexcept</td></tr>
<tr class="memdesc:a6fe560c2153c95d29a3c2b1cb2b91b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows you to initialize std::string and std::string_view objects provided that they are lvalue, that is, not temporary. <br /></td></tr>
<tr class="separator:a6fe560c2153c95d29a3c2b1cb2b91b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382454e202378bf79672e5f675fb85f" id="r_a2382454e202378bf79672e5f675fb85f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2382454e202378bf79672e5f675fb85f">operator const K *</a> () const noexcept</td></tr>
<tr class="memdesc:a2382454e202378bf79672e5f675fb85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to a null-terminated C string.  <br /></td></tr>
<tr class="separator:a2382454e202378bf79672e5f675fb85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5208a3e746ac41a843a4bff0582d4b1a" id="r_a5208a3e746ac41a843a4bff0582d4b1a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5208a3e746ac41a843a4bff0582d4b1a">to_nts</a> (size_t from)</td></tr>
<tr class="memdesc:a5208a3e746ac41a843a4bff0582d4b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a null-terminated string by shifting the start by the specified number of characters.  <br /></td></tr>
<tr class="separator:a5208a3e746ac41a843a4bff0582d4b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574c8578274b5cc7a3e9507e8669d343" id="r_a574c8578274b5cc7a3e9507e8669d343"><td class="memItemLeft" align="right" valign="top"><a id="a574c8578274b5cc7a3e9507e8669d343" name="a574c8578274b5cc7a3e9507e8669d343"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> () const noexcept</td></tr>
<tr class="memdesc:a574c8578274b5cc7a3e9507e8669d343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string. <br /></td></tr>
<tr class="separator:a574c8578274b5cc7a3e9507e8669d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611ab22c81c515ed231fc767ecb0df0a" id="r_a611ab22c81c515ed231fc767ecb0df0a"><td class="memItemLeft" align="right" valign="top"><a id="a611ab22c81c515ed231fc767ecb0df0a" name="a611ab22c81c515ed231fc767ecb0df0a"></a>
constexpr const symb_type *&#160;</td><td class="memItemRight" valign="bottom"><b>symbols</b> () const noexcept</td></tr>
<tr class="memdesc:a611ab22c81c515ed231fc767ecb0df0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a constant buffer containing string characters. <br /></td></tr>
<tr class="separator:a611ab22c81c515ed231fc767ecb0df0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c3531ce29d4b40a306c458279c7a63" id="r_ab4c3531ce29d4b40a306c458279c7a63"><td class="memItemLeft" align="right" valign="top"><a id="ab4c3531ce29d4b40a306c458279c7a63" name="ab4c3531ce29d4b40a306c458279c7a63"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const noexcept</td></tr>
<tr class="memdesc:ab4c3531ce29d4b40a306c458279c7a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string is empty. <br /></td></tr>
<tr class="separator:ab4c3531ce29d4b40a306c458279c7a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a66a7877b07e9f95d91c71077fdf48" id="r_ab6a66a7877b07e9f95d91c71077fdf48"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1simple__str.html#ab6a66a7877b07e9f95d91c71077fdf48">is_same</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt; other) const noexcept</td></tr>
<tr class="memdesc:ab6a66a7877b07e9f95d91c71077fdf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two objects point to the same string.  <br /></td></tr>
<tr class="separator:ab6a66a7877b07e9f95d91c71077fdf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaedb195f21ec725e42544784bc2663" id="r_afdaedb195f21ec725e42544784bc2663"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1simple__str.html#afdaedb195f21ec725e42544784bc2663">is_part_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt; other) const noexcept</td></tr>
<tr class="memdesc:afdaedb195f21ec725e42544784bc2663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string is part of another string.  <br /></td></tr>
<tr class="separator:afdaedb195f21ec725e42544784bc2663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab058c6d2bb0b8c36cafd7c82490943" id="r_a1ab058c6d2bb0b8c36cafd7c82490943"><td class="memItemLeft" align="right" valign="top">constexpr K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1simple__str.html#a1ab058c6d2bb0b8c36cafd7c82490943">operator[]</a> (size_t idx) const</td></tr>
<tr class="memdesc:a1ab058c6d2bb0b8c36cafd7c82490943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character from the specified position. Bounds checking is not performed.  <br /></td></tr>
<tr class="separator:a1ab058c6d2bb0b8c36cafd7c82490943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ad322b41b70f1d49e735e2e5456c16" id="r_a71ad322b41b70f1d49e735e2e5456c16"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1simple__str.html#a71ad322b41b70f1d49e735e2e5456c16">remove_prefix</a> (size_t delta)</td></tr>
<tr class="memdesc:a71ad322b41b70f1d49e735e2e5456c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the start of a line by the specified number of characters.  <br /></td></tr>
<tr class="separator:a71ad322b41b70f1d49e735e2e5456c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442986ca3c3ff2e67b53240cca4d2cd6" id="r_a442986ca3c3ff2e67b53240cca4d2cd6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1simple__str.html#a442986ca3c3ff2e67b53240cca4d2cd6">remove_suffix</a> (size_t delta)</td></tr>
<tr class="memdesc:a442986ca3c3ff2e67b53240cca4d2cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortens the string by the specified number of characters.  <br /></td></tr>
<tr class="separator:a442986ca3c3ff2e67b53240cca4d2cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efa353bc382a6e476b1180f0cbd64be" id="r_a9efa353bc382a6e476b1180f0cbd64be"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a9efa353bc382a6e476b1180f0cbd64be">place</a> (K *ptr) const noexcept</td></tr>
<tr class="memdesc:a9efa353bc382a6e476b1180f0cbd64be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string to the specified buffer.  <br /></td></tr>
<tr class="separator:a9efa353bc382a6e476b1180f0cbd64be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa371442f5d71650b6759407a74ba7f6c" id="r_aa371442f5d71650b6759407a74ba7f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aa371442f5d71650b6759407a74ba7f6c">copy_to</a> (K *buffer, size_t bufSize)</td></tr>
<tr class="memdesc:aa371442f5d71650b6759407a74ba7f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string to the specified buffer.  <br /></td></tr>
<tr class="separator:aa371442f5d71650b6759407a74ba7f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032bb26b7a123fc2a391597e0b1478c8" id="r_a032bb26b7a123fc2a391597e0b1478c8"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a032bb26b7a123fc2a391597e0b1478c8">size</a> () const</td></tr>
<tr class="memdesc:a032bb26b7a123fc2a391597e0b1478c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the string in characters.  <br /></td></tr>
<tr class="separator:a032bb26b7a123fc2a391597e0b1478c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb514b2a1711b54c063b6b77adfb524" id="r_a9cb514b2a1711b54c063b6b77adfb524"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a9cb514b2a1711b54c063b6b77adfb524">operator str_piece</a> () const noexcept</td></tr>
<tr class="memdesc:a9cb514b2a1711b54c063b6b77adfb524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert itself to a "string chunk" that includes the entire string.  <br /></td></tr>
<tr class="separator:a9cb514b2a1711b54c063b6b77adfb524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d10266d4f76dfa7e1f79e603e947b1" id="r_a19d10266d4f76dfa7e1f79e603e947b1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a19d10266d4f76dfa7e1f79e603e947b1">to_str</a> () const noexcept</td></tr>
<tr class="memdesc:a19d10266d4f76dfa7e1f79e603e947b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert itself to a "string chunk" that includes the entire string.  <br /></td></tr>
<tr class="separator:a19d10266d4f76dfa7e1f79e603e947b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4e13ca8dd62c156b460b40be5722d8" id="r_a1c4e13ca8dd62c156b460b40be5722d8"><td class="memItemLeft" align="right" valign="top">constexpr std::basic_string_view&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a1c4e13ca8dd62c156b460b40be5722d8">to_sv</a> () const noexcept</td></tr>
<tr class="memdesc:a1c4e13ca8dd62c156b460b40be5722d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::string_view.  <br /></td></tr>
<tr class="separator:a1c4e13ca8dd62c156b460b40be5722d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14461bfb4a7760db97bf50bb834c197" id="r_af14461bfb4a7760db97bf50bb834c197"><td class="memItemLeft" align="right" valign="top">constexpr std::basic_string&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af14461bfb4a7760db97bf50bb834c197">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:af14461bfb4a7760db97bf50bb834c197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to std::string.  <br /></td></tr>
<tr class="separator:af14461bfb4a7760db97bf50bb834c197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bb2523d89124db15ab675dd7b661dd" id="r_a85bb2523d89124db15ab675dd7b661dd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a85bb2523d89124db15ab675dd7b661dd">operator()</a> (ptrdiff_t from, ptrdiff_t len=0) const noexcept</td></tr>
<tr class="memdesc:a85bb2523d89124db15ab675dd7b661dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string as "simple_str".  <br /></td></tr>
<tr class="separator:a85bb2523d89124db15ab675dd7b661dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3cdef6c7633c7da8dac91187cc545e" id="r_a2d3cdef6c7633c7da8dac91187cc545e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a2d3cdef6c7633c7da8dac91187cc545e">mid</a> (size_t from, size_t len=-1) const noexcept</td></tr>
<tr class="memdesc:a2d3cdef6c7633c7da8dac91187cc545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string as "string chunk".  <br /></td></tr>
<tr class="separator:a2d3cdef6c7633c7da8dac91187cc545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56043b721d327307a88b3be41d36bc5" id="r_af56043b721d327307a88b3be41d36bc5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af56043b721d327307a88b3be41d36bc5">from_to</a> (size_t from, size_t to) const noexcept</td></tr>
<tr class="memdesc:af56043b721d327307a88b3be41d36bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the substring <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a> from position from to position to (not including it).  <br /></td></tr>
<tr class="separator:af56043b721d327307a88b3be41d36bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cc821a25864d4e5550973e104efe98" id="r_a03cc821a25864d4e5550973e104efe98"><td class="memItemLeft" align="right" valign="top"><a id="a03cc821a25864d4e5550973e104efe98" name="a03cc821a25864d4e5550973e104efe98"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!</b> () const noexcept</td></tr>
<tr class="memdesc:a03cc821a25864d4e5550973e104efe98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for emptiness. <br /></td></tr>
<tr class="separator:a03cc821a25864d4e5550973e104efe98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28acaa475e182b6df9010bd99dfd9c1" id="r_ae28acaa475e182b6df9010bd99dfd9c1"><td class="memItemLeft" align="right" valign="top">constexpr K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ae28acaa475e182b6df9010bd99dfd9c1">at</a> (ptrdiff_t idx) const</td></tr>
<tr class="memdesc:ae28acaa475e182b6df9010bd99dfd9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the character at the given position.  <br /></td></tr>
<tr class="separator:ae28acaa475e182b6df9010bd99dfd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac72f56788a268face1e9315ac514390" id="r_aac72f56788a268face1e9315ac514390"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aac72f56788a268face1e9315ac514390">compare</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> o) const</td></tr>
<tr class="memdesc:aac72f56788a268face1e9315ac514390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character.  <br /></td></tr>
<tr class="separator:aac72f56788a268face1e9315ac514390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cbab476dcc336ea5f2bceee89b14ca" id="r_ab4cbab476dcc336ea5f2bceee89b14ca"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ab4cbab476dcc336ea5f2bceee89b14ca">strcmp</a> (const K *text) const</td></tr>
<tr class="memdesc:ab4cbab476dcc336ea5f2bceee89b14ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare with C-string character by character.  <br /></td></tr>
<tr class="separator:ab4cbab476dcc336ea5f2bceee89b14ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8402c183e1c28ed0f06aa2fe28bedc" id="r_aef8402c183e1c28ed0f06aa2fe28bedc"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aef8402c183e1c28ed0f06aa2fe28bedc">equal</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> other) const noexcept</td></tr>
<tr class="memdesc:aef8402c183e1c28ed0f06aa2fe28bedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">String comparison for equality.  <br /></td></tr>
<tr class="separator:aef8402c183e1c28ed0f06aa2fe28bedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae891863b2c4ed81e603838890173496d" id="r_ae891863b2c4ed81e603838890173496d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ae891863b2c4ed81e603838890173496d">operator==</a> (const <a class="el" href="structsimstr_1_1simple__str.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ae891863b2c4ed81e603838890173496d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator comparing strings for equality.  <br /></td></tr>
<tr class="separator:ae891863b2c4ed81e603838890173496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8ea7c375d988ab82099d10d0779118" id="r_a3d8ea7c375d988ab82099d10d0779118"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a3d8ea7c375d988ab82099d10d0779118">operator==</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:a3d8ea7c375d988ab82099d10d0779118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for comparing a string and a string literal for equality.  <br /></td></tr>
<tr class="separator:a3d8ea7c375d988ab82099d10d0779118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882ecc460b3d9e6b6786121796b89372" id="r_a882ecc460b3d9e6b6786121796b89372"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a882ecc460b3d9e6b6786121796b89372">operator&lt;=&gt;</a> (const <a class="el" href="structsimstr_1_1simple__str.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a882ecc460b3d9e6b6786121796b89372"><td class="mdescLeft">&#160;</td><td class="mdescRight">String comparison operator.  <br /></td></tr>
<tr class="separator:a882ecc460b3d9e6b6786121796b89372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac967d356ab7df7db6245866aa34d5232" id="r_ac967d356ab7df7db6245866aa34d5232"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ac967d356ab7df7db6245866aa34d5232">operator&lt;=&gt;</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ac967d356ab7df7db6245866aa34d5232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator between a string and a string literal.  <br /></td></tr>
<tr class="separator:ac967d356ab7df7db6245866aa34d5232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d481d6eb2d043ac8ce5d0d5e7ec86" id="r_ae89d481d6eb2d043ac8ce5d0d5e7ec86"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ae89d481d6eb2d043ac8ce5d0d5e7ec86">compare_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:ae89d481d6eb2d043ac8ce5d0d5e7ec86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character and not case sensitive ASCII characters.  <br /></td></tr>
<tr class="separator:ae89d481d6eb2d043ac8ce5d0d5e7ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd1a4d1a8b9c8e5aaa199f8914fe474" id="r_a2cd1a4d1a8b9c8e5aaa199f8914fe474"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a2cd1a4d1a8b9c8e5aaa199f8914fe474">equal_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a2cd1a4d1a8b9c8e5aaa199f8914fe474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is equal to another string, character-by-character-insensitive, of ASCII characters.  <br /></td></tr>
<tr class="separator:a2cd1a4d1a8b9c8e5aaa199f8914fe474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d3a1a76af2a3153cc4b329e486dac6" id="r_af1d3a1a76af2a3153cc4b329e486dac6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af1d3a1a76af2a3153cc4b329e486dac6">less_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:af1d3a1a76af2a3153cc4b329e486dac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is smaller than another string, character-by-character-insensitive, ASCII characters.  <br /></td></tr>
<tr class="separator:af1d3a1a76af2a3153cc4b329e486dac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400250ea87cc59daa152dc9ddb57491f" id="r_a400250ea87cc59daa152dc9ddb57491f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a400250ea87cc59daa152dc9ddb57491f">compare_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a400250ea87cc59daa152dc9ddb57491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings character by character without taking into account the case of Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a400250ea87cc59daa152dc9ddb57491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf0990c46a280cd363da46bef12e02f" id="r_adbf0990c46a280cd363da46bef12e02f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#adbf0990c46a280cd363da46bef12e02f">equal_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:adbf0990c46a280cd363da46bef12e02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is equal to another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:adbf0990c46a280cd363da46bef12e02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79e99462478b57d62873f7942ff2b6" id="r_a4e79e99462478b57d62873f7942ff2b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a4e79e99462478b57d62873f7942ff2b6">less_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a4e79e99462478b57d62873f7942ff2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a string is smaller than another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a4e79e99462478b57d62873f7942ff2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8390e23702a40a3f550fce9c04d1e8d1" id="r_a8390e23702a40a3f550fce9c04d1e8d1"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a8390e23702a40a3f550fce9c04d1e8d1">find</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a8390e23702a40a3f550fce9c04d1e8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a8390e23702a40a3f550fce9c04d1e8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4000d2493f15cd529bc78ae2d1c581c7" id="r_a4000d2493f15cd529bc78ae2d1c581c7"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a4000d2493f15cd529bc78ae2d1c581c7">find</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a4000d2493f15cd529bc78ae2d1c581c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a character in this string.  <br /></td></tr>
<tr class="separator:a4000d2493f15cd529bc78ae2d1c581c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33894b131f47fba7559eda085111409c" id="r_a33894b131f47fba7559eda085111409c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a33894b131f47fba7559eda085111409c">find_or_throw</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, Args &amp;&amp;... args) const noexcept</td></tr>
<tr class="memdesc:a33894b131f47fba7559eda085111409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string or throw an exception.  <br /></td></tr>
<tr class="separator:a33894b131f47fba7559eda085111409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ccd354949c2af5ed75676b36791527" id="r_ad6ccd354949c2af5ed75676b36791527"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ad6ccd354949c2af5ed75676b36791527">find_end</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ad6ccd354949c2af5ed75676b36791527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:ad6ccd354949c2af5ed75676b36791527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d58b99ec86c7c0f469349c12ad07de" id="r_a58d58b99ec86c7c0f469349c12ad07de"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a58d58b99ec86c7c0f469349c12ad07de">find_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a58d58b99ec86c7c0f469349c12ad07de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the first occurrence of a substring in this string or the end of the string.  <br /></td></tr>
<tr class="separator:a58d58b99ec86c7c0f469349c12ad07de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76489dd5307a12260f1766f514016fe6" id="r_a76489dd5307a12260f1766f514016fe6"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a76489dd5307a12260f1766f514016fe6">find_or_all</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a76489dd5307a12260f1766f514016fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a character in this string or the end of a string.  <br /></td></tr>
<tr class="separator:a76489dd5307a12260f1766f514016fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a9f3ade055eb5db285d726f388f64" id="r_ae90a9f3ade055eb5db285d726f388f64"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ae90a9f3ade055eb5db285d726f388f64">find_end_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ae90a9f3ade055eb5db285d726f388f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the first occurrence of a substring in this string, or the end of a string.  <br /></td></tr>
<tr class="separator:ae90a9f3ade055eb5db285d726f388f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee58c2b8fd6e049423cb859dd7ad164" id="r_a8ee58c2b8fd6e049423cb859dd7ad164"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a8ee58c2b8fd6e049423cb859dd7ad164">find_last</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a8ee58c2b8fd6e049423cb859dd7ad164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the last occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a8ee58c2b8fd6e049423cb859dd7ad164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f7e754f87cfa55e8ec0bcb4f44efc1" id="r_ae7f7e754f87cfa55e8ec0bcb4f44efc1"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ae7f7e754f87cfa55e8ec0bcb4f44efc1">find_last</a> (K s, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:ae7f7e754f87cfa55e8ec0bcb4f44efc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character in this string.  <br /></td></tr>
<tr class="separator:ae7f7e754f87cfa55e8ec0bcb4f44efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c54be3da183bf0f7f04071c484ceff7" id="r_a3c54be3da183bf0f7f04071c484ceff7"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a3c54be3da183bf0f7f04071c484ceff7">find_end_of_last</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a3c54be3da183bf0f7f04071c484ceff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the last occurrence of a substring in this string.  <br /></td></tr>
<tr class="separator:a3c54be3da183bf0f7f04071c484ceff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3683cb297886257bd6259c2e0f77bd21" id="r_a3683cb297886257bd6259c2e0f77bd21"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a3683cb297886257bd6259c2e0f77bd21">find_last_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a3683cb297886257bd6259c2e0f77bd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of the last occurrence of a substring in this string or the end of the string.  <br /></td></tr>
<tr class="separator:a3683cb297886257bd6259c2e0f77bd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef25980678fac58bdf7112e3354eb68" id="r_a5ef25980678fac58bdf7112e3354eb68"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a5ef25980678fac58bdf7112e3354eb68">find_end_of_last_or_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a5ef25980678fac58bdf7112e3354eb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of the last occurrence of a substring in this string, or the end of a string.  <br /></td></tr>
<tr class="separator:a5ef25980678fac58bdf7112e3354eb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e02eb727a2351300d4349d6637fe262" id="r_a6e02eb727a2351300d4349d6637fe262"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a6e02eb727a2351300d4349d6637fe262">contains</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a6e02eb727a2351300d4349d6637fe262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string contains the specified substring.  <br /></td></tr>
<tr class="separator:a6e02eb727a2351300d4349d6637fe262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab344db1789674fe5c9dbd31fcfbbe254" id="r_ab344db1789674fe5c9dbd31fcfbbe254"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ab344db1789674fe5c9dbd31fcfbbe254">for_all_finded</a> (const Op &amp;op, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:ab344db1789674fe5c9dbd31fcfbbe254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor on all found occurrences of a substring in this string.  <br /></td></tr>
<tr class="separator:ab344db1789674fe5c9dbd31fcfbbe254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713475a34317581d09f86728d8ddb44c" id="r_a713475a34317581d09f86728d8ddb44c"><td class="memItemLeft" align="right" valign="top">constexpr std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a713475a34317581d09f86728d8ddb44c">find_all</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a713475a34317581d09f86728d8ddb44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all occurrences of a substring in this string.  <br /></td></tr>
<tr class="separator:a713475a34317581d09f86728d8ddb44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0216228858201c6bd0c0375dcb3d575" id="r_ac0216228858201c6bd0c0375dcb3d575"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ac0216228858201c6bd0c0375dcb3d575">find_first_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac0216228858201c6bd0c0375dcb3d575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:ac0216228858201c6bd0c0375dcb3d575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bb2222b4e7c3830bacd27357b5733e" id="r_a97bb2222b4e7c3830bacd27357b5733e"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a97bb2222b4e7c3830bacd27357b5733e">find_first_of_idx</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a97bb2222b4e7c3830bacd27357b5733e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:a97bb2222b4e7c3830bacd27357b5733e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff07b785db7f341898a931ecffee7056" id="r_aff07b785db7f341898a931ecffee7056"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aff07b785db7f341898a931ecffee7056">find_first_not_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:aff07b785db7f341898a931ecffee7056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character not from the given character set.  <br /></td></tr>
<tr class="separator:aff07b785db7f341898a931ecffee7056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad775d1f04c93d2ba8a1a32775fd8e3ff" id="r_ad775d1f04c93d2ba8a1a32775fd8e3ff"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ad775d1f04c93d2ba8a1a32775fd8e3ff">find_last_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:ad775d1f04c93d2ba8a1a32775fd8e3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:ad775d1f04c93d2ba8a1a32775fd8e3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12d2001ab5e2aed830cc78a1f718536" id="r_af12d2001ab5e2aed830cc78a1f718536"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af12d2001ab5e2aed830cc78a1f718536">find_last_of_idx</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:af12d2001ab5e2aed830cc78a1f718536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character from a given character set.  <br /></td></tr>
<tr class="separator:af12d2001ab5e2aed830cc78a1f718536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc411c9a47381f1b565f9931e7ee6d07" id="r_adc411c9a47381f1b565f9931e7ee6d07"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#adc411c9a47381f1b565f9931e7ee6d07">find_last_not_of</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:adc411c9a47381f1b565f9931e7ee6d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last occurrence of a character not from the given character set.  <br /></td></tr>
<tr class="separator:adc411c9a47381f1b565f9931e7ee6d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d443fd3ca34c3e6ebd728e2f511acb" id="r_ab8d443fd3ca34c3e6ebd728e2f511acb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ab8d443fd3ca34c3e6ebd728e2f511acb">substr</a> (ptrdiff_t from, ptrdiff_t len=0) const</td></tr>
<tr class="memdesc:ab8d443fd3ca34c3e6ebd728e2f511acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a substring. Works similarly to operator(), only the result is the same type as the method applied to.  <br /></td></tr>
<tr class="separator:ab8d443fd3ca34c3e6ebd728e2f511acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62256e9942d3337c50a9458374ac52f3" id="r_a62256e9942d3337c50a9458374ac52f3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a62256e9942d3337c50a9458374ac52f3">str_mid</a> (size_t from, size_t len=-1) const</td></tr>
<tr class="memdesc:a62256e9942d3337c50a9458374ac52f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part of a string with an object of the same type to which the method is applied, similar to mid.  <br /></td></tr>
<tr class="separator:a62256e9942d3337c50a9458374ac52f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5321022f75db5f7c791c145e7fe0f1" id="r_a3b5321022f75db5f7c791c145e7fe0f1"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a3b5321022f75db5f7c791c145e7fe0f1">as_int</a> () const noexcept</td></tr>
<tr class="memdesc:a3b5321022f75db5f7c791c145e7fe0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number of the given type.  <br /></td></tr>
<tr class="separator:a3b5321022f75db5f7c791c145e7fe0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356a572ad74e9d512c0d36d1e6699d96" id="r_a356a572ad74e9d512c0d36d1e6699d96"><td class="memItemLeft" align="right" valign="top">constexpr convert_result&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a356a572ad74e9d512c0d36d1e6699d96">to_int</a> () const noexcept</td></tr>
<tr class="memdesc:a356a572ad74e9d512c0d36d1e6699d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a number of the given type.  <br /></td></tr>
<tr class="separator:a356a572ad74e9d512c0d36d1e6699d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af52e61e73c687a34ff6978304edc3" id="r_aa1af52e61e73c687a34ff6978304edc3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aa1af52e61e73c687a34ff6978304edc3">to_double</a> () const noexcept</td></tr>
<tr class="memdesc:aa1af52e61e73c687a34ff6978304edc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <br /></td></tr>
<tr class="separator:aa1af52e61e73c687a34ff6978304edc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683d9d722cc772870832128793e8a624" id="r_a683d9d722cc772870832128793e8a624"><td class="memItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a683d9d722cc772870832128793e8a624">to_double_hex</a> () const noexcept</td></tr>
<tr class="memdesc:a683d9d722cc772870832128793e8a624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string in hex form to double.  <br /></td></tr>
<tr class="separator:a683d9d722cc772870832128793e8a624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17421202713ebd4d62ddf175023f535" id="r_ac17421202713ebd4d62ddf175023f535"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ac17421202713ebd4d62ddf175023f535">as_number</a> (T &amp;t) const</td></tr>
<tr class="memdesc:ac17421202713ebd4d62ddf175023f535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an integer.  <br /></td></tr>
<tr class="separator:ac17421202713ebd4d62ddf175023f535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860598fca0df848662d7d8578a8f6da" id="r_af860598fca0df848662d7d8578a8f6da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af860598fca0df848662d7d8578a8f6da">as_number</a> (double &amp;t) const</td></tr>
<tr class="memdesc:af860598fca0df848662d7d8578a8f6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to double.  <br /></td></tr>
<tr class="separator:af860598fca0df848662d7d8578a8f6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0476580fd6fa230fd46d0fe5a1f33e" id="r_aed0476580fd6fa230fd46d0fe5a1f33e"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aed0476580fd6fa230fd46d0fe5a1f33e">splitf</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimeter, const Op &amp;beforeFunc, size_t offset=0) const</td></tr>
<tr class="memdesc:aed0476580fd6fa230fd46d0fe5a1f33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into parts at a given delimiter, possibly applying a functor to each substring.  <br /></td></tr>
<tr class="separator:aed0476580fd6fa230fd46d0fe5a1f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346fe7eb58168d714387f2c3065f78d0" id="r_a346fe7eb58168d714387f2c3065f78d0"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a346fe7eb58168d714387f2c3065f78d0">split</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimeter, size_t offset=0) const</td></tr>
<tr class="memdesc:a346fe7eb58168d714387f2c3065f78d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into substrings using a given delimiter.  <br /></td></tr>
<tr class="separator:a346fe7eb58168d714387f2c3065f78d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25dce601de84e9e5f0c78de89a71cf9" id="r_ac25dce601de84e9e5f0c78de89a71cf9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1_splitter.html">Splitter</a>&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ac25dce601de84e9e5f0c78de89a71cf9">splitter</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> delimeter) const</td></tr>
<tr class="memdesc:ac25dce601de84e9e5f0c78de89a71cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <code><a class="el" href="classsimstr_1_1_splitter.html" title="Class for sequentially obtaining substrings by a given delimiter.">Splitter</a></code> object by the given splitter, which allows sequential get substrings using the <code>next()</code> method while <code>is_done()</code> is false.  <br /></td></tr>
<tr class="separator:ac25dce601de84e9e5f0c78de89a71cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0749cac4a635847a7a57e244281fcd97" id="r_a0749cac4a635847a7a57e244281fcd97"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a0749cac4a635847a7a57e244281fcd97">starts_with</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a0749cac4a635847a7a57e244281fcd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string begins with the given substring.  <br /></td></tr>
<tr class="separator:a0749cac4a635847a7a57e244281fcd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affea5af6d58202e885267ae12615e3fb" id="r_affea5af6d58202e885267ae12615e3fb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#affea5af6d58202e885267ae12615e3fb">starts_with_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:affea5af6d58202e885267ae12615e3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string begins with the given substring in a case-insensitive ASCII character.  <br /></td></tr>
<tr class="separator:affea5af6d58202e885267ae12615e3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26465c7fdac87e8d215e836bdbf6e8c3" id="r_a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a26465c7fdac87e8d215e836bdbf6e8c3">starts_with_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> prefix) const noexcept</td></tr>
<tr class="memdesc:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string starts with the given substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9b707b45b955a9d525f5f699b82341" id="r_a3d9b707b45b955a9d525f5f699b82341"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a3d9b707b45b955a9d525f5f699b82341">prefix_in</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> text) const noexcept</td></tr>
<tr class="memdesc:a3d9b707b45b955a9d525f5f699b82341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this string is the beginning of another string.  <br /></td></tr>
<tr class="separator:a3d9b707b45b955a9d525f5f699b82341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748fd0f63cd688dbfbbb12ddb4ad0042" id="r_a748fd0f63cd688dbfbbb12ddb4ad0042"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a748fd0f63cd688dbfbbb12ddb4ad0042">ends_with</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a748fd0f63cd688dbfbbb12ddb4ad0042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring.  <br /></td></tr>
<tr class="separator:a748fd0f63cd688dbfbbb12ddb4ad0042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ac7184386cd4e60e65c799cf5df83" id="r_adc8ac7184386cd4e60e65c799cf5df83"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#adc8ac7184386cd4e60e65c799cf5df83">ends_with_ia</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:adc8ac7184386cd4e60e65c799cf5df83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring in a case-insensitive ASCII character.  <br /></td></tr>
<tr class="separator:adc8ac7184386cd4e60e65c799cf5df83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535d655a6702861b788830a1d266e48f" id="r_a535d655a6702861b788830a1d266e48f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a535d655a6702861b788830a1d266e48f">ends_with_iu</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> suffix) const noexcept</td></tr>
<tr class="memdesc:a535d655a6702861b788830a1d266e48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string ends with the specified substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a535d655a6702861b788830a1d266e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b79211345b6f993a30fecff2eba10df" id="r_a4b79211345b6f993a30fecff2eba10df"><td class="memItemLeft" align="right" valign="top"><a id="a4b79211345b6f993a30fecff2eba10df" name="a4b79211345b6f993a30fecff2eba10df"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ascii</b> () const noexcept</td></tr>
<tr class="memdesc:a4b79211345b6f993a30fecff2eba10df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the string contains only ASCII characters. <br /></td></tr>
<tr class="separator:a4b79211345b6f993a30fecff2eba10df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dffe997b57c8543ac242fff94b346a" id="r_a30dffe997b57c8543ac242fff94b346a"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a30dffe997b57c8543ac242fff94b346a">upperred_only_ascii</a> () const</td></tr>
<tr class="memdesc:a30dffe997b57c8543ac242fff94b346a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in uppercase ASCII characters.  <br /></td></tr>
<tr class="separator:a30dffe997b57c8543ac242fff94b346a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dd9a33977e5ef7878079085214a783" id="r_a08dd9a33977e5ef7878079085214a783"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a08dd9a33977e5ef7878079085214a783">lowered_only_ascii</a> () const</td></tr>
<tr class="memdesc:a08dd9a33977e5ef7878079085214a783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in lowercase ASCII characters.  <br /></td></tr>
<tr class="separator:a08dd9a33977e5ef7878079085214a783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3ef69a372dab777c952f22c492689" id="r_a6ae3ef69a372dab777c952f22c492689"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a6ae3ef69a372dab777c952f22c492689">upperred</a> () const</td></tr>
<tr class="memdesc:a6ae3ef69a372dab777c952f22c492689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in upper case Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a6ae3ef69a372dab777c952f22c492689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51ac2887746e40214eeee7d52460f4" id="r_a8d51ac2887746e40214eeee7d52460f4"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a8d51ac2887746e40214eeee7d52460f4">lowered</a> () const</td></tr>
<tr class="memdesc:a8d51ac2887746e40214eeee7d52460f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string in lowercase Unicode characters of the first plane (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a8d51ac2887746e40214eeee7d52460f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29130d837f80814b37c7baa57a22392b" id="r_a29130d837f80814b37c7baa57a22392b"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a29130d837f80814b37c7baa57a22392b">replaced</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern, <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> repl, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a29130d837f80814b37c7baa57a22392b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the string with occurrences of substrings replaced.  <br /></td></tr>
<tr class="separator:a29130d837f80814b37c7baa57a22392b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af142fe005925c6d4503e98ff23e126f8" id="r_af142fe005925c6d4503e98ff23e126f8"><td class="memItemLeft" align="right" valign="top">constexpr expr_replaces&lt; K, N - 1, L - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#af142fe005925c6d4503e98ff23e126f8">replace_init</a> (T &amp;&amp;pattern, M &amp;&amp;repl) const</td></tr>
<tr class="memdesc:af142fe005925c6d4503e98ff23e126f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that produces a string with replaced substrings given by string literals.  <br /></td></tr>
<tr class="separator:af142fe005925c6d4503e98ff23e126f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0ee1f7d2e81f09bbf60becebb3cd32" id="r_a7a0ee1f7d2e81f09bbf60becebb3cd32"><td class="memItemLeft" align="right" valign="top">constexpr R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a7a0ee1f7d2e81f09bbf60becebb3cd32">trimmed</a> () const</td></tr>
<tr class="memdesc:a7a0ee1f7d2e81f09bbf60becebb3cd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the left and right.  <br /></td></tr>
<tr class="separator:a7a0ee1f7d2e81f09bbf60becebb3cd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef209fc5249c973fd6853c37bd6c52d0" id="r_aef209fc5249c973fd6853c37bd6c52d0"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aef209fc5249c973fd6853c37bd6c52d0">trimmed</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:aef209fc5249c973fd6853c37bd6c52d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the left and right.  <br /></td></tr>
<tr class="separator:aef209fc5249c973fd6853c37bd6c52d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c44f690d2f35cd001e2b4a6f8ddd8b" id="r_a50c44f690d2f35cd001e2b4a6f8ddd8b"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a50c44f690d2f35cd001e2b4a6f8ddd8b">trimmed</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a50c44f690d2f35cd001e2b4a6f8ddd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed, left and right.  <br /></td></tr>
<tr class="separator:a50c44f690d2f35cd001e2b4a6f8ddd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5087dc2570361c3733b981749ee0af3" id="r_aa5087dc2570361c3733b981749ee0af3"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aa5087dc2570361c3733b981749ee0af3">trimmed_left</a> () const</td></tr>
<tr class="memdesc:aa5087dc2570361c3733b981749ee0af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the left.  <br /></td></tr>
<tr class="separator:aa5087dc2570361c3733b981749ee0af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b26a03e3f0f06f58695c2bf83085263" id="r_a1b26a03e3f0f06f58695c2bf83085263"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a1b26a03e3f0f06f58695c2bf83085263">trimmed_left</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a1b26a03e3f0f06f58695c2bf83085263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the left.  <br /></td></tr>
<tr class="separator:a1b26a03e3f0f06f58695c2bf83085263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527f7faf2b1c3cb1176f64bc21b64930" id="r_a527f7faf2b1c3cb1176f64bc21b64930"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a527f7faf2b1c3cb1176f64bc21b64930">trimmed_left</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a527f7faf2b1c3cb1176f64bc21b64930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed from the left.  <br /></td></tr>
<tr class="separator:a527f7faf2b1c3cb1176f64bc21b64930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfe9d42e11ad3d5d6402de39ff67194" id="r_a6bfe9d42e11ad3d5d6402de39ff67194"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a6bfe9d42e11ad3d5d6402de39ff67194">trimmed_right</a> () const</td></tr>
<tr class="memdesc:a6bfe9d42e11ad3d5d6402de39ff67194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with whitespace removed on the right.  <br /></td></tr>
<tr class="separator:a6bfe9d42e11ad3d5d6402de39ff67194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e110b24fc0c97c21e59b466e5aa344f" id="r_a8e110b24fc0c97c21e59b466e5aa344f"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a8e110b24fc0c97c21e59b466e5aa344f">trimmed_right</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a8e110b24fc0c97c21e59b466e5aa344f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed from the right.  <br /></td></tr>
<tr class="separator:a8e110b24fc0c97c21e59b466e5aa344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50252bba2dc037ddb4d64c74049f4a3" id="r_aa50252bba2dc037ddb4d64c74049f4a3"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aa50252bba2dc037ddb4d64c74049f4a3">trimmed_right</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:aa50252bba2dc037ddb4d64c74049f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with characters specified by another string removed to the right.  <br /></td></tr>
<tr class="separator:aa50252bba2dc037ddb4d64c74049f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678aa93ea710405b57c42abd110481a5" id="r_a678aa93ea710405b57c42abd110481a5"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a678aa93ea710405b57c42abd110481a5">trimmed_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a678aa93ea710405b57c42abd110481a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, left and right.  <br /></td></tr>
<tr class="separator:a678aa93ea710405b57c42abd110481a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76189081415ac6d1a94f2612796963f3" id="r_a76189081415ac6d1a94f2612796963f3"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a76189081415ac6d1a94f2612796963f3">trimmed_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a76189081415ac6d1a94f2612796963f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, left and right.  <br /></td></tr>
<tr class="separator:a76189081415ac6d1a94f2612796963f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f8d05593c163518bdee7d036a271d3" id="r_ab7f8d05593c163518bdee7d036a271d3"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#ab7f8d05593c163518bdee7d036a271d3">trimmed_left_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab7f8d05593c163518bdee7d036a271d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, left.  <br /></td></tr>
<tr class="separator:ab7f8d05593c163518bdee7d036a271d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2840ba24d010e214d6e30a13ce59215" id="r_aa2840ba24d010e214d6e30a13ce59215"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#aa2840ba24d010e214d6e30a13ce59215">trimmed_left_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:aa2840ba24d010e214d6e30a13ce59215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, left.  <br /></td></tr>
<tr class="separator:aa2840ba24d010e214d6e30a13ce59215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bafb34363268b0e826652945bcf4c0" id="r_a72bafb34363268b0e826652945bcf4c0"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a72bafb34363268b0e826652945bcf4c0">trimmed_right_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a72bafb34363268b0e826652945bcf4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the characters specified by the string literal removed, as well as whitespace characters, right.  <br /></td></tr>
<tr class="separator:a72bafb34363268b0e826652945bcf4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dd40ceb456ffbe03e2317617afcaf9" id="r_a39dd40ceb456ffbe03e2317617afcaf9"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__algs.html#a39dd40ceb456ffbe03e2317617afcaf9">trimmed_right_with_spaces</a> (<a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> pattern) const</td></tr>
<tr class="memdesc:a39dd40ceb456ffbe03e2317617afcaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string, removing characters specified by another string, as well as whitespace characters, right.  <br /></td></tr>
<tr class="separator:a39dd40ceb456ffbe03e2317617afcaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476d90d2e02d4e72e99f4b4e40f3fec" id="r_ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="memItemLeft" align="right" valign="top">constexpr const K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1null__terminated.html#ac476d90d2e02d4e72e99f4b4e40f3fec">c_str</a> () const</td></tr>
<tr class="memdesc:ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a constant character buffer of a string.  <br /></td></tr>
<tr class="separator:ac476d90d2e02d4e72e99f4b4e40f3fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K&gt;<br />
struct simstr::simple_str_nt&lt; K &gt;</div><p>A class that claims to refer to a null-terminated string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- the character type of the string.</td></tr>
  </table>
  </dd>
</dl>
<p>Shows what the function wants to receive as a parameter a string with a zero at the end, for example, she needs to further transfer it to third party API. Without this, she would have to either specify the parameter specific string class, which deprives universality, or would lead to the constant overhead of unnecessary copying of string into the temporary buffer. Null-terminated strings can be sourced from string literals during compilation, or classes that store strings. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a63bd89453f2dba71fbf43d9a849ae659" name="a63bd89453f2dba71fbf43d9a849ae659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bd89453f2dba71fbf43d9a849ae659">&#9670;&#160;</a></span>simple_str_nt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires std::is_same_v&lt;std::remove_const_t&lt;std::remove_pointer_t&lt;std::remove_cvref_t&lt;T&gt;&gt;&gt;, K&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">simstr::simple_str_nt</a>&lt; K &gt;::simple_str_nt </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit constructor from C-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- pointer to a C-string (null-terminated string).</td></tr>
  </table>
  </dd>
</dl>
<p>This is the only constructor of all string objects that accepts a C-string. Calculates its length upon initialization. All other string objects are not initialized C-strings. This is to ensure that <code>strlen</code> is called only in one place in the library, the length of the C-string was calculated only once and was not subsequently lost accidentally when transferred between different types of string objects. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b5321022f75db5f7c791c145e7fe0f1" name="a3b5321022f75db5f7c791c145e7fe0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5321022f75db5f7c791c145e7fe0f1">&#9670;&#160;</a></span>as_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::as_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a number of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- the desired number type. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- check for overflow. </td></tr>
    <tr><td class="paramname">Base</td><td>- the base of the number, from -1 to 36, except 1.<ul>
<li>If 0: then tries to determine the base by the prefix 0[xX] as 16, 0 as 8, otherwise 10.</li>
<li>If -1: then tries to determine the base by prefixes:<ul>
<li>0 or 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
</ul>
</li>
<li>in other cases 10. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- skip whitespace characters at the beginning of the line. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- whether the '+' sign is allowed before a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - a number, the result of the transformation, how much it turned out, or 0 if it overflows. </dd></dl>

</div>
</div>
<a id="af860598fca0df848662d7d8578a8f6da" name="af860598fca0df848662d7d8578a8f6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af860598fca0df848662d7d8578a8f6da">&#9670;&#160;</a></span>as_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- the variable into which the result is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17421202713ebd4d62ddf175023f535" name="ac17421202713ebd4d62ddf175023f535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17421202713ebd4d62ddf175023f535">&#9670;&#160;</a></span>as_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to an integer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- number type, inferred from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- the variable into which the result is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae28acaa475e182b6df9010bd99dfd9c1" name="ae28acaa475e182b6df9010bd99dfd9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28acaa475e182b6df9010bd99dfd9c1">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::at </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the character at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- symbol index. For negative values, it is counted from the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>K - character.</dd></dl>
<p>Does not check for line boundaries. </p>

</div>
</div>
<a id="ac476d90d2e02d4e72e99f4b4e40f3fec" name="ac476d90d2e02d4e72e99f4b4e40f3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac476d90d2e02d4e72e99f4b4e40f3fec">&#9670;&#160;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename Impl&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const K * simstr::null_terminated&lt; K, Impl &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a constant character buffer of a string. </p>
<dl class="section return"><dt>Returns</dt><dd>const K* - pointer to a constant string character buffer </dd></dl>

</div>
</div>
<a id="aac72f56788a268face1e9315ac514390" name="aac72f56788a268face1e9315ac514390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac72f56788a268face1e9315ac514390">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="ae89d481d6eb2d043ac8ce5d0d5e7ec86" name="ae89d481d6eb2d043ac8ce5d0d5e7ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89d481d6eb2d043ac8ce5d0d5e7ec86">&#9670;&#160;</a></span>compare_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::compare_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character and not case sensitive ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a400250ea87cc59daa152dc9ddb57491f" name="a400250ea87cc59daa152dc9ddb57491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400250ea87cc59daa152dc9ddb57491f">&#9670;&#160;</a></span>compare_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::compare_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare strings character by character without taking into account the case of Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="a6e02eb727a2351300d4349d6637fe262" name="a6e02eb727a2351300d4349d6637fe262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e02eb727a2351300d4349d6637fe262">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string contains the specified substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a id="aa371442f5d71650b6759407a74ba7f6c" name="aa371442f5d71650b6759407a74ba7f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa371442f5d71650b6759407a74ba7f6c">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string to the specified buffer. </p>
<p>The method adds <code>\0</code> after the copied characters. Does not exceed buffer boundaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- pointer to buffer </td></tr>
    <tr><td class="paramname">bufSize</td><td>- buffer size in characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a748fd0f63cd688dbfbbb12ddb4ad0042" name="a748fd0f63cd688dbfbbb12ddb4ad0042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748fd0f63cd688dbfbbb12ddb4ad0042">&#9670;&#160;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc8ac7184386cd4e60e65c799cf5df83" name="adc8ac7184386cd4e60e65c799cf5df83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8ac7184386cd4e60e65c799cf5df83">&#9670;&#160;</a></span>ends_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::ends_with_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring in a case-insensitive ASCII character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a535d655a6702861b788830a1d266e48f" name="a535d655a6702861b788830a1d266e48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535d655a6702861b788830a1d266e48f">&#9670;&#160;</a></span>ends_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::ends_with_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string ends with the specified substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef8402c183e1c28ed0f06aa2fe28bedc" name="aef8402c183e1c28ed0f06aa2fe28bedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8402c183e1c28ed0f06aa2fe28bedc">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String comparison for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a2cd1a4d1a8b9c8e5aaa199f8914fe474" name="a2cd1a4d1a8b9c8e5aaa199f8914fe474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd1a4d1a8b9c8e5aaa199f8914fe474">&#9670;&#160;</a></span>equal_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::equal_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is equal to another string, character-by-character-insensitive, of ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="adbf0990c46a280cd363da46bef12e02f" name="adbf0990c46a280cd363da46bef12e02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf0990c46a280cd363da46bef12e02f">&#9670;&#160;</a></span>equal_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::equal_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is equal to another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a4000d2493f15cd529bc78ae2d1c581c7" name="a4000d2493f15cd529bc78ae2d1c581c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4000d2493f15cd529bc78ae2d1c581c7">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a8390e23702a40a3f550fce9c04d1e8d1" name="a8390e23702a40a3f550fce9c04d1e8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8390e23702a40a3f550fce9c04d1e8d1">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a713475a34317581d09f86728d8ddb44c" name="a713475a34317581d09f86728d8ddb44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713475a34317581d09f86728d8ddb44c">&#9670;&#160;</a></span>find_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all occurrences of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- the maximum number of occurrences to be processed, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;size_t&gt; - a vector with the positions of the beginnings of the found occurrences. </dd></dl>

</div>
</div>
<a id="ad6ccd354949c2af5ed75676b36791527" name="ad6ccd354949c2af5ed75676b36791527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ccd354949c2af5ed75676b36791527">&#9670;&#160;</a></span>find_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a3c54be3da183bf0f7f04071c484ceff7" name="a3c54be3da183bf0f7f04071c484ceff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c54be3da183bf0f7f04071c484ceff7">&#9670;&#160;</a></span>find_end_of_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_end_of_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the last occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the last occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a5ef25980678fac58bdf7112e3354eb68" name="a5ef25980678fac58bdf7112e3354eb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef25980678fac58bdf7112e3354eb68">&#9670;&#160;</a></span>find_end_of_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_end_of_last_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the last occurrence of a substring in this string, or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the last occurrence of the substring, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="ae90a9f3ade055eb5db285d726f388f64" name="ae90a9f3ade055eb5db285d726f388f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90a9f3ade055eb5db285d726f388f64">&#9670;&#160;</a></span>find_end_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_end_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the end of the first occurrence of a substring in this string, or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position immediately after the occurrence of the substring, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="aff07b785db7f341898a931ecffee7056" name="aff07b785db7f341898a931ecffee7056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff07b785db7f341898a931ecffee7056">&#9670;&#160;</a></span>find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character not from the given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the character set. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ac0216228858201c6bd0c0375dcb3d575" name="ac0216228858201c6bd0c0375dcb3d575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0216228858201c6bd0c0375dcb3d575">&#9670;&#160;</a></span>find_first_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a97bb2222b4e7c3830bacd27357b5733e" name="a97bb2222b4e7c3830bacd27357b5733e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bb2222b4e7c3830bacd27357b5733e">&#9670;&#160;</a></span>find_first_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_first_of_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t, size_t&gt; - a pair from the position of the found occurrence and the number of the found character in the set, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ae7f7e754f87cfa55e8ec0bcb4f44efc1" name="ae7f7e754f87cfa55e8ec0bcb4f44efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f7e754f87cfa55e8ec0bcb4f44efc1">&#9670;&#160;</a></span>find_last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a8ee58c2b8fd6e049423cb859dd7ad164" name="a8ee58c2b8fd6e049423cb859dd7ad164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee58c2b8fd6e049423cb859dd7ad164">&#9670;&#160;</a></span>find_last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the last occurrence of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the occurrence of the substring, or -1 if not found. </dd></dl>

</div>
</div>
<a id="adc411c9a47381f1b565f9931e7ee6d07" name="adc411c9a47381f1b565f9931e7ee6d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc411c9a47381f1b565f9931e7ee6d07">&#9670;&#160;</a></span>find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character not from the given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the character set. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="ad775d1f04c93d2ba8a1a32775fd8e3ff" name="ad775d1f04c93d2ba8a1a32775fd8e3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad775d1f04c93d2ba8a1a32775fd8e3ff">&#9670;&#160;</a></span>find_last_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found occurrence, or -1 if not found. </dd></dl>

</div>
</div>
<a id="af12d2001ab5e2aed830cc78a1f718536" name="af12d2001ab5e2aed830cc78a1f718536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12d2001ab5e2aed830cc78a1f718536">&#9670;&#160;</a></span>find_last_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_last_of_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last occurrence of a character from a given character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the set of characters to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t, size_t&gt; - a pair from the position of the found occurrence and the number of the found character in the set, or -1 if not found. </dd></dl>

</div>
</div>
<a id="a3683cb297886257bd6259c2e0f77bd21" name="a3683cb297886257bd6259c2e0f77bd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3683cb297886257bd6259c2e0f77bd21">&#9670;&#160;</a></span>find_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_last_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the last occurrence of a substring in this string or the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to search in the opposite direction, -1 - from the very end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position at which the substring begins, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a76489dd5307a12260f1766f514016fe6" name="a76489dd5307a12260f1766f514016fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76489dd5307a12260f1766f514016fe6">&#9670;&#160;</a></span>find_or_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a character in this string or the end of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is an optional character. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - position of the found character, or string length if not found. </dd></dl>

</div>
</div>
<a id="a58d58b99ec86c7c0f469349c12ad07de" name="a58d58b99ec86c7c0f469349c12ad07de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d58b99ec86c7c0f469349c12ad07de">&#9670;&#160;</a></span>find_or_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string or the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position at which the substring begins, or the length of the string if not found. </dd></dl>

</div>
</div>
<a id="a33894b131f47fba7559eda085111409c" name="a33894b131f47fba7559eda085111409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33894b131f47fba7559eda085111409c">&#9670;&#160;</a></span>find_or_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::find_or_throw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the beginning of the first occurrence of a substring in this string or throw an exception. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exc</td><td>- exception type. </td></tr>
    <tr><td class="paramname">Args...</td><td>- types of parameters for constructing an exception, inferred from the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the search string. </td></tr>
    <tr><td class="paramname">offset</td><td>- from which position to start the search. </td></tr>
    <tr><td class="paramname">args</td><td>- arguments for the exception constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t - the position of the beginning of the substring occurrence, or throws an Exc exception if not found. </dd></dl>

</div>
</div>
<a id="ab344db1789674fe5c9dbd31fcfbbe254" name="ab344db1789674fe5c9dbd31fcfbbe254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab344db1789674fe5c9dbd31fcfbbe254">&#9670;&#160;</a></span>for_all_finded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::for_all_finded </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor on all found occurrences of a substring in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is a functor that takes a string. </td></tr>
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">offset</td><td>- search start position. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- the maximum number of occurrences to be processed, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af56043b721d327307a88b3be41d36bc5" name="af56043b721d327307a88b3be41d36bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56043b721d327307a88b3be41d36bc5">&#9670;&#160;</a></span>from_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::from_to </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the substring <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a> from position from to position to (not including it). </p>
<p>For performance reasons, the method does not check for line boundaries in any way, use in scenarios when you know for sure that these are positions inside the line and to &gt;= from. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- starting position. </td></tr>
    <tr><td class="paramname">to</td><td>- final position (not included in the result). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </dd></dl>

</div>
</div>
<a id="afdaedb195f21ec725e42544784bc2663" name="afdaedb195f21ec725e42544784bc2663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaedb195f21ec725e42544784bc2663">&#9670;&#160;</a></span>is_part_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structsimstr_1_1simple__str.html">simstr::simple_str</a>&lt; K &gt;::is_part_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a string is part of another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6a66a7877b07e9f95d91c71077fdf48" name="ab6a66a7877b07e9f95d91c71077fdf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a66a7877b07e9f95d91c71077fdf48">&#9670;&#160;</a></span>is_same()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structsimstr_1_1simple__str.html">simstr::simple_str</a>&lt; K &gt;::is_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two objects point to the same string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1d3a1a76af2a3153cc4b329e486dac6" name="af1d3a1a76af2a3153cc4b329e486dac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d3a1a76af2a3153cc4b329e486dac6">&#9670;&#160;</a></span>less_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::less_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is smaller than another string, character-by-character-insensitive, ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the string is smaller. </dd></dl>

</div>
</div>
<a id="a4e79e99462478b57d62873f7942ff2b6" name="a4e79e99462478b57d62873f7942ff2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79e99462478b57d62873f7942ff2b6">&#9670;&#160;</a></span>less_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::less_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a string is smaller than another string, character-by-character-insensitive, of the Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the string is smaller. </dd></dl>

</div>
</div>
<a id="a8d51ac2887746e40214eeee7d52460f4" name="a8d51ac2887746e40214eeee7d52460f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d51ac2887746e40214eeee7d52460f4">&#9670;&#160;</a></span>lowered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::lowered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in lowercase Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - lowercase copy of the string. </dd></dl>

</div>
</div>
<a id="a08dd9a33977e5ef7878079085214a783" name="a08dd9a33977e5ef7878079085214a783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dd9a33977e5ef7878079085214a783">&#9670;&#160;</a></span>lowered_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::lowered_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in lowercase ASCII characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - lowercase copy of the string. </dd></dl>

</div>
</div>
<a id="a2d3cdef6c7633c7da8dac91187cc545e" name="a2d3cdef6c7633c7da8dac91187cc545e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3cdef6c7633c7da8dac91187cc545e">&#9670;&#160;</a></span>mid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string as "string chunk". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If the string size is exceeded, it will return an empty string. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". When going beyond the line, it will return everything up to the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </dd></dl>

</div>
</div>
<a id="a2382454e202378bf79672e5f675fb85f" name="a2382454e202378bf79672e5f675fb85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2382454e202378bf79672e5f675fb85f">&#9670;&#160;</a></span>operator const K *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">simstr::simple_str_nt</a>&lt; K &gt;::operator const K * </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator to a null-terminated C string. </p>
<dl class="section return"><dt>Returns</dt><dd>const K* - pointer to the beginning of the line. </dd></dl>

</div>
</div>
<a id="a9cb514b2a1711b54c063b6b77adfb524" name="a9cb514b2a1711b54c063b6b77adfb524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb514b2a1711b54c063b6b77adfb524">&#9670;&#160;</a></span>operator str_piece()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::operator <a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert itself to a "string chunk" that includes the entire string. </p>
<dl class="section return"><dt>Returns</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="a85bb2523d89124db15ab675dd7b661dd" name="a85bb2523d89124db15ab675dd7b661dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bb2523d89124db15ab675dd7b661dd">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string as "simple_str". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring, <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>.</dd></dl>
<p>If <code>from</code> is less than zero, then <code>-from</code> characters are counted from the end of the line towards the beginning. If <code>len</code> is less than or equal to zero, then count <code>-len</code> characters from the end of the line</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, 2) == <span class="stringliteral">&quot;56&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5) == <span class="stringliteral">&quot;56789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, -1) == <span class="stringliteral">&quot;5678&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3) == <span class="stringliteral">&quot;789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3, 2) == <span class="stringliteral">&quot;78&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-4, -1) == <span class="stringliteral">&quot;678&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a882ecc460b3d9e6b6786121796b89372" name="a882ecc460b3d9e6b6786121796b89372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882ecc460b3d9e6b6786121796b89372">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac967d356ab7df7db6245866aa34d5232" name="ac967d356ab7df7db6245866aa34d5232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac967d356ab7df7db6245866aa34d5232">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator between a string and a string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is a string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae891863b2c4ed81e603838890173496d" name="ae891863b2c4ed81e603838890173496d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae891863b2c4ed81e603838890173496d">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator comparing strings for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the strings are equal. </dd></dl>

</div>
</div>
<a id="a3d8ea7c375d988ab82099d10d0779118" name="a3d8ea7c375d988ab82099d10d0779118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8ea7c375d988ab82099d10d0779118">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for comparing a string and a string literal for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ab058c6d2bb0b8c36cafd7c82490943" name="a1ab058c6d2bb0b8c36cafd7c82490943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab058c6d2bb0b8c36cafd7c82490943">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="structsimstr_1_1simple__str.html">simstr::simple_str</a>&lt; K &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the character from the specified position. Bounds checking is not performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- position of the symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>K is a symbol. </dd></dl>

</div>
</div>
<a id="a9efa353bc382a6e476b1180f0cbd64be" name="a9efa353bc382a6e476b1180f0cbd64be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa353bc382a6e476b1180f0cbd64be">&#9670;&#160;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::place </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string to the specified buffer. </p>
<p>The method assumes that the size of the allocated buffer is sufficient for the entire line, i.e. <code><a class="el" href="structsimstr_1_1simple__str.html#a574c8578274b5cc7a3e9507e8669d343" title="Get the length of the string.">length()</a></code> was previously requested. Does not add <code>\0</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- pointer to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the character after the end of the symbols placed in the buffer. </dd></dl>

</div>
</div>
<a id="a3d9b707b45b955a9d525f5f699b82341" name="a3d9b707b45b955a9d525f5f699b82341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9b707b45b955a9d525f5f699b82341">&#9670;&#160;</a></span>prefix_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::prefix_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this string is the beginning of another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71ad322b41b70f1d49e735e2e5456c16" name="a71ad322b41b70f1d49e735e2e5456c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ad322b41b70f1d49e735e2e5456c16">&#9670;&#160;</a></span>remove_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a> &amp; <a class="el" href="structsimstr_1_1simple__str.html">simstr::simple_str</a>&lt; K &gt;::remove_prefix </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the start of a line by the specified number of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>- number of characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp;. </dd></dl>

</div>
</div>
<a id="a442986ca3c3ff2e67b53240cca4d2cd6" name="a442986ca3c3ff2e67b53240cca4d2cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442986ca3c3ff2e67b53240cca4d2cd6">&#9670;&#160;</a></span>remove_suffix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a> &amp; <a class="el" href="structsimstr_1_1simple__str.html">simstr::simple_str</a>&lt; K &gt;::remove_suffix </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortens the string by the specified number of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>- number of characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type&amp;. </dd></dl>

</div>
</div>
<a id="af142fe005925c6d4503e98ff23e126f8" name="af142fe005925c6d4503e98ff23e126f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142fe005925c6d4503e98ff23e126f8">&#9670;&#160;</a></span>replace_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_replaces&lt; K, N - 1, L - 1 &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::replace_init </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>repl</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string expression that produces a string with replaced substrings given by string literals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- string literal, substring to be changed. </td></tr>
    <tr><td class="paramname">repl</td><td>- string literal, substring to change to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression that replaces substrings. </dd></dl>

</div>
</div>
<a id="a29130d837f80814b37c7baa57a22392b" name="a29130d837f80814b37c7baa57a22392b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29130d837f80814b37c7baa57a22392b">&#9670;&#160;</a></span>replaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::replaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string with occurrences of substrings replaced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- the substring to search for. </td></tr>
    <tr><td class="paramname">repl</td><td>- the string to replace with. </td></tr>
    <tr><td class="paramname">offset</td><td>- starting position of the search. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- maximum number of replacements, 0 - no restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R a string of the given type, by default the same whose method was called. </dd></dl>

</div>
</div>
<a id="a032bb26b7a123fc2a391597e0b1478c8" name="a032bb26b7a123fc2a391597e0b1478c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032bb26b7a123fc2a391597e0b1478c8">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the string in characters. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="a346fe7eb58168d714387f2c3065f78d0" name="a346fe7eb58168d714387f2c3065f78d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346fe7eb58168d714387f2c3065f78d0">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimeter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into substrings using a given delimiter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- container type for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeter</td><td>- delimiter. </td></tr>
    <tr><td class="paramname">offset</td><td>- the position to start searching for the separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - container with the result. </dd></dl>

</div>
</div>
<a id="aed0476580fd6fa230fd46d0fe5a1f33e" name="aed0476580fd6fa230fd46d0fe5a1f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0476580fd6fa230fd46d0fe5a1f33e">&#9670;&#160;</a></span>splitf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::splitf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimeter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>beforeFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string into parts at a given delimiter, possibly applying a functor to each substring. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of container for folding substrings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeter</td><td>- substring delimiter. </td></tr>
    <tr><td class="paramname">beforeFunc</td><td>- a functor to apply to the found substrings, before placing them in the result. </td></tr>
    <tr><td class="paramname">offset</td><td>- the position to start searching for the separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T - result.</dd></dl>
<p>For each substring found, if the functor can accept it, the functor is called, and the substring is assigned to the result of the functor. Next, the substring tries to be added to the result, calling one of its methods - <code>emplace_back</code>, <code>push_back</code>, <code>operator[]</code>. If none of this method no, nothing is done, just calling the functor. <code>operator[]</code> tries to apply if the result can have a size via <code>std::size</code> and we do not exceed this size. At the same time, if the found substring turns out to match the entire string, the result is attempted place not a substring, but the entire string object, which allows, for example, to effectively copy sstring. </p>

</div>
</div>
<a id="ac25dce601de84e9e5f0c78de89a71cf9" name="ac25dce601de84e9e5f0c78de89a71cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25dce601de84e9e5f0c78de89a71cf9">&#9670;&#160;</a></span>splitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1_splitter.html">Splitter</a>&lt; K &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::splitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>delimeter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <code><a class="el" href="classsimstr_1_1_splitter.html" title="Class for sequentially obtaining substrings by a given delimiter.">Splitter</a></code> object by the given splitter, which allows sequential get substrings using the <code>next()</code> method while <code>is_done()</code> is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeter</td><td>- delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsimstr_1_1_splitter.html" title="Class for sequentially obtaining substrings by a given delimiter.">Splitter&lt;K&gt;</a>. </dd></dl>

</div>
</div>
<a id="a0749cac4a635847a7a57e244281fcd97" name="a0749cac4a635847a7a57e244281fcd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0749cac4a635847a7a57e244281fcd97">&#9670;&#160;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string begins with the given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affea5af6d58202e885267ae12615e3fb" name="affea5af6d58202e885267ae12615e3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affea5af6d58202e885267ae12615e3fb">&#9670;&#160;</a></span>starts_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::starts_with_ia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string begins with the given substring in a case-insensitive ASCII character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26465c7fdac87e8d215e836bdbf6e8c3" name="a26465c7fdac87e8d215e836bdbf6e8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26465c7fdac87e8d215e836bdbf6e8c3">&#9670;&#160;</a></span>starts_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::starts_with_iu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the string starts with the given substring, case-insensitive Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- substring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62256e9942d3337c50a9458374ac52f3" name="a62256e9942d3337c50a9458374ac52f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62256e9942d3337c50a9458374ac52f3">&#9670;&#160;</a></span>str_mid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a> <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::str_mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get part of a string with an object of the same type to which the method is applied, similar to mid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If the string size is exceeded, it will return an empty string. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". When going beyond the line, it will return everything up to the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the same type to which the method is applied. </dd></dl>

</div>
</div>
<a id="ab4cbab476dcc336ea5f2bceee89b14ca" name="ab4cbab476dcc336ea5f2bceee89b14ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cbab476dcc336ea5f2bceee89b14ca">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::strcmp </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare with C-string character by character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- another line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 this string is less, ==0 - strings are equal, &gt;0 - this string is greater. </dd></dl>

</div>
</div>
<a id="ab8d443fd3ca34c3e6ebd728e2f511acb" name="ab8d443fd3ca34c3e6ebd728e2f511acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d443fd3ca34c3e6ebd728e2f511acb">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a> <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a substring. Works similarly to operator(), only the result is the same type as the method applied to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- number of characters from the beginning of the line. If less than zero, it is counted from the end of the line towards the beginning. </td></tr>
    <tr><td class="paramname">len</td><td>- the number of characters in the resulting "chunk". If less than or equal to zero, then count len characters from the end of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type - a substring, an object of the same type to which the method is applied. </dd></dl>

</div>
</div>
<a id="aa1af52e61e73c687a34ff6978304edc3" name="aa1af52e61e73c687a34ff6978304edc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af52e61e73c687a34ff6978304edc3">&#9670;&#160;</a></span>to_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::to_double </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to double. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="a683d9d722cc772870832128793e8a624" name="a683d9d722cc772870832128793e8a624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683d9d722cc772870832128793e8a624">&#9670;&#160;</a></span>to_double_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::to_double_hex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string in hex form to double. </p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="a356a572ad74e9d512c0d36d1e6699d96" name="a356a572ad74e9d512c0d36d1e6699d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a572ad74e9d512c0d36d1e6699d96">&#9670;&#160;</a></span>to_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">convert_result&lt; T &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::to_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string to a number of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- the desired number type. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- check for overflow. </td></tr>
    <tr><td class="paramname">Base</td><td>- the base of the number, from -1 to 36, except 1.<ul>
<li>If 0: then tries to determine the base by the prefix 0[xX] as 16, 0 as 8, otherwise 10</li>
<li>If -1: then tries to determine the base by prefixes:<ul>
<li>0 or 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
</ul>
</li>
<li>in other cases 10. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- skip whitespace characters at the beginning of the line. All characters with ASCII codes &lt;= 32 are skipped. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- whether the '+' sign is allowed before a number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>convert_result&lt;T&gt; - a tuple of the received number, the success of the conversion and the number of characters processed. </dd></dl>

</div>
</div>
<a id="a5208a3e746ac41a843a4bff0582d4b1a" name="a5208a3e746ac41a843a4bff0582d4b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5208a3e746ac41a843a4bff0582d4b1a">&#9670;&#160;</a></span>to_nts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str__nt.html">my_type</a> <a class="el" href="structsimstr_1_1simple__str__nt.html">simstr::simple_str_nt</a>&lt; K &gt;::to_nts </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a null-terminated string by shifting the start by the specified number of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- by how many characters to shift the beginning of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>my_type. </dd></dl>

</div>
</div>
<a id="a19d10266d4f76dfa7e1f79e603e947b1" name="a19d10266d4f76dfa7e1f79e603e947b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d10266d4f76dfa7e1f79e603e947b1">&#9670;&#160;</a></span>to_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a> <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::to_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert itself to a "string chunk" that includes the entire string. </p>
<dl class="section return"><dt>Returns</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="af14461bfb4a7760db97bf50bb834c197" name="af14461bfb4a7760db97bf50bb834c197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14461bfb4a7760db97bf50bb834c197">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; K &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::string. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a1c4e13ca8dd62c156b460b40be5722d8" name="a1c4e13ca8dd62c156b460b40be5722d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4e13ca8dd62c156b460b40be5722d8">&#9670;&#160;</a></span>to_sv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string_view&lt; K &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::to_sv </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to std::string_view. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a7a0ee1f7d2e81f09bbf60becebb3cd32" name="a7a0ee1f7d2e81f09bbf60becebb3cd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0ee1f7d2e81f09bbf60becebb3cd32">&#9670;&#160;</a></span>trimmed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with whitespace characters removed at the beginning and end. </dd></dl>

</div>
</div>
<a id="a50c44f690d2f35cd001e2b4a6f8ddd8b" name="a50c44f690d2f35cd001e2b4a6f8ddd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c44f690d2f35cd001e2b4a6f8ddd8b">&#9670;&#160;</a></span>trimmed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and at the end. </dd></dl>

</div>
</div>
<a id="aef209fc5249c973fd6853c37bd6c52d0" name="aef209fc5249c973fd6853c37bd6c52d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef209fc5249c973fd6853c37bd6c52d0">&#9670;&#160;</a></span>trimmed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and at the end. </dd></dl>

</div>
</div>
<a id="aa5087dc2570361c3733b981749ee0af3" name="aa5087dc2570361c3733b981749ee0af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5087dc2570361c3733b981749ee0af3">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with leading whitespace characters removed. </dd></dl>

</div>
</div>
<a id="a527f7faf2b1c3cb1176f64bc21b64930" name="a527f7faf2b1c3cb1176f64bc21b64930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527f7faf2b1c3cb1176f64bc21b64930">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed from the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning. </dd></dl>

</div>
</div>
<a id="a1b26a03e3f0f06f58695c2bf83085263" name="a1b26a03e3f0f06f58695c2bf83085263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b26a03e3f0f06f58695c2bf83085263">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning. </dd></dl>

</div>
</div>
<a id="aa2840ba24d010e214d6e30a13ce59215" name="aa2840ba24d010e214d6e30a13ce59215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2840ba24d010e214d6e30a13ce59215">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and whitespace characters. </dd></dl>

</div>
</div>
<a id="ab7f8d05593c163518bdee7d036a271d3" name="ab7f8d05593c163518bdee7d036a271d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f8d05593c163518bdee7d036a271d3">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, left. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and whitespace characters. </dd></dl>

</div>
</div>
<a id="a6bfe9d42e11ad3d5d6402de39ff67194" name="a6bfe9d42e11ad3d5d6402de39ff67194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfe9d42e11ad3d5d6402de39ff67194">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with whitespace removed on the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with whitespace characters removed at the end. </dd></dl>

</div>
</div>
<a id="aa50252bba2dc037ddb4d64c74049f4a3" name="aa50252bba2dc037ddb4d64c74049f4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50252bba2dc037ddb4d64c74049f4a3">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with characters specified by another string removed to the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the pattern removed at the end. </dd></dl>

</div>
</div>
<a id="a8e110b24fc0c97c21e59b466e5aa344f" name="a8e110b24fc0c97c21e59b466e5aa344f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e110b24fc0c97c21e59b466e5aa344f">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed from the right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the literal removed at the end. </dd></dl>

</div>
</div>
<a id="a39dd40ceb456ffbe03e2317617afcaf9" name="a39dd40ceb456ffbe03e2317617afcaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dd40ceb456ffbe03e2317617afcaf9">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the template removed at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a72bafb34363268b0e826652945bcf4c0" name="a72bafb34363268b0e826652945bcf4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bafb34363268b0e826652945bcf4c0">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with characters contained in the literal removed at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a76189081415ac6d1a94f2612796963f3" name="a76189081415ac6d1a94f2612796963f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76189081415ac6d1a94f2612796963f3">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimstr_1_1simple__str.html">str_piece</a></td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string, removing characters specified by another string, as well as whitespace characters, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- a string specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the pattern removed at the beginning and at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a678aa93ea710405b57c42abd110481a5" name="a678aa93ea710405b57c42abd110481a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678aa93ea710405b57c42abd110481a5">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string with the characters specified by the string literal removed, as well as whitespace characters, left and right. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- desired string type, default <a class="el" href="structsimstr_1_1simple__str.html" title="The simplest immutable non-owning string class.">simple_str</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>is a string literal specifying the characters that will be trimmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - a string with the characters contained in the literal removed at the beginning and at the end and whitespace characters. </dd></dl>

</div>
</div>
<a id="a6ae3ef69a372dab777c952f22c492689" name="a6ae3ef69a372dab777c952f22c492689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3ef69a372dab777c952f22c492689">&#9670;&#160;</a></span>upperred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::upperred </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in upper case Unicode characters of the first plane (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - uppercase copy of the string. </dd></dl>

</div>
</div>
<a id="a30dffe997b57c8543ac242fff94b346a" name="a30dffe997b57c8543ac242fff94b346a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dffe997b57c8543ac242fff94b346a">&#9670;&#160;</a></span>upperred_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, <a class="el" href="structsimstr_1_1simple__str.html">simple_str</a>&lt; K &gt;, Mutable &gt;::upperred_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the string in uppercase ASCII characters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- the desired string type, by default the same whose method was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R - uppercase copy of the string. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="sstring_8h_source.html">sstring.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimstr.html">simstr</a></li><li class="navelem"><a class="el" href="structsimstr_1_1simple__str__nt.html">simple_str_nt</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: Шаблон класса simstr::str_algs&lt; K, StrRef, Impl, Mutable &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.6.0</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsimstr_1_1str__algs.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="classsimstr_1_1str__algs-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle"><div class="title">Шаблон класса simstr::str_algs&lt; K, StrRef, Impl, Mutable &gt;</div></div>
</div><!--header-->
<div class="contents">

<p>Класс с дополнительными константными строковыми алгоритмами.  
 <a href="#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="sstring_8h_source.html">sstring.h</a>&gt;</code></p>
<div class="dynheader">
Граф наследования:simstr::str_algs&lt; K, StrRef, Impl, Mutable &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsimstr_1_1str__algs.png" usemap="#simstr::str_5Falgs_3C_20K_2C_20StrRef_2C_20Impl_2C_20Mutable_20_3E_map" alt=""/>
  <map id="simstr::str_5Falgs_3C_20K_2C_20StrRef_2C_20Impl_2C_20Mutable_20_3E_map" name="simstr::str_5Falgs_3C_20K_2C_20StrRef_2C_20Impl_2C_20Mutable_20_3E_map">
<area href="classsimstr_1_1str__src__algs.html" title="Класс с базовыми константными строковыми алгоритмами." alt="simstr::str_src_algs&lt; K, StrRef, Impl, Mutable &gt;" shape="rect" coords="0,0,280,24"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; K, N, forShared, Allocator &gt;" shape="rect" coords="290,112,570,136"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u8s, N &gt;" shape="rect" coords="290,168,570,192"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; ubs, N &gt;" shape="rect" coords="290,224,570,248"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; wchar_t, N &gt;" shape="rect" coords="290,280,570,304"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u16s, N &gt;" shape="rect" coords="290,336,570,360"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u32s, N &gt;" shape="rect" coords="290,392,570,416"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u8s, N, true &gt;" shape="rect" coords="290,448,570,472"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; ubs, N, true &gt;" shape="rect" coords="290,504,570,528"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; wchar_t, N, true &gt;" shape="rect" coords="290,560,570,584"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u16s, N, true &gt;" shape="rect" coords="290,616,570,640"/>
<area href="classsimstr_1_1lstring.html" alt="simstr::lstring&lt; u32s, N, true &gt;" shape="rect" coords="290,672,570,696"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; u8s &gt;" shape="rect" coords="290,728,570,752"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; ubs &gt;" shape="rect" coords="290,784,570,808"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; wchar_t &gt;" shape="rect" coords="290,840,570,864"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; u16s &gt;" shape="rect" coords="290,896,570,920"/>
<area href="structsimstr_1_1simple__str.html" alt="simstr::simple_str&lt; u32s &gt;" shape="rect" coords="290,952,570,976"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; K, Allocator &gt;" shape="rect" coords="290,1008,570,1032"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; u8s &gt;" shape="rect" coords="290,1064,570,1088"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; ubs &gt;" shape="rect" coords="290,1120,570,1144"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; wchar_t &gt;" shape="rect" coords="290,1176,570,1200"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; u16s &gt;" shape="rect" coords="290,1232,570,1256"/>
<area href="classsimstr_1_1sstring.html" alt="simstr::sstring&lt; u32s &gt;" shape="rect" coords="290,1288,570,1312"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:a400250ea87cc59daa152dc9ddb57491f" id="r_a400250ea87cc59daa152dc9ddb57491f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400250ea87cc59daa152dc9ddb57491f">compare_iu</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:a400250ea87cc59daa152dc9ddb57491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение строк посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a400250ea87cc59daa152dc9ddb57491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf0990c46a280cd363da46bef12e02f" id="r_adbf0990c46a280cd363da46bef12e02f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbf0990c46a280cd363da46bef12e02f">equal_iu</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:adbf0990c46a280cd363da46bef12e02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Равна ли строка другой строке посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:adbf0990c46a280cd363da46bef12e02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79e99462478b57d62873f7942ff2b6" id="r_a4e79e99462478b57d62873f7942ff2b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e79e99462478b57d62873f7942ff2b6">less_iu</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:a4e79e99462478b57d62873f7942ff2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Меньше ли строка другой строки посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a4e79e99462478b57d62873f7942ff2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26465c7fdac87e8d215e836bdbf6e8c3" id="r_a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26465c7fdac87e8d215e836bdbf6e8c3">starts_with_iu</a> (str_piece prefix) const noexcept</td></tr>
<tr class="memdesc:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Начинается ли строка с заданной подстроки без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a26465c7fdac87e8d215e836bdbf6e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535d655a6702861b788830a1d266e48f" id="r_a535d655a6702861b788830a1d266e48f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a535d655a6702861b788830a1d266e48f">ends_with_iu</a> (str_piece suffix) const noexcept</td></tr>
<tr class="memdesc:a535d655a6702861b788830a1d266e48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заканчивается ли строка указанной подстрокой без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a535d655a6702861b788830a1d266e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3ef69a372dab777c952f22c492689" id="r_a6ae3ef69a372dab777c952f22c492689"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a6ae3ef69a372dab777c952f22c492689"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ae3ef69a372dab777c952f22c492689">upperred</a> () const</td></tr>
<tr class="memdesc:a6ae3ef69a372dab777c952f22c492689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки в верхнем регистре Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a6ae3ef69a372dab777c952f22c492689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51ac2887746e40214eeee7d52460f4" id="r_a8d51ac2887746e40214eeee7d52460f4"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a8d51ac2887746e40214eeee7d52460f4"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d51ac2887746e40214eeee7d52460f4">lowered</a> () const</td></tr>
<tr class="memdesc:a8d51ac2887746e40214eeee7d52460f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки в нижнем регистре Unicode символов первой плоскости (&lt;0xFFFF).  <br /></td></tr>
<tr class="separator:a8d51ac2887746e40214eeee7d52460f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af52e61e73c687a34ff6978304edc3" id="r_aa1af52e61e73c687a34ff6978304edc3"><td class="memTemplParams" colspan="2">template&lt;bool SkipWS = true, bool AllowPlus = true&gt; </td></tr>
<tr class="memitem:aa1af52e61e73c687a34ff6978304edc3"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1af52e61e73c687a34ff6978304edc3">to_double</a> () const noexcept</td></tr>
<tr class="memdesc:aa1af52e61e73c687a34ff6978304edc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в double.  <br /></td></tr>
<tr class="separator:aa1af52e61e73c687a34ff6978304edc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860598fca0df848662d7d8578a8f6da" id="r_af860598fca0df848662d7d8578a8f6da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af860598fca0df848662d7d8578a8f6da">as_number</a> (double &amp;t) const</td></tr>
<tr class="memdesc:af860598fca0df848662d7d8578a8f6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в double.  <br /></td></tr>
<tr class="separator:af860598fca0df848662d7d8578a8f6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17421202713ebd4d62ddf175023f535" id="r_ac17421202713ebd4d62ddf175023f535"><td class="memTemplParams" colspan="2">template&lt;ToIntNumber T&gt; </td></tr>
<tr class="memitem:ac17421202713ebd4d62ddf175023f535"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac17421202713ebd4d62ddf175023f535">as_number</a> (T &amp;t) const</td></tr>
<tr class="memdesc:ac17421202713ebd4d62ddf175023f535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в целое число.  <br /></td></tr>
<tr class="separator:ac17421202713ebd4d62ddf175023f535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af893677739e0d24418f6acc0a29090cc" id="r_af893677739e0d24418f6acc0a29090cc"><td class="memItemLeft" align="right" valign="top">constexpr K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#af893677739e0d24418f6acc0a29090cc">place</a> (K *ptr) const noexcept</td></tr>
<tr class="memdesc:af893677739e0d24418f6acc0a29090cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Копировать строку в указанный буфер.  <br /></td></tr>
<tr class="separator:af893677739e0d24418f6acc0a29090cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2498615b426546b65e9b6c4f973264" id="r_a3c2498615b426546b65e9b6c4f973264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a3c2498615b426546b65e9b6c4f973264">copy_to</a> (K *buffer, size_t bufSize)</td></tr>
<tr class="memdesc:a3c2498615b426546b65e9b6c4f973264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Копировать строку в указанный буфер.  <br /></td></tr>
<tr class="separator:a3c2498615b426546b65e9b6c4f973264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2732ccf421fcd1ba606addcca7e6e42" id="r_aa2732ccf421fcd1ba606addcca7e6e42"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa2732ccf421fcd1ba606addcca7e6e42">size</a> () const</td></tr>
<tr class="memdesc:aa2732ccf421fcd1ba606addcca7e6e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер строки в символах.  <br /></td></tr>
<tr class="separator:aa2732ccf421fcd1ba606addcca7e6e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2af1ee80a32a77ad30cffbf6987107" id="r_a1f2af1ee80a32a77ad30cffbf6987107"><td class="memTemplParams" colspan="2">template&lt;typename D = K&gt; <br />
requires is_equal_str_type_v&lt;K, D&gt;</td></tr>
<tr class="memitem:a1f2af1ee80a32a77ad30cffbf6987107"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::basic_string_view&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a1f2af1ee80a32a77ad30cffbf6987107">to_sv</a> () const noexcept</td></tr>
<tr class="memdesc:a1f2af1ee80a32a77ad30cffbf6987107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конвертировать в std::basic_string_view.  <br /></td></tr>
<tr class="separator:a1f2af1ee80a32a77ad30cffbf6987107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c6b4c365f05e609a7b22cbf37b39c6" id="r_ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memTemplParams" colspan="2">template&lt;typename D, typename Traits&gt; <br />
requires is_equal_str_type_v&lt;K, D&gt;</td></tr>
<tr class="memitem:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab4c6b4c365f05e609a7b22cbf37b39c6">operator std::basic_string_view&lt; D, Traits &gt;</a> () const</td></tr>
<tr class="memdesc:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конвертировать в std::basic_string_view.  <br /></td></tr>
<tr class="separator:ab4c6b4c365f05e609a7b22cbf37b39c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc816f095922a510dfe466db1905fc63" id="r_adc816f095922a510dfe466db1905fc63"><td class="memTemplParams" colspan="2">template&lt;typename D = K, typename Traits = std::char_traits&lt;D&gt;, typename Allocator = std::allocator&lt;D&gt;&gt; <br />
requires is_equal_str_type_v&lt;K, D&gt;</td></tr>
<tr class="memitem:adc816f095922a510dfe466db1905fc63"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::basic_string&lt; D, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#adc816f095922a510dfe466db1905fc63">to_string</a> () const</td></tr>
<tr class="memdesc:adc816f095922a510dfe466db1905fc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конвертировать в std::basic_string.  <br /></td></tr>
<tr class="separator:adc816f095922a510dfe466db1905fc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9959513e8a072c51620248c4a29f4196" id="r_a9959513e8a072c51620248c4a29f4196"><td class="memTemplParams" colspan="2">template&lt;typename D, typename Traits, typename Allocator&gt; <br />
requires is_equal_str_type_v&lt;K, D&gt;</td></tr>
<tr class="memitem:a9959513e8a072c51620248c4a29f4196"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9959513e8a072c51620248c4a29f4196">operator std::basic_string&lt; D, Traits, Allocator &gt;</a> () const</td></tr>
<tr class="memdesc:a9959513e8a072c51620248c4a29f4196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конвертировать в std::basic_string.  <br /></td></tr>
<tr class="separator:a9959513e8a072c51620248c4a29f4196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916218a7a75a3866a9d3d0da9334653c" id="r_a916218a7a75a3866a9d3d0da9334653c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a916218a7a75a3866a9d3d0da9334653c">operator str_piece</a> () const noexcept</td></tr>
<tr class="memdesc:a916218a7a75a3866a9d3d0da9334653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать себя в "кусок строки", включающий всю строку.  <br /></td></tr>
<tr class="separator:a916218a7a75a3866a9d3d0da9334653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d19b3fba03bfd481d2a3b3def766af" id="r_a53d19b3fba03bfd481d2a3b3def766af"><td class="memItemLeft" align="right" valign="top">constexpr str_piece&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a53d19b3fba03bfd481d2a3b3def766af">to_str</a> () const noexcept</td></tr>
<tr class="memdesc:a53d19b3fba03bfd481d2a3b3def766af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать себя в "кусок строки", включающий всю строку.  <br /></td></tr>
<tr class="separator:a53d19b3fba03bfd481d2a3b3def766af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8f275b33545d2491850f49ba3b7876" id="r_ace8f275b33545d2491850f49ba3b7876"><td class="memItemLeft" align="right" valign="top">constexpr str_piece&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ace8f275b33545d2491850f49ba3b7876">operator()</a> (ptrdiff_t from, ptrdiff_t len=0) const noexcept</td></tr>
<tr class="memdesc:ace8f275b33545d2491850f49ba3b7876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить часть строки как "str_src".  <br /></td></tr>
<tr class="separator:ace8f275b33545d2491850f49ba3b7876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507a43e6ebcc51e6409874712abbbd63" id="r_a507a43e6ebcc51e6409874712abbbd63"><td class="memItemLeft" align="right" valign="top">constexpr str_piece&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a507a43e6ebcc51e6409874712abbbd63">mid</a> (size_t from, size_t len=-1) const noexcept</td></tr>
<tr class="memdesc:a507a43e6ebcc51e6409874712abbbd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить часть строки как "кусок строки".  <br /></td></tr>
<tr class="separator:a507a43e6ebcc51e6409874712abbbd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5659e7fb47dfb6bd6736a1b454ffde92" id="r_a5659e7fb47dfb6bd6736a1b454ffde92"><td class="memItemLeft" align="right" valign="top">constexpr str_piece&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a5659e7fb47dfb6bd6736a1b454ffde92">from_to</a> (size_t from, size_t to) const noexcept</td></tr>
<tr class="memdesc:a5659e7fb47dfb6bd6736a1b454ffde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить подстроку <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a> с позиции от from до позиции to (не включая её).  <br /></td></tr>
<tr class="separator:a5659e7fb47dfb6bd6736a1b454ffde92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a3ed434bc8ecc755076da742f8e5b" id="r_a992a3ed434bc8ecc755076da742f8e5b"><td class="memItemLeft" align="right" valign="top"><a id="a992a3ed434bc8ecc755076da742f8e5b" name="a992a3ed434bc8ecc755076da742f8e5b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!</b> () const noexcept</td></tr>
<tr class="memdesc:a992a3ed434bc8ecc755076da742f8e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка на пустоту. <br /></td></tr>
<tr class="separator:a992a3ed434bc8ecc755076da742f8e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c053de38bf2a0eab39cf1de5b0a21a" id="r_ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="memItemLeft" align="right" valign="top">constexpr K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad2c053de38bf2a0eab39cf1de5b0a21a">at</a> (ptrdiff_t idx) const</td></tr>
<tr class="memdesc:ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить символ на заданной позиции .  <br /></td></tr>
<tr class="separator:ad2c053de38bf2a0eab39cf1de5b0a21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d9cd0dc24f5d395e838a3ef20d846" id="r_a108d9cd0dc24f5d395e838a3ef20d846"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a108d9cd0dc24f5d395e838a3ef20d846">compare</a> (str_piece o) const</td></tr>
<tr class="memdesc:a108d9cd0dc24f5d395e838a3ef20d846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение строк посимвольно.  <br /></td></tr>
<tr class="separator:a108d9cd0dc24f5d395e838a3ef20d846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d501d16ab38c3efb1427f14ea7f67" id="r_a610d501d16ab38c3efb1427f14ea7f67"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a610d501d16ab38c3efb1427f14ea7f67">strcmp</a> (const K *text) const</td></tr>
<tr class="memdesc:a610d501d16ab38c3efb1427f14ea7f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение с C-строкой посимвольно.  <br /></td></tr>
<tr class="separator:a610d501d16ab38c3efb1427f14ea7f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b0cb780c465cb9b6bd925d712ff07" id="r_a3b9b0cb780c465cb9b6bd925d712ff07"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a3b9b0cb780c465cb9b6bd925d712ff07">equal</a> (str_piece other) const noexcept</td></tr>
<tr class="memdesc:a3b9b0cb780c465cb9b6bd925d712ff07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение строк на равенство.  <br /></td></tr>
<tr class="separator:a3b9b0cb780c465cb9b6bd925d712ff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddd0a1f9b25247465fb55c79b58826d" id="r_a1ddd0a1f9b25247465fb55c79b58826d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a1ddd0a1f9b25247465fb55c79b58826d">operator==</a> (const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a1ddd0a1f9b25247465fb55c79b58826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор сравнение строк на равенство.  <br /></td></tr>
<tr class="separator:a1ddd0a1f9b25247465fb55c79b58826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19dc728f9d7edafbd85a52e70b46376" id="r_ac19dc728f9d7edafbd85a52e70b46376"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:ac19dc728f9d7edafbd85a52e70b46376"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac19dc728f9d7edafbd85a52e70b46376">operator==</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ac19dc728f9d7edafbd85a52e70b46376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор сравнения строки и строкового литерала на равенство.  <br /></td></tr>
<tr class="separator:ac19dc728f9d7edafbd85a52e70b46376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34637c1f071ac6e6faa0237a092cc61" id="r_ac34637c1f071ac6e6faa0237a092cc61"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac34637c1f071ac6e6faa0237a092cc61">operator&lt;=&gt;</a> (const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ac34637c1f071ac6e6faa0237a092cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор сравнения строк.  <br /></td></tr>
<tr class="separator:ac34637c1f071ac6e6faa0237a092cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63f315c4a97ee6ad1e2b045b9f5f9e0" id="r_ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </td></tr>
<tr class="memitem:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad63f315c4a97ee6ad1e2b045b9f5f9e0">operator&lt;=&gt;</a> (T &amp;&amp;other) const noexcept</td></tr>
<tr class="memdesc:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Оператор сравнения строки и строкового литерала.  <br /></td></tr>
<tr class="separator:ad63f315c4a97ee6ad1e2b045b9f5f9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5e10ff025504ee5d60e8c77f439003" id="r_a0e5e10ff025504ee5d60e8c77f439003"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0e5e10ff025504ee5d60e8c77f439003">compare_ia</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:a0e5e10ff025504ee5d60e8c77f439003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сравнение строк посимвольно без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:a0e5e10ff025504ee5d60e8c77f439003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9fca49d189fd0d760ffe8aed1485f1" id="r_afa9fca49d189fd0d760ffe8aed1485f1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#afa9fca49d189fd0d760ffe8aed1485f1">equal_ia</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:afa9fca49d189fd0d760ffe8aed1485f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Равна ли строка другой строке посимвольно без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:afa9fca49d189fd0d760ffe8aed1485f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ede528e694988f26555e91cf9a1ca2" id="r_a44ede528e694988f26555e91cf9a1ca2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a44ede528e694988f26555e91cf9a1ca2">less_ia</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:a44ede528e694988f26555e91cf9a1ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Меньше ли строка другой строки посимвольно без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:a44ede528e694988f26555e91cf9a1ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38e5cc7893a20e69cdf03d88232b49c" id="r_ab38e5cc7893a20e69cdf03d88232b49c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab38e5cc7893a20e69cdf03d88232b49c">find</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ab38e5cc7893a20e69cdf03d88232b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало первого вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:ab38e5cc7893a20e69cdf03d88232b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129d72cc64be6029f10bbe1f8385f3ea" id="r_a129d72cc64be6029f10bbe1f8385f3ea"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a129d72cc64be6029f10bbe1f8385f3ea">find</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a129d72cc64be6029f10bbe1f8385f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти символ в этой строке.  <br /></td></tr>
<tr class="separator:a129d72cc64be6029f10bbe1f8385f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab0482ea5f02bc0c3097bed6c9a5fa" id="r_a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memTemplParams" colspan="2">template&lt;typename Exc, typename ... Args&gt; <br />
requires std::is_constructible_v&lt;Exc, Args...&gt;</td></tr>
<tr class="memitem:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a40ab0482ea5f02bc0c3097bed6c9a5fa">find_or_throw</a> (str_piece pattern, size_t offset=0, Args &amp;&amp;... args) const noexcept</td></tr>
<tr class="memdesc:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало первого вхождения подстроки в этой строке или выкинуть исключение.  <br /></td></tr>
<tr class="separator:a40ab0482ea5f02bc0c3097bed6c9a5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcde5878d3d7fd5138d38ff2f1df4d2" id="r_a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a8bcde5878d3d7fd5138d38ff2f1df4d2">find_end</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти конец вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:a8bcde5878d3d7fd5138d38ff2f1df4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029fd5412ed114bfefbdddba2c50167" id="r_ac029fd5412ed114bfefbdddba2c50167"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac029fd5412ed114bfefbdddba2c50167">find_or_all</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac029fd5412ed114bfefbdddba2c50167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало первого вхождения подстроки в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:ac029fd5412ed114bfefbdddba2c50167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762c55d09b34ba2b7b5f9f10783da662" id="r_a762c55d09b34ba2b7b5f9f10783da662"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a762c55d09b34ba2b7b5f9f10783da662">find_or_all</a> (K s, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a762c55d09b34ba2b7b5f9f10783da662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти символ в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:a762c55d09b34ba2b7b5f9f10783da662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c56c3345019c8d5dc20717092d52101" id="r_a2c56c3345019c8d5dc20717092d52101"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a2c56c3345019c8d5dc20717092d52101">find_end_or_all</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a2c56c3345019c8d5dc20717092d52101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти конец первого вхождения подстроки в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:a2c56c3345019c8d5dc20717092d52101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a2c0b10e857c245f67a2abd7c1a2f0" id="r_a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a72a2c0b10e857c245f67a2abd7c1a2f0">find_last</a> (str_piece pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало последнего вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:a72a2c0b10e857c245f67a2abd7c1a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0564461ab81bfbb6c5bd8b4c7e5a496e" id="r_a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0564461ab81bfbb6c5bd8b4c7e5a496e">find_last</a> (K s, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти последнее вхождения символа в этой строке.  <br /></td></tr>
<tr class="separator:a0564461ab81bfbb6c5bd8b4c7e5a496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab67ba06c8637f93984e45cf349c3eb8" id="r_aab67ba06c8637f93984e45cf349c3eb8"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aab67ba06c8637f93984e45cf349c3eb8">find_end_of_last</a> (str_piece pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:aab67ba06c8637f93984e45cf349c3eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти конец последнего вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:aab67ba06c8637f93984e45cf349c3eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5bdd0e7ab4f7e64e1e776f4dabe11c" id="r_a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6a5bdd0e7ab4f7e64e1e776f4dabe11c">find_last_or_all</a> (str_piece pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти начало последнего вхождения подстроки в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:a6a5bdd0e7ab4f7e64e1e776f4dabe11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281c63da2d81ef8aac65a2dad77eb93" id="r_ae281c63da2d81ef8aac65a2dad77eb93"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae281c63da2d81ef8aac65a2dad77eb93">find_end_of_last_or_all</a> (str_piece pattern, size_t offset=-1) const noexcept</td></tr>
<tr class="memdesc:ae281c63da2d81ef8aac65a2dad77eb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти конец последнего вхождения подстроки в этой строке или конец строки.  <br /></td></tr>
<tr class="separator:ae281c63da2d81ef8aac65a2dad77eb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d712294186e2e181910677ba9c3ca7" id="r_ac4d712294186e2e181910677ba9c3ca7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac4d712294186e2e181910677ba9c3ca7">contains</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:ac4d712294186e2e181910677ba9c3ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Содержит ли строка указанную подстроку.  <br /></td></tr>
<tr class="separator:ac4d712294186e2e181910677ba9c3ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8185ccf8fc2297b628cce3c83b6a0b4c" id="r_a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memTemplParams" colspan="2">template&lt;typename Op&gt; </td></tr>
<tr class="memitem:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a8185ccf8fc2297b628cce3c83b6a0b4c">for_all_finded</a> (const Op &amp;op, str_piece pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вызвать функтор для всех найденных вхождений подстроки в этой строке.  <br /></td></tr>
<tr class="separator:a8185ccf8fc2297b628cce3c83b6a0b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d568443f3ed5752279098b9a488655" id="r_aa6d568443f3ed5752279098b9a488655"><td class="memTemplParams" colspan="2">template&lt;typename To = std::vector&lt;size_t&gt;&gt; </td></tr>
<tr class="memitem:aa6d568443f3ed5752279098b9a488655"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa6d568443f3ed5752279098b9a488655">find_all</a> (str_piece pattern, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:aa6d568443f3ed5752279098b9a488655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти все вхождения подстроки в этой строке.  <br /></td></tr>
<tr class="separator:aa6d568443f3ed5752279098b9a488655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bf839edef0abbd43c3f3654e8e700" id="r_a643bf839edef0abbd43c3f3654e8e700"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a643bf839edef0abbd43c3f3654e8e700">find_first_of</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a643bf839edef0abbd43c3f3654e8e700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти первое вхождение символа из заданного набора символов.  <br /></td></tr>
<tr class="separator:a643bf839edef0abbd43c3f3654e8e700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5ad9c702f21003a272469cb1edcbf3" id="r_aad5ad9c702f21003a272469cb1edcbf3"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aad5ad9c702f21003a272469cb1edcbf3">find_first_of_idx</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:aad5ad9c702f21003a272469cb1edcbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти первое вхождение символа из заданного набора символов.  <br /></td></tr>
<tr class="separator:aad5ad9c702f21003a272469cb1edcbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff5e918afcc8e1fba9a3ec19c47897" id="r_a63ff5e918afcc8e1fba9a3ec19c47897"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a63ff5e918afcc8e1fba9a3ec19c47897">find_first_not_of</a> (str_piece pattern, size_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a63ff5e918afcc8e1fba9a3ec19c47897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти первое вхождение символа не из заданного набора символов.  <br /></td></tr>
<tr class="separator:a63ff5e918afcc8e1fba9a3ec19c47897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73806fa93c9ec619ba93d479d413ea0f" id="r_a73806fa93c9ec619ba93d479d413ea0f"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a73806fa93c9ec619ba93d479d413ea0f">find_last_of</a> (str_piece pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:a73806fa93c9ec619ba93d479d413ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти последнее вхождение символа из заданного набора символов.  <br /></td></tr>
<tr class="separator:a73806fa93c9ec619ba93d479d413ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab630d62252bf1210f573a8c7222942c8" id="r_ab630d62252bf1210f573a8c7222942c8"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab630d62252bf1210f573a8c7222942c8">find_last_of_idx</a> (str_piece pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:ab630d62252bf1210f573a8c7222942c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти последнее вхождение символа из заданного набора символов.  <br /></td></tr>
<tr class="separator:ab630d62252bf1210f573a8c7222942c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775a7c8e218ab3223f0248f225076b7c" id="r_a775a7c8e218ab3223f0248f225076b7c"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a775a7c8e218ab3223f0248f225076b7c">find_last_not_of</a> (str_piece pattern, size_t offset=str::npos) const noexcept</td></tr>
<tr class="memdesc:a775a7c8e218ab3223f0248f225076b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Найти последнее вхождение символа не из заданного набора символов.  <br /></td></tr>
<tr class="separator:a775a7c8e218ab3223f0248f225076b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512eaf3c2c8736f3021a5bbe60823866" id="r_a512eaf3c2c8736f3021a5bbe60823866"><td class="memItemLeft" align="right" valign="top">constexpr my_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a512eaf3c2c8736f3021a5bbe60823866">substr</a> (ptrdiff_t from, ptrdiff_t len=0) const</td></tr>
<tr class="memdesc:a512eaf3c2c8736f3021a5bbe60823866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить подстроку. Работает аналогично operator(), только результат выдает того же типа, к которому применён метод.  <br /></td></tr>
<tr class="separator:a512eaf3c2c8736f3021a5bbe60823866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77c31da012cf5cc23e0a60c1888cec2" id="r_aa77c31da012cf5cc23e0a60c1888cec2"><td class="memItemLeft" align="right" valign="top">constexpr my_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa77c31da012cf5cc23e0a60c1888cec2">str_mid</a> (size_t from, size_t len=-1) const</td></tr>
<tr class="memdesc:aa77c31da012cf5cc23e0a60c1888cec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить часть строки объектом того же типа, к которому применён метод, аналогично mid.  <br /></td></tr>
<tr class="separator:aa77c31da012cf5cc23e0a60c1888cec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4213df62c3208dd26ae540122dcfa45d" id="r_a4213df62c3208dd26ae540122dcfa45d"><td class="memTemplParams" colspan="2">template&lt;ToIntNumber T, bool CheckOverflow = true, unsigned Base = 0, bool SkipWs = true, bool AllowSign = true&gt; </td></tr>
<tr class="memitem:a4213df62c3208dd26ae540122dcfa45d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a4213df62c3208dd26ae540122dcfa45d">as_int</a> () const noexcept</td></tr>
<tr class="memdesc:a4213df62c3208dd26ae540122dcfa45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в число заданного типа.  <br /></td></tr>
<tr class="separator:a4213df62c3208dd26ae540122dcfa45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa40ca4ad70df9ec0941599b88c443dc" id="r_afa40ca4ad70df9ec0941599b88c443dc"><td class="memTemplParams" colspan="2">template&lt;ToIntNumber T, bool CheckOverflow = true, unsigned Base = 0, bool SkipWs = true, bool AllowSign = true&gt; </td></tr>
<tr class="memitem:afa40ca4ad70df9ec0941599b88c443dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr convert_result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#afa40ca4ad70df9ec0941599b88c443dc">to_int</a> () const noexcept</td></tr>
<tr class="memdesc:afa40ca4ad70df9ec0941599b88c443dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в число заданного типа.  <br /></td></tr>
<tr class="separator:afa40ca4ad70df9ec0941599b88c443dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037d07ad0ee024d983927cec3ee81908" id="r_a037d07ad0ee024d983927cec3ee81908"><td class="memTemplParams" colspan="2">template&lt;bool SkipWS = true&gt; <br />
requires (sizeof(K) == 1)</td></tr>
<tr class="memitem:a037d07ad0ee024d983927cec3ee81908"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a037d07ad0ee024d983927cec3ee81908">to_double_hex</a> () const noexcept</td></tr>
<tr class="memdesc:a037d07ad0ee024d983927cec3ee81908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Преобразовать строку в 16ричной записи в double. Пока работает только для char.  <br /></td></tr>
<tr class="separator:a037d07ad0ee024d983927cec3ee81908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffb295777b82a1475a4fc0d9754481b" id="r_adffb295777b82a1475a4fc0d9754481b"><td class="memTemplParams" colspan="2">template&lt;typename T, typename Op&gt; </td></tr>
<tr class="memitem:adffb295777b82a1475a4fc0d9754481b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#adffb295777b82a1475a4fc0d9754481b">splitf</a> (str_piece delimiter, const Op &amp;beforeFunc, size_t offset=0) const</td></tr>
<tr class="memdesc:adffb295777b82a1475a4fc0d9754481b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Разделить строку на части по заданному разделителю, с возможным применением функтора к каждой подстроке.  <br /></td></tr>
<tr class="separator:adffb295777b82a1475a4fc0d9754481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad7e9416ed3abc8689034463f497e6b" id="r_a4ad7e9416ed3abc8689034463f497e6b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a4ad7e9416ed3abc8689034463f497e6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a4ad7e9416ed3abc8689034463f497e6b">split</a> (str_piece delimiter, size_t offset=0) const</td></tr>
<tr class="memdesc:a4ad7e9416ed3abc8689034463f497e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Разделить строку на подстроки по заданному разделителю.  <br /></td></tr>
<tr class="separator:a4ad7e9416ed3abc8689034463f497e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2febfef44dabdf863a74db2049410e9f" id="r_a2febfef44dabdf863a74db2049410e9f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a2febfef44dabdf863a74db2049410e9f">starts_with</a> (str_piece prefix) const noexcept</td></tr>
<tr class="memdesc:a2febfef44dabdf863a74db2049410e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Начинается ли строка с заданной подстроки.  <br /></td></tr>
<tr class="separator:a2febfef44dabdf863a74db2049410e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9409e48b2f182546b7f7186af2477e" id="r_a6d9409e48b2f182546b7f7186af2477e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6d9409e48b2f182546b7f7186af2477e">starts_with_ia</a> (str_piece prefix) const noexcept</td></tr>
<tr class="memdesc:a6d9409e48b2f182546b7f7186af2477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Начинается ли строка с заданной подстроки без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:a6d9409e48b2f182546b7f7186af2477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37c68155961c5c7b1609aa1b873b8d3" id="r_ae37c68155961c5c7b1609aa1b873b8d3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae37c68155961c5c7b1609aa1b873b8d3">prefix_in</a> (str_piece text) const noexcept</td></tr>
<tr class="memdesc:ae37c68155961c5c7b1609aa1b873b8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Является ли эта строка началом другой строки.  <br /></td></tr>
<tr class="separator:ae37c68155961c5c7b1609aa1b873b8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15504449e8d2a8f77832046b559ae0a8" id="r_a15504449e8d2a8f77832046b559ae0a8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a15504449e8d2a8f77832046b559ae0a8">ends_with</a> (str_piece suffix) const noexcept</td></tr>
<tr class="memdesc:a15504449e8d2a8f77832046b559ae0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заканчивается ли строка указанной подстрокой.  <br /></td></tr>
<tr class="separator:a15504449e8d2a8f77832046b559ae0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63742e2c0e55c85b0569f6a0004e5418" id="r_a63742e2c0e55c85b0569f6a0004e5418"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a63742e2c0e55c85b0569f6a0004e5418">ends_with_ia</a> (str_piece suffix) const noexcept</td></tr>
<tr class="memdesc:a63742e2c0e55c85b0569f6a0004e5418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заканчивается ли строка указанной подстрокой без учёта регистра ASCII символов.  <br /></td></tr>
<tr class="separator:a63742e2c0e55c85b0569f6a0004e5418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeefcf45750a8260d5a57b3056a1521f" id="r_aaeefcf45750a8260d5a57b3056a1521f"><td class="memItemLeft" align="right" valign="top"><a id="aaeefcf45750a8260d5a57b3056a1521f" name="aaeefcf45750a8260d5a57b3056a1521f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ascii</b> () const noexcept</td></tr>
<tr class="memdesc:aaeefcf45750a8260d5a57b3056a1521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Содержит ли строка только ASCII символы. <br /></td></tr>
<tr class="separator:aaeefcf45750a8260d5a57b3056a1521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517129dd2774440cd48c401b65bcf066" id="r_a517129dd2774440cd48c401b65bcf066"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a517129dd2774440cd48c401b65bcf066"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a517129dd2774440cd48c401b65bcf066">upperred_only_ascii</a> () const</td></tr>
<tr class="memdesc:a517129dd2774440cd48c401b65bcf066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки в верхнем регистре ASCII символов.  <br /></td></tr>
<tr class="separator:a517129dd2774440cd48c401b65bcf066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f36df5ff2422e43919e74d965f24a4" id="r_ad2f36df5ff2422e43919e74d965f24a4"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:ad2f36df5ff2422e43919e74d965f24a4"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad2f36df5ff2422e43919e74d965f24a4">lowered_only_ascii</a> () const</td></tr>
<tr class="memdesc:ad2f36df5ff2422e43919e74d965f24a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки в нижнем регистре ASCII символов.  <br /></td></tr>
<tr class="separator:ad2f36df5ff2422e43919e74d965f24a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606b0373189a0fb89bce3801e972e46a" id="r_a606b0373189a0fb89bce3801e972e46a"><td class="memTemplParams" colspan="2">template&lt;typename R = my_type&gt; </td></tr>
<tr class="memitem:a606b0373189a0fb89bce3801e972e46a"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a606b0373189a0fb89bce3801e972e46a">replaced</a> (str_piece pattern, str_piece repl, size_t offset=0, size_t maxCount=0) const</td></tr>
<tr class="memdesc:a606b0373189a0fb89bce3801e972e46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить копию строки с заменёнными вхождениями подстрок.  <br /></td></tr>
<tr class="separator:a606b0373189a0fb89bce3801e972e46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bded9dcb3da163cf73d690dd63a73d4" id="r_a9bded9dcb3da163cf73d690dd63a73d4"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a9bded9dcb3da163cf73d690dd63a73d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9bded9dcb3da163cf73d690dd63a73d4">trimmed</a> () const</td></tr>
<tr class="memdesc:a9bded9dcb3da163cf73d690dd63a73d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением пробельных символов слева и справа.  <br /></td></tr>
<tr class="separator:a9bded9dcb3da163cf73d690dd63a73d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9958a7ba764ec2ee03fd5f205e3bcd" id="r_a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a9b9958a7ba764ec2ee03fd5f205e3bcd">trimmed</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, слева и справа.  <br /></td></tr>
<tr class="separator:a9b9958a7ba764ec2ee03fd5f205e3bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e8b3bad27529f5033fee8985dbec7d" id="r_a16e8b3bad27529f5033fee8985dbec7d"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a16e8b3bad27529f5033fee8985dbec7d"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a16e8b3bad27529f5033fee8985dbec7d">trimmed</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:a16e8b3bad27529f5033fee8985dbec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, слева и справа.  <br /></td></tr>
<tr class="separator:a16e8b3bad27529f5033fee8985dbec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d2652007aef40826102fb153134c4d" id="r_a25d2652007aef40826102fb153134c4d"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a25d2652007aef40826102fb153134c4d"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a25d2652007aef40826102fb153134c4d">trimmed_left</a> () const</td></tr>
<tr class="memdesc:a25d2652007aef40826102fb153134c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением пробельных символов слева.  <br /></td></tr>
<tr class="separator:a25d2652007aef40826102fb153134c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7910e7f7cb59cad7452f79ee8f1921a" id="r_ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab7910e7f7cb59cad7452f79ee8f1921a">trimmed_left</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, слева.  <br /></td></tr>
<tr class="separator:ab7910e7f7cb59cad7452f79ee8f1921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a1d3727d030ed34c789a1fd45a8038" id="r_a17a1d3727d030ed34c789a1fd45a8038"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a17a1d3727d030ed34c789a1fd45a8038"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a17a1d3727d030ed34c789a1fd45a8038">trimmed_left</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:a17a1d3727d030ed34c789a1fd45a8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, слева.  <br /></td></tr>
<tr class="separator:a17a1d3727d030ed34c789a1fd45a8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3af5eab221e4645e6e91b7b1a6e7d2" id="r_a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a0b3af5eab221e4645e6e91b7b1a6e7d2">trimmed_right</a> () const</td></tr>
<tr class="memdesc:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением пробельных символов справа.  <br /></td></tr>
<tr class="separator:a0b3af5eab221e4645e6e91b7b1a6e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82f1096d596015340377b58704030cf" id="r_ac82f1096d596015340377b58704030cf"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:ac82f1096d596015340377b58704030cf"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac82f1096d596015340377b58704030cf">trimmed_right</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ac82f1096d596015340377b58704030cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, справа.  <br /></td></tr>
<tr class="separator:ac82f1096d596015340377b58704030cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a49ba436dd8d11037216dc97efcd4c" id="r_aa5a49ba436dd8d11037216dc97efcd4c"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:aa5a49ba436dd8d11037216dc97efcd4c"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#aa5a49ba436dd8d11037216dc97efcd4c">trimmed_right</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:aa5a49ba436dd8d11037216dc97efcd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, справа.  <br /></td></tr>
<tr class="separator:aa5a49ba436dd8d11037216dc97efcd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab950f20c494e2c60b22dfe95e410ec25" id="r_ab950f20c494e2c60b22dfe95e410ec25"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:ab950f20c494e2c60b22dfe95e410ec25"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab950f20c494e2c60b22dfe95e410ec25">trimmed_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ab950f20c494e2c60b22dfe95e410ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, слева и справа.  <br /></td></tr>
<tr class="separator:ab950f20c494e2c60b22dfe95e410ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2541095cb5e5a262b8e20c4dc8428b" id="r_a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#a6c2541095cb5e5a262b8e20c4dc8428b">trimmed_with_spaces</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, слева и справа.  <br /></td></tr>
<tr class="separator:a6c2541095cb5e5a262b8e20c4dc8428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e7c2822c67cc2ea9a0b8c8ed9e0280" id="r_ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae0e7c2822c67cc2ea9a0b8c8ed9e0280">trimmed_left_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, слева.  <br /></td></tr>
<tr class="separator:ae0e7c2822c67cc2ea9a0b8c8ed9e0280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b80529d46935202969c279de481cda" id="r_ae9b80529d46935202969c279de481cda"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:ae9b80529d46935202969c279de481cda"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ae9b80529d46935202969c279de481cda">trimmed_left_with_spaces</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:ae9b80529d46935202969c279de481cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, слева.  <br /></td></tr>
<tr class="separator:ae9b80529d46935202969c279de481cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41853e3d4d2579fe7557873592e7302" id="r_ad41853e3d4d2579fe7557873592e7302"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</td></tr>
<tr class="memitem:ad41853e3d4d2579fe7557873592e7302"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ad41853e3d4d2579fe7557873592e7302">trimmed_right_with_spaces</a> (T &amp;&amp;pattern) const</td></tr>
<tr class="memdesc:ad41853e3d4d2579fe7557873592e7302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, справа.  <br /></td></tr>
<tr class="separator:ad41853e3d4d2579fe7557873592e7302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21bff9dca83968de291faa2b6d59fa8" id="r_ac21bff9dca83968de291faa2b6d59fa8"><td class="memTemplParams" colspan="2">template&lt;typename R = str_piece&gt; </td></tr>
<tr class="memitem:ac21bff9dca83968de291faa2b6d59fa8"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ac21bff9dca83968de291faa2b6d59fa8">trimmed_right_with_spaces</a> (str_piece pattern) const</td></tr>
<tr class="memdesc:ac21bff9dca83968de291faa2b6d59fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, справа.  <br /></td></tr>
<tr class="separator:ac21bff9dca83968de291faa2b6d59fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6c202d1c1723297d46a45d82c5808" id="r_ab3f6c202d1c1723297d46a45d82c5808"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a>&lt; K, str_piece &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimstr_1_1str__src__algs.html#ab3f6c202d1c1723297d46a45d82c5808">splitter</a> (str_piece delimiter) const</td></tr>
<tr class="memdesc:ab3f6c202d1c1723297d46a45d82c5808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить объект <code>Splitter</code> по заданному разделителю, который позволяет последовательно получать подстроки методом <code>next()</code>, пока <code>is_done()</code> false.  <br /></td></tr>
<tr class="separator:ab3f6c202d1c1723297d46a45d82c5808"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt;<br />
class simstr::str_algs&lt; K, StrRef, Impl, Mutable &gt;</div><p>Класс с дополнительными константными строковыми алгоритмами. </p>
<p>Дополняет алгоритмы из <a class="el" href="classsimstr_1_1str__src__algs.html" title="Класс с базовыми константными строковыми алгоритмами.">str_src_algs</a> теми, которые связаны с упрощённым юникодом и парсингом double. </p><dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- тип символов. </td></tr>
    <tr><td class="paramname">StrRef</td><td>- тип хранилища куска строки. </td></tr>
    <tr><td class="paramname">Impl</td><td>- конечный класс наследник. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Методы</h2>
<a id="a4213df62c3208dd26ae540122dcfa45d" name="a4213df62c3208dd26ae540122dcfa45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4213df62c3208dd26ae540122dcfa45d">&#9670;&#160;</a></span>as_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;ToIntNumber T, bool CheckOverflow = true, unsigned Base = 0, bool SkipWs = true, bool AllowSign = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::as_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в число заданного типа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- желаемый тип числа. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- проверять на переполнение. </td></tr>
    <tr><td class="paramname">Base</td><td>- основание счисления числа, от -1 до 36, кроме 1.<ul>
<li>Если 0: то пытается определить основание по префиксу 0[xX] как 16, 0 как 8, иначе 10.</li>
<li>Если -1: то пытается определить основание по префиксам:<ul>
<li>0 или 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
<li>в остальных случаях 10. </li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- пропускать пробельные символы в начале строки. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- допустим ли знак '+' перед числом. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>T - число, результат преобразования, насколько оно получилось, или 0 при переполнении. </dd></dl>

</div>
</div>
<a id="af860598fca0df848662d7d8578a8f6da" name="af860598fca0df848662d7d8578a8f6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af860598fca0df848662d7d8578a8f6da">&#9670;&#160;</a></span>as_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в double. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- переменная, в которую записывается результат. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17421202713ebd4d62ddf175023f535" name="ac17421202713ebd4d62ddf175023f535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17421202713ebd4d62ddf175023f535">&#9670;&#160;</a></span>as_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;ToIntNumber T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::as_number </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в целое число. </p>
<p>Так как <code>as_number(double&amp; t)</code> перекрывает видимость <code>as_number</code> из базового класса, придётся добавить его ещё раз. </p><dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- тип числа, выводится из аргумента. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- переменная, в которую записывается результат. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c053de38bf2a0eab39cf1de5b0a21a" name="ad2c053de38bf2a0eab39cf1de5b0a21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c053de38bf2a0eab39cf1de5b0a21a">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::at </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить символ на заданной позиции . </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>- индекс символа. Для отрицательных значений отсчитывается от конца строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>K - символ.</dd></dl>
<p>Не производит проверку на выход за границы строки. </p>

</div>
</div>
<a id="a108d9cd0dc24f5d395e838a3ef20d846" name="a108d9cd0dc24f5d395e838a3ef20d846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d9cd0dc24f5d395e838a3ef20d846">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение строк посимвольно. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>&lt;0 эта строка меньше, ==0 - строки равны, &gt;0 - эта строка больше. </dd></dl>

</div>
</div>
<a id="a0e5e10ff025504ee5d60e8c77f439003" name="a0e5e10ff025504ee5d60e8c77f439003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5e10ff025504ee5d60e8c77f439003">&#9670;&#160;</a></span>compare_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::compare_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение строк посимвольно без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>&lt;0 эта строка меньше, ==0 - строки равны, &gt;0 - эта строка больше. </dd></dl>

</div>
</div>
<a id="a400250ea87cc59daa152dc9ddb57491f" name="a400250ea87cc59daa152dc9ddb57491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400250ea87cc59daa152dc9ddb57491f">&#9670;&#160;</a></span>compare_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::compare_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение строк посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>&lt;0 эта строка меньше, ==0 - строки равны, &gt;0 - эта строка больше. </dd></dl>

</div>
</div>
<a id="ac4d712294186e2e181910677ba9c3ca7" name="ac4d712294186e2e181910677ba9c3ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d712294186e2e181910677ba9c3ca7">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Содержит ли строка указанную подстроку. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>bool. </dd></dl>

</div>
</div>
<a id="a3c2498615b426546b65e9b6c4f973264" name="a3c2498615b426546b65e9b6c4f973264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2498615b426546b65e9b6c4f973264">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Копировать строку в указанный буфер. </p>
<p>Метод добавляет <code>\0</code> после скопированных символов. Не выходит за границы буфера. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- указатель на буфер </td></tr>
    <tr><td class="paramname">bufSize</td><td>- размер буфера в символах. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15504449e8d2a8f77832046b559ae0a8" name="a15504449e8d2a8f77832046b559ae0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15504449e8d2a8f77832046b559ae0a8">&#9670;&#160;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заканчивается ли строка указанной подстрокой. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63742e2c0e55c85b0569f6a0004e5418" name="a63742e2c0e55c85b0569f6a0004e5418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63742e2c0e55c85b0569f6a0004e5418">&#9670;&#160;</a></span>ends_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::ends_with_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заканчивается ли строка указанной подстрокой без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a535d655a6702861b788830a1d266e48f" name="a535d655a6702861b788830a1d266e48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535d655a6702861b788830a1d266e48f">&#9670;&#160;</a></span>ends_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::ends_with_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Заканчивается ли строка указанной подстрокой без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b9b0cb780c465cb9b6bd925d712ff07" name="a3b9b0cb780c465cb9b6bd925d712ff07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9b0cb780c465cb9b6bd925d712ff07">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::equal </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение строк на равенство. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>равны ли строки. </dd></dl>

</div>
</div>
<a id="afa9fca49d189fd0d760ffe8aed1485f1" name="afa9fca49d189fd0d760ffe8aed1485f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9fca49d189fd0d760ffe8aed1485f1">&#9670;&#160;</a></span>equal_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::equal_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Равна ли строка другой строке посимвольно без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>равны ли строки. </dd></dl>

</div>
</div>
<a id="adbf0990c46a280cd363da46bef12e02f" name="adbf0990c46a280cd363da46bef12e02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf0990c46a280cd363da46bef12e02f">&#9670;&#160;</a></span>equal_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::equal_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Равна ли строка другой строке посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>равны ли строки. </dd></dl>

</div>
</div>
<a id="a129d72cc64be6029f10bbe1f8385f3ea" name="a129d72cc64be6029f10bbe1f8385f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129d72cc64be6029f10bbe1f8385f3ea">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти символ в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- искомый символ. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного символа, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="ab38e5cc7893a20e69cdf03d88232b49c" name="ab38e5cc7893a20e69cdf03d88232b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38e5cc7893a20e69cdf03d88232b49c">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало первого вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или -1, если не найдена. </dd></dl>

</div>
</div>
<a id="aa6d568443f3ed5752279098b9a488655" name="aa6d568443f3ed5752279098b9a488655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d568443f3ed5752279098b9a488655">&#9670;&#160;</a></span>find_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename To = std::vector&lt;size_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти все вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая подстрока. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество обрабатываемых вхождений, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::vector&lt;size_t&gt; - вектор с позициями начал найденных вхождений. </dd></dl>

</div>
</div>
<a id="a8bcde5878d3d7fd5138d38ff2f1df4d2" name="a8bcde5878d3d7fd5138d38ff2f1df4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcde5878d3d7fd5138d38ff2f1df4d2">&#9670;&#160;</a></span>find_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_end </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти конец вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию сразу за вхождением подстроки, или -1, если не найдена. </dd></dl>

</div>
</div>
<a id="aab67ba06c8637f93984e45cf349c3eb8" name="aab67ba06c8637f93984e45cf349c3eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab67ba06c8637f93984e45cf349c3eb8">&#9670;&#160;</a></span>find_end_of_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_end_of_last </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти конец последнего вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию сразу за последним вхождением подстроки, или -1, если не найдена. </dd></dl>

</div>
</div>
<a id="ae281c63da2d81ef8aac65a2dad77eb93" name="ae281c63da2d81ef8aac65a2dad77eb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae281c63da2d81ef8aac65a2dad77eb93">&#9670;&#160;</a></span>find_end_of_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_end_of_last_or_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти конец последнего вхождения подстроки в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию сразу за последним вхождением подстроки, или длину строки, если не найдена. </dd></dl>

</div>
</div>
<a id="a2c56c3345019c8d5dc20717092d52101" name="a2c56c3345019c8d5dc20717092d52101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c56c3345019c8d5dc20717092d52101">&#9670;&#160;</a></span>find_end_or_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_end_or_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти конец первого вхождения подстроки в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию сразу за вхождением подстроки, или длину строки, если не найдена. </dd></dl>

</div>
</div>
<a id="a63ff5e918afcc8e1fba9a3ec19c47897" name="a63ff5e918afcc8e1fba9a3ec19c47897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff5e918afcc8e1fba9a3ec19c47897">&#9670;&#160;</a></span>find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти первое вхождение символа не из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного вхождения, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a643bf839edef0abbd43c3f3654e8e700" name="a643bf839edef0abbd43c3f3654e8e700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bf839edef0abbd43c3f3654e8e700">&#9670;&#160;</a></span>find_first_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_first_of </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти первое вхождение символа из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор искомых символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного вхождения, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="aad5ad9c702f21003a272469cb1edcbf3" name="aad5ad9c702f21003a272469cb1edcbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5ad9c702f21003a272469cb1edcbf3">&#9670;&#160;</a></span>find_first_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_first_of_idx </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти первое вхождение символа из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор искомых символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::pair&lt;size_t, size_t&gt; - пару из позиции найденного вхождения и номера найденного символа в наборе, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a0564461ab81bfbb6c5bd8b4c7e5a496e" name="a0564461ab81bfbb6c5bd8b4c7e5a496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0564461ab81bfbb6c5bd8b4c7e5a496e">&#9670;&#160;</a></span>find_last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти последнее вхождения символа в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- искомый символ. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного символа, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a72a2c0b10e857c245f67a2abd7c1a2f0" name="a72a2c0b10e857c245f67a2abd7c1a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a2c0b10e857c245f67a2abd7c1a2f0">&#9670;&#160;</a></span>find_last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало последнего вхождения подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или -1, если не найдена. </dd></dl>

</div>
</div>
<a id="a775a7c8e218ab3223f0248f225076b7c" name="a775a7c8e218ab3223f0248f225076b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775a7c8e218ab3223f0248f225076b7c">&#9670;&#160;</a></span>find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти последнее вхождение символа не из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного вхождения, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a73806fa93c9ec619ba93d479d413ea0f" name="a73806fa93c9ec619ba93d479d413ea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73806fa93c9ec619ba93d479d413ea0f">&#9670;&#160;</a></span>find_last_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last_of </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти последнее вхождение символа из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор искомых символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного вхождения, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="ab630d62252bf1210f573a8c7222942c8" name="ab630d62252bf1210f573a8c7222942c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab630d62252bf1210f573a8c7222942c8">&#9670;&#160;</a></span>find_last_of_idx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last_of_idx </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">str::npos</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти последнее вхождение символа из заданного набора символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая набор искомых символов. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::pair&lt;size_t, size_t&gt; - пару из позиции найденного вхождения и номера найденного символа в наборе, или -1, если не найден. </dd></dl>

</div>
</div>
<a id="a6a5bdd0e7ab4f7e64e1e776f4dabe11c" name="a6a5bdd0e7ab4f7e64e1e776f4dabe11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5bdd0e7ab4f7e64e1e776f4dabe11c">&#9670;&#160;</a></span>find_last_or_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_last_or_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало последнего вхождения подстроки в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- c какой позиции вести поиск в обратную сторону, -1 - с самого конца. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или длину строки, если не найдена. </dd></dl>

</div>
</div>
<a id="a762c55d09b34ba2b7b5f9f10783da662" name="a762c55d09b34ba2b7b5f9f10783da662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762c55d09b34ba2b7b5f9f10783da662">&#9670;&#160;</a></span>find_or_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти символ в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- искомый символ. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию найденного символа, или длину строки, если не найден. </dd></dl>

</div>
</div>
<a id="ac029fd5412ed114bfefbdddba2c50167" name="ac029fd5412ed114bfefbdddba2c50167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac029fd5412ed114bfefbdddba2c50167">&#9670;&#160;</a></span>find_or_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_or_all </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало первого вхождения подстроки в этой строке или конец строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или длину строки, если не найдена. </dd></dl>

</div>
</div>
<a id="a40ab0482ea5f02bc0c3097bed6c9a5fa" name="a40ab0482ea5f02bc0c3097bed6c9a5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab0482ea5f02bc0c3097bed6c9a5fa">&#9670;&#160;</a></span>find_or_throw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename Exc, typename ... Args&gt; <br />
requires std::is_constructible_v&lt;Exc, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::find_or_throw </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Найти начало первого вхождения подстроки в этой строке или выкинуть исключение. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Exc</td><td>- тип исключения. </td></tr>
    <tr><td class="paramname">Args...</td><td>- типы параметров для конструирования исключения, выводятся из аргументов. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая строка. </td></tr>
    <tr><td class="paramname">offset</td><td>- с какой позиции начинать поиск. </td></tr>
    <tr><td class="paramname">args</td><td>- аргументы для конструктора исключения. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>size_t - позицию начала вхождения подстроки, или выбрасывает исключение Exc, если не найдена. </dd></dl>

</div>
</div>
<a id="a8185ccf8fc2297b628cce3c83b6a0b4c" name="a8185ccf8fc2297b628cce3c83b6a0b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8185ccf8fc2297b628cce3c83b6a0b4c">&#9670;&#160;</a></span>for_all_finded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename Op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::for_all_finded </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Вызвать функтор для всех найденных вхождений подстроки в этой строке. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>- функтор, принимающий строку. </td></tr>
    <tr><td class="paramname">pattern</td><td>- искомая подстрока. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество обрабатываемых вхождений, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5659e7fb47dfb6bd6736a1b454ffde92" name="a5659e7fb47dfb6bd6736a1b454ffde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5659e7fb47dfb6bd6736a1b454ffde92">&#9670;&#160;</a></span>from_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str_piece <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::from_to </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить подстроку <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a> с позиции от from до позиции to (не включая её). </p>
<p>Для производительности метод никак не проверяет выходы за границы строки, используйте в сценариях, когда точно знаете, что это позиции внутри строки и to &gt;= from. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- начальная позиция. </td></tr>
    <tr><td class="paramname">to</td><td>- конечная позиция (не входит в результат). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Подстроку, <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a44ede528e694988f26555e91cf9a1ca2" name="a44ede528e694988f26555e91cf9a1ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ede528e694988f26555e91cf9a1ca2">&#9670;&#160;</a></span>less_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::less_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Меньше ли строка другой строки посимвольно без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>меньше ли строка. </dd></dl>

</div>
</div>
<a id="a4e79e99462478b57d62873f7942ff2b6" name="a4e79e99462478b57d62873f7942ff2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79e99462478b57d62873f7942ff2b6">&#9670;&#160;</a></span>less_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::less_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Меньше ли строка другой строки посимвольно без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>меньше ли строка. </dd></dl>

</div>
</div>
<a id="a8d51ac2887746e40214eeee7d52460f4" name="a8d51ac2887746e40214eeee7d52460f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d51ac2887746e40214eeee7d52460f4">&#9670;&#160;</a></span>lowered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::lowered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки в нижнем регистре Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - копию строки в нижнем регистре. </dd></dl>

</div>
</div>
<a id="ad2f36df5ff2422e43919e74d965f24a4" name="ad2f36df5ff2422e43919e74d965f24a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f36df5ff2422e43919e74d965f24a4">&#9670;&#160;</a></span>lowered_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::lowered_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки в нижнем регистре ASCII символов. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - копию строки в нижнем регистре. </dd></dl>

</div>
</div>
<a id="a507a43e6ebcc51e6409874712abbbd63" name="a507a43e6ebcc51e6409874712abbbd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507a43e6ebcc51e6409874712abbbd63">&#9670;&#160;</a></span>mid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str_piece <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить часть строки как "кусок строки". </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- количество символов от начала строки. При превышении размера строки вернёт пустую строку. </td></tr>
    <tr><td class="paramname">len</td><td>- количество символов в получаемом "куске". При выходе за пределы строки вернёт всё до конца строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Подстроку, <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </dd></dl>

</div>
</div>
<a id="a9959513e8a072c51620248c4a29f4196" name="a9959513e8a072c51620248c4a29f4196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9959513e8a072c51620248c4a29f4196">&#9670;&#160;</a></span>operator std::basic_string&lt; D, Traits, Allocator &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename D, typename Traits, typename Allocator&gt; <br />
requires is_equal_str_type_v&lt;K, D&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator std::basic_string&lt; D, Traits, Allocator &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конвертировать в std::basic_string. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="ab4c6b4c365f05e609a7b22cbf37b39c6" name="ab4c6b4c365f05e609a7b22cbf37b39c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c6b4c365f05e609a7b22cbf37b39c6">&#9670;&#160;</a></span>operator std::basic_string_view&lt; D, Traits &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename D, typename Traits&gt; <br />
requires is_equal_str_type_v&lt;K, D&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator std::basic_string_view&lt; D, Traits &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конвертировать в std::basic_string_view. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a916218a7a75a3866a9d3d0da9334653c" name="a916218a7a75a3866a9d3d0da9334653c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916218a7a75a3866a9d3d0da9334653c">&#9670;&#160;</a></span>operator str_piece()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator str_piece </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать себя в "кусок строки", включающий всю строку. </p>
<dl class="section return"><dt>Возвращает</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="ace8f275b33545d2491850f49ba3b7876" name="ace8f275b33545d2491850f49ba3b7876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8f275b33545d2491850f49ba3b7876">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str_piece <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить часть строки как "str_src". </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- количество символов от начала строки. </td></tr>
    <tr><td class="paramname">len</td><td>- количество символов в получаемом "куске". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Подстроку, <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>.</dd></dl>
<p>Если <code>from</code> меньше нуля, то отсчитывается <code>-from</code> символов от конца строки в сторону начала. Если <code>len</code> меньше или равно нулю, то отсчитать <code>-len</code> символов от конца строки</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, 2) == <span class="stringliteral">&quot;56&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5) == <span class="stringliteral">&quot;56789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(5, -1) == <span class="stringliteral">&quot;5678&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3) == <span class="stringliteral">&quot;789&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-3, 2) == <span class="stringliteral">&quot;78&quot;</span>;</div>
<div class="line"><span class="stringliteral">&quot;0123456789&quot;</span>_ss(-4, -1) == <span class="stringliteral">&quot;678&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac34637c1f071ac6e6faa0237a092cc61" name="ac34637c1f071ac6e6faa0237a092cc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34637c1f071ac6e6faa0237a092cc61">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор сравнения строк. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad63f315c4a97ee6ad1e2b045b9f5f9e0" name="ad63f315c4a97ee6ad1e2b045b9f5f9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63f315c4a97ee6ad1e2b045b9f5f9e0">&#9670;&#160;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор сравнения строки и строкового литерала. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- строковый литерал. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ddd0a1f9b25247465fb55c79b58826d" name="a1ddd0a1f9b25247465fb55c79b58826d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddd0a1f9b25247465fb55c79b58826d">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimstr_1_1str__src__algs.html">base</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор сравнение строк на равенство. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>равны ли строки. </dd></dl>

</div>
</div>
<a id="ac19dc728f9d7edafbd85a52e70b46376" name="ac19dc728f9d7edafbd85a52e70b46376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19dc728f9d7edafbd85a52e70b46376">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Оператор сравнения строки и строкового литерала на равенство. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>- строковый литерал. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af893677739e0d24418f6acc0a29090cc" name="af893677739e0d24418f6acc0a29090cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af893677739e0d24418f6acc0a29090cc">&#9670;&#160;</a></span>place()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K * <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::place </td>
          <td>(</td>
          <td class="paramtype">K *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Копировать строку в указанный буфер. </p>
<p>Метод предполагает, что размер выделенного буфера достаточен для всей строки, т.е. предварительно была запрошена <code>length()</code>. Не добавляет <code>\0</code>. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- указатель на буфер. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>указатель на символ после конца размещённой в буфере строки. </dd></dl>

</div>
</div>
<a id="ae37c68155961c5c7b1609aa1b873b8d3" name="ae37c68155961c5c7b1609aa1b873b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37c68155961c5c7b1609aa1b873b8d3">&#9670;&#160;</a></span>prefix_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::prefix_in </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Является ли эта строка началом другой строки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a606b0373189a0fb89bce3801e972e46a" name="a606b0373189a0fb89bce3801e972e46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606b0373189a0fb89bce3801e972e46a">&#9670;&#160;</a></span>replaced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::replaced </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>repl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки с заменёнными вхождениями подстрок. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- искомая подстрока. </td></tr>
    <tr><td class="paramname">repl</td><td>- строка, на которую заменять. </td></tr>
    <tr><td class="paramname">offset</td><td>- начальная позиция поиска. </td></tr>
    <tr><td class="paramname">maxCount</td><td>- максимальное количество замен, 0 - без ограничений. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R строку заданного типа, по умолчанию того же, чей метод вызывался. </dd></dl>

</div>
</div>
<a id="aa2732ccf421fcd1ba606addcca7e6e42" name="aa2732ccf421fcd1ba606addcca7e6e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2732ccf421fcd1ba606addcca7e6e42">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Размер строки в символах. </p>
<dl class="section return"><dt>Возвращает</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="a4ad7e9416ed3abc8689034463f497e6b" name="a4ad7e9416ed3abc8689034463f497e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad7e9416ed3abc8689034463f497e6b">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::split </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Разделить строку на подстроки по заданному разделителю. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- тип контейнера для результата. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- разделитель. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска разделителя. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>T - контейнер с результатом. </dd></dl>

</div>
</div>
<a id="adffb295777b82a1475a4fc0d9754481b" name="adffb295777b82a1475a4fc0d9754481b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffb295777b82a1475a4fc0d9754481b">&#9670;&#160;</a></span>splitf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename Op&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::splitf </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Op &amp;</td>          <td class="paramname"><span class="paramname"><em>beforeFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Разделить строку на части по заданному разделителю, с возможным применением функтора к каждой подстроке. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- тип контейнера для складывания подстрок. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- подстрока разделитель. </td></tr>
    <tr><td class="paramname">beforeFunc</td><td>- функтор для применения к найденным подстрокам, перед помещением их в результат. </td></tr>
    <tr><td class="paramname">offset</td><td>- позиция начала поиска разделителя. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>T - результат.</dd></dl>
<p>Для каждой найденной подстроки, если функтор может принять её, вызывается функтор, и подстрока присваивается результату функтора. Далее подстрока пытается добавиться в результат, вызывая один из его методов - <code>emplace_back</code>, <code>push_back</code>, <code>operator[]</code>. Если ни одного этого метода нет, ничего не делается, только вызов функтора. <code>operator[]</code> пытается применится, если у результата можно получить размер через <code>std::size</code> и мы не выходим за этот размер. При этом, если найденная подстрока получается совпадающей со всей строкой - в результат пытается поместить не подстроку, а весь объект строки, что позволяет, например, эффективно копировать sstring. </p>

</div>
</div>
<a id="ab3f6c202d1c1723297d46a45d82c5808" name="ab3f6c202d1c1723297d46a45d82c5808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6c202d1c1723297d46a45d82c5808">&#9670;&#160;</a></span>splitter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimstr_1_1_splitter_base.html">SplitterBase</a>&lt; K, str_piece &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::splitter </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить объект <code>Splitter</code> по заданному разделителю, который позволяет последовательно получать подстроки методом <code>next()</code>, пока <code>is_done()</code> false. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>- разделитель. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Splitter&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a2febfef44dabdf863a74db2049410e9f" name="a2febfef44dabdf863a74db2049410e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2febfef44dabdf863a74db2049410e9f">&#9670;&#160;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Начинается ли строка с заданной подстроки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9409e48b2f182546b7f7186af2477e" name="a6d9409e48b2f182546b7f7186af2477e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9409e48b2f182546b7f7186af2477e">&#9670;&#160;</a></span>starts_with_ia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::starts_with_ia </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Начинается ли строка с заданной подстроки без учёта регистра ASCII символов. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26465c7fdac87e8d215e836bdbf6e8c3" name="a26465c7fdac87e8d215e836bdbf6e8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26465c7fdac87e8d215e836bdbf6e8c3">&#9670;&#160;</a></span>starts_with_iu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::starts_with_iu </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Начинается ли строка с заданной подстроки без учёта регистра Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>- подстрока. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa77c31da012cf5cc23e0a60c1888cec2" name="aa77c31da012cf5cc23e0a60c1888cec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77c31da012cf5cc23e0a60c1888cec2">&#9670;&#160;</a></span>str_mid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_type <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::str_mid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить часть строки объектом того же типа, к которому применён метод, аналогично mid. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- количество символов от начала строки. При превышении размера строки вернёт пустую строку. </td></tr>
    <tr><td class="paramname">len</td><td>- количество символов в получаемом "куске". При выходе за пределы строки вернёт всё до конца строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Строку того же типа, к которому применён метод. </dd></dl>

</div>
</div>
<a id="a610d501d16ab38c3efb1427f14ea7f67" name="a610d501d16ab38c3efb1427f14ea7f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d501d16ab38c3efb1427f14ea7f67">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::strcmp </td>
          <td>(</td>
          <td class="paramtype">const K *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Сравнение с C-строкой посимвольно. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>- другая строка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>&lt;0 эта строка меньше, ==0 - строки равны, &gt;0 - эта строка больше. </dd></dl>

</div>
</div>
<a id="a512eaf3c2c8736f3021a5bbe60823866" name="a512eaf3c2c8736f3021a5bbe60823866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512eaf3c2c8736f3021a5bbe60823866">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_type <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить подстроку. Работает аналогично operator(), только результат выдает того же типа, к которому применён метод. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>- количество символов от начала строки. Если меньше нуля, отсчитывается от конца строки в сторону начала. </td></tr>
    <tr><td class="paramname">len</td><td>- количество символов в получаемом "куске". Если меньше или равно нулю, то отсчитать len символов от конца строки. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>my_type - подстроку, объект того же типа, к которому применён метод. </dd></dl>

</div>
</div>
<a id="aa1af52e61e73c687a34ff6978304edc3" name="aa1af52e61e73c687a34ff6978304edc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af52e61e73c687a34ff6978304edc3">&#9670;&#160;</a></span>to_double()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;bool SkipWS = true, bool AllowPlus = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_double </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в double. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="a037d07ad0ee024d983927cec3ee81908" name="a037d07ad0ee024d983927cec3ee81908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037d07ad0ee024d983927cec3ee81908">&#9670;&#160;</a></span>to_double_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;bool SkipWS = true&gt; <br />
requires (sizeof(K) == 1)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_double_hex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в 16ричной записи в double. Пока работает только для char. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::optional&lt;double&gt;. </dd></dl>

</div>
</div>
<a id="afa40ca4ad70df9ec0941599b88c443dc" name="afa40ca4ad70df9ec0941599b88c443dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa40ca4ad70df9ec0941599b88c443dc">&#9670;&#160;</a></span>to_int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;ToIntNumber T, bool CheckOverflow = true, unsigned Base = 0, bool SkipWs = true, bool AllowSign = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">convert_result&lt; T &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_int </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать строку в число заданного типа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- желаемый тип числа. </td></tr>
    <tr><td class="paramname">CheckOverflow</td><td>- проверять на переполнение. </td></tr>
    <tr><td class="paramname">Base</td><td>- основание счисления числа, от -1 до 36, кроме 1.<ul>
<li>Если 0: то пытается определить основание по префиксу 0[xX] как 16, 0 как 8, иначе 10</li>
<li>Если -1: то пытается определить основание по префиксам:<ul>
<li>0 или 0[oO]: 8</li>
<li>0[bB]: 2</li>
<li>0[xX]: 16</li>
<li>в остальных случаях 10. </li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">SkipWs</td><td>- пропускать пробельные символы в начале строки. Пропускаются все символы с ASCII кодами &lt;= 32. </td></tr>
    <tr><td class="paramname">AllowSign</td><td>- допустим ли знак '+' перед числом. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>convert_result&lt;T&gt; - кортеж из полученного числа, успешности преобразования и количестве обработанных символов. </dd></dl>

</div>
</div>
<a id="a53d19b3fba03bfd481d2a3b3def766af" name="a53d19b3fba03bfd481d2a3b3def766af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d19b3fba03bfd481d2a3b3def766af">&#9670;&#160;</a></span>to_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">str_piece <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Преобразовать себя в "кусок строки", включающий всю строку. </p>
<dl class="section return"><dt>Возвращает</dt><dd>str_piece. </dd></dl>

</div>
</div>
<a id="adc816f095922a510dfe466db1905fc63" name="adc816f095922a510dfe466db1905fc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc816f095922a510dfe466db1905fc63">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename D = K, typename Traits = std::char_traits&lt;D&gt;, typename Allocator = std::allocator&lt;D&gt;&gt; <br />
requires is_equal_str_type_v&lt;K, D&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; D, Traits, Allocator &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конвертировать в std::basic_string. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a1f2af1ee80a32a77ad30cffbf6987107" name="a1f2af1ee80a32a77ad30cffbf6987107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2af1ee80a32a77ad30cffbf6987107">&#9670;&#160;</a></span>to_sv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename D = K&gt; <br />
requires is_equal_str_type_v&lt;K, D&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string_view&lt; D &gt; <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::to_sv </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конвертировать в std::basic_string_view. </p>
<dl class="section return"><dt>Возвращает</dt><dd>std::basic_string_view&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a9bded9dcb3da163cf73d690dd63a73d4" name="a9bded9dcb3da163cf73d690dd63a73d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bded9dcb3da163cf73d690dd63a73d4">&#9670;&#160;</a></span>trimmed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением пробельных символов слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце пробельными символами. </dd></dl>

</div>
</div>
<a id="a16e8b3bad27529f5033fee8985dbec7d" name="a16e8b3bad27529f5033fee8985dbec7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e8b3bad27529f5033fee8985dbec7d">&#9670;&#160;</a></span>trimmed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце символами, содержащимися в шаблоне. </dd></dl>

</div>
</div>
<a id="a9b9958a7ba764ec2ee03fd5f205e3bcd" name="a9b9958a7ba764ec2ee03fd5f205e3bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9958a7ba764ec2ee03fd5f205e3bcd">&#9670;&#160;</a></span>trimmed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце символами, содержащимися в литерале. </dd></dl>

</div>
</div>
<a id="a25d2652007aef40826102fb153134c4d" name="a25d2652007aef40826102fb153134c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d2652007aef40826102fb153134c4d">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением пробельных символов слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале пробельными символами. </dd></dl>

</div>
</div>
<a id="a17a1d3727d030ed34c789a1fd45a8038" name="a17a1d3727d030ed34c789a1fd45a8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a1d3727d030ed34c789a1fd45a8038">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале символами, содержащимися в шаблоне. </dd></dl>

</div>
</div>
<a id="ab7910e7f7cb59cad7452f79ee8f1921a" name="ab7910e7f7cb59cad7452f79ee8f1921a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7910e7f7cb59cad7452f79ee8f1921a">&#9670;&#160;</a></span>trimmed_left() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале символами, содержащимися в литерале. </dd></dl>

</div>
</div>
<a id="ae9b80529d46935202969c279de481cda" name="ae9b80529d46935202969c279de481cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b80529d46935202969c279de481cda">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале символами, содержащимися в шаблоне и пробельными символами. </dd></dl>

</div>
</div>
<a id="ae0e7c2822c67cc2ea9a0b8c8ed9e0280" name="ae0e7c2822c67cc2ea9a0b8c8ed9e0280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e7c2822c67cc2ea9a0b8c8ed9e0280">&#9670;&#160;</a></span>trimmed_left_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_left_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, слева. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале символами, содержащимися в литерале и пробельными символами. </dd></dl>

</div>
</div>
<a id="a0b3af5eab221e4645e6e91b7b1a6e7d2" name="a0b3af5eab221e4645e6e91b7b1a6e7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3af5eab221e4645e6e91b7b1a6e7d2">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением пробельных символов справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце пробельными символами. </dd></dl>

</div>
</div>
<a id="aa5a49ba436dd8d11037216dc97efcd4c" name="aa5a49ba436dd8d11037216dc97efcd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a49ba436dd8d11037216dc97efcd4c">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце символами, содержащимися в шаблоне. </dd></dl>

</div>
</div>
<a id="ac82f1096d596015340377b58704030cf" name="ac82f1096d596015340377b58704030cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82f1096d596015340377b58704030cf">&#9670;&#160;</a></span>trimmed_right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце символами, содержащимися в литерале. </dd></dl>

</div>
</div>
<a id="ac21bff9dca83968de291faa2b6d59fa8" name="ac21bff9dca83968de291faa2b6d59fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21bff9dca83968de291faa2b6d59fa8">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце символами, содержащимися в шаблоне и пробельными символами. </dd></dl>

</div>
</div>
<a id="ad41853e3d4d2579fe7557873592e7302" name="ad41853e3d4d2579fe7557873592e7302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41853e3d4d2579fe7557873592e7302">&#9670;&#160;</a></span>trimmed_right_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_right_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в конце символами, содержащимися в литерале и пробельными символами. </dd></dl>

</div>
</div>
<a id="a6c2541095cb5e5a262b8e20c4dc8428b" name="a6c2541095cb5e5a262b8e20c4dc8428b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2541095cb5e5a262b8e20c4dc8428b">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype">str_piece</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных другой строкой, а также пробельных символов, слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строка, задающая символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце символами, содержащимися в шаблоне и пробельными символами. </dd></dl>

</div>
</div>
<a id="ab950f20c494e2c60b22dfe95e410ec25" name="ab950f20c494e2c60b22dfe95e410ec25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab950f20c494e2c60b22dfe95e410ec25">&#9670;&#160;</a></span>trimmed_with_spaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = str_piece, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count&gt; <br />
requires is_const_pattern&lt;N&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::trimmed_with_spaces </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить строку с удалением символов, заданных строковым литералом, а также пробельных символов, слева и справа. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию <a class="el" href="structsimstr_1_1str__src.html" title="Простейший класс иммутабельной не владеющей строки.">str_src</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- строковый литерал, задающий символы, которые будут обрезаться. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - строка, с удалёнными в начале и в конце символами, содержащимися в литерале и пробельными символами. </dd></dl>

</div>
</div>
<a id="a6ae3ef69a372dab777c952f22c492689" name="a6ae3ef69a372dab777c952f22c492689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3ef69a372dab777c952f22c492689">&#9670;&#160;</a></span>upperred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__algs.html">simstr::str_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::upperred </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки в верхнем регистре Unicode символов первой плоскости (&lt;0xFFFF). </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - копию строки в верхнем регистре. </dd></dl>

</div>
</div>
<a id="a517129dd2774440cd48c401b65bcf066" name="a517129dd2774440cd48c401b65bcf066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517129dd2774440cd48c401b65bcf066">&#9670;&#160;</a></span>upperred_only_ascii()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename StrRef, typename Impl, bool Mutable&gt; </div>
<div class="memtemplate">
template&lt;typename R = my_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classsimstr_1_1str__src__algs.html">simstr::str_src_algs</a>&lt; K, StrRef, Impl, Mutable &gt;::upperred_only_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получить копию строки в верхнем регистре ASCII символов. </p>
<dl class="tparams"><dt>Параметры шаблона</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>- желаемый тип строки, по умолчанию тот же, чей метод вызывался. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>R - копию строки в верхнем регистре. </dd></dl>

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li><a class="el" href="sstring_8h_source.html">sstring.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimstr.html">simstr</a></li><li class="navelem"><a class="el" href="classsimstr_1_1str__algs.html">str_algs</a></li>
    <li class="footer">Создано системой <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simstr: String Expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simstr<span id="projectnumber">&#160;1.5.0</span>
   </div>
   <div id="projectbrief">Yet another strings library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group___str_exprs.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#concepts">Concepts</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">String Expressions</div></div>
</div><!--header-->
<div class="contents">

<p>Description of String Expressions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1_str_expr.html">simstr::StrExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept of "String Expressions". <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsimstr_1_1_str_expr_for_type.html">simstr::StrExprForType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept of a string expression compatible with a given character type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1strexprjoin.html">simstr::strexprjoin&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for concatenating two string expressions into one using <code>operator +</code>  <a href="structsimstr_1_1strexprjoin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1strexprjoin__c.html">simstr::strexprjoin_c&lt; A, B, last &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation of a reference to a string expression and the value of the string expression.  <a href="structsimstr_1_1strexprjoin__c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1empty__expr.html">simstr::empty_expr&lt; K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An "empty" string expression.  <a href="structsimstr_1_1empty__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__spaces.html">simstr::expr_spaces&lt; K, N, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of string expression that returns N specified characters.  <a href="structsimstr_1_1expr__spaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__pad.html">simstr::expr_pad&lt; K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of string expression that returns N specified characters.  <a href="structsimstr_1_1expr__pad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice.html">simstr::expr_choice&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__if.html">simstr::expr_if&lt; A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice__one__lit.html">simstr::expr_choice_one_lit&lt; L, A, N, Compare &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice__one__lit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__choice__two__lit.html">simstr::expr_choice_two_lit&lt; K, N, P, M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional selection string expression.  <a href="structsimstr_1_1expr__choice__two__lit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__stdstr.html">simstr::expr_stdstr&lt; K, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for using std::string and std::string_view as sources in string expressions.  <a href="structsimstr_1_1expr__stdstr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__replaced.html">simstr::expr_replaced&lt; K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string expression that generates a string replacing all occurrences of the given substring to another string.  <a href="structsimstr_1_1expr__replaced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__replaced__e.html">simstr::expr_replaced_e&lt; K, E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string expression that generates a string replacing all occurrences of the given substring to string expression.  <a href="structsimstr_1_1expr__replaced__e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimstr_1_1expr__replace__symbols.html">simstr::expr_replace_symbols&lt; K, UseVectorForReplace &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for a string expression that generates a string in which the given characters are replaced by the given strings.  <a href="structsimstr_1_1expr__replace__symbols.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga680097382d9bc271c361f85828ac741f" id="r_ga680097382d9bc271c361f85828ac741f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga680097382d9bc271c361f85828ac741f">simstr::HexFlags</a> : unsigned { <a class="el" href="#gga680097382d9bc271c361f85828ac741fad4ddbe11a4c8e3daca5795ad268df0c4">simstr::Short</a> = 1
, <b>No0x</b> = 2
, <b>Lcase</b> = 4
 }</td></tr>
<tr class="memdesc:ga680097382d9bc271c361f85828ac741f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for the e_hex function.  <a href="#ga680097382d9bc271c361f85828ac741f">More...</a><br /></td></tr>
<tr class="separator:ga680097382d9bc271c361f85828ac741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9742e8cdcccc67c0746578f3579127e2" id="r_ga9742e8cdcccc67c0746578f3579127e2"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </td></tr>
<tr class="memitem:ga9742e8cdcccc67c0746578f3579127e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin.html">strexprjoin</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9742e8cdcccc67c0746578f3579127e2">simstr::operator+</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:ga9742e8cdcccc67c0746578f3579127e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An addition operator for two arbitrary string expressions of the same character type.  <br /></td></tr>
<tr class="separator:ga9742e8cdcccc67c0746578f3579127e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8bc7652fac165ad43ae054fb083616" id="r_ga9d8bc7652fac165ad43ae054fb083616"><td class="memTemplParams" colspan="2">template&lt;typename K, StrExprForType&lt; K &gt; A&gt; </td></tr>
<tr class="memitem:ga9d8bc7652fac165ad43ae054fb083616"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_char&lt; K &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9d8bc7652fac165ad43ae054fb083616">simstr::operator+</a> (const A &amp;a, K s)</td></tr>
<tr class="memdesc:ga9d8bc7652fac165ad43ae054fb083616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator of a string expression and one character.  <br /></td></tr>
<tr class="separator:ga9d8bc7652fac165ad43ae054fb083616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d62d117c726329b31a3ab6b35e8153" id="r_gab0d62d117c726329b31a3ab6b35e8153"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:gab0d62d117c726329b31a3ab6b35e8153"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_char&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab0d62d117c726329b31a3ab6b35e8153">simstr::e_char</a> (K s)</td></tr>
<tr class="memdesc:gab0d62d117c726329b31a3ab6b35e8153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of 1 given character.  <br /></td></tr>
<tr class="separator:gab0d62d117c726329b31a3ab6b35e8153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9c377a32a2cc243efce977c4adffe3" id="r_ga9e9c377a32a2cc243efce977c4adffe3"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N = const_lit&lt;T&gt;::Count&gt; </td></tr>
<tr class="memitem:ga9e9c377a32a2cc243efce977c4adffe3"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal&lt; typename const_lit&lt; T &gt;::symb_type, static_cast&lt; size_t &gt;(N - 1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9e9c377a32a2cc243efce977c4adffe3">simstr::e_t</a> (T &amp;&amp;s)</td></tr>
<tr class="memdesc:ga9e9c377a32a2cc243efce977c4adffe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string literal to a string expression.  <br /></td></tr>
<tr class="separator:ga9e9c377a32a2cc243efce977c4adffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426dd6edd38c382f64fb4cc547896c80" id="r_ga426dd6edd38c382f64fb4cc547896c80"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename T, typename P = typename const_lit&lt;T&gt;::symb_type, size_t N = const_lit&lt;T&gt;::Count&gt; <br />
requires <a class="el" href="#ga4cc5f9a930baa653948843b0d2284b27">is_equal_str_type_v</a>&lt;typename A::symb_type, P&gt;</td></tr>
<tr class="memitem:ga426dd6edd38c382f64fb4cc547896c80"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal_join&lt; false, P,(N - 1), A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga426dd6edd38c382f64fb4cc547896c80">simstr::operator+</a> (const A &amp;a, T &amp;&amp;s)</td></tr>
<tr class="memdesc:ga426dd6edd38c382f64fb4cc547896c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator for a string expression and a string literal of the same character type.  <br /></td></tr>
<tr class="separator:ga426dd6edd38c382f64fb4cc547896c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c35bc9eecc1509118d73ef5e27d303" id="r_ga07c35bc9eecc1509118d73ef5e27d303"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename T, typename P = typename const_lit&lt;T&gt;::symb_type, size_t N = const_lit&lt;T&gt;::Count&gt; <br />
requires <a class="el" href="#ga4cc5f9a930baa653948843b0d2284b27">is_equal_str_type_v</a>&lt;typename A::symb_type, P&gt;</td></tr>
<tr class="memitem:ga07c35bc9eecc1509118d73ef5e27d303"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_literal_join&lt; true, P,(N - 1), A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga07c35bc9eecc1509118d73ef5e27d303">simstr::operator+</a> (T &amp;&amp;s, const A &amp;a)</td></tr>
<tr class="memdesc:ga07c35bc9eecc1509118d73ef5e27d303"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator for a string literal of the same character type and string expression.  <br /></td></tr>
<tr class="separator:ga07c35bc9eecc1509118d73ef5e27d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e02268e25a635b4b7e14d0744b46c1" id="r_ga33e02268e25a635b4b7e14d0744b46c1"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ga33e02268e25a635b4b7e14d0744b46c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; u8s, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga33e02268e25a635b4b7e14d0744b46c1">simstr::e_spca</a> ()</td></tr>
<tr class="memdesc:ga33e02268e25a635b4b7e14d0744b46c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of N char spaces.  <br /></td></tr>
<tr class="separator:ga33e02268e25a635b4b7e14d0744b46c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b5d15132fcc706d1edc1364673a4ab" id="r_ga23b5d15132fcc706d1edc1364673a4ab"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ga23b5d15132fcc706d1edc1364673a4ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; uws, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga23b5d15132fcc706d1edc1364673a4ab">simstr::e_spcw</a> ()</td></tr>
<tr class="memdesc:ga23b5d15132fcc706d1edc1364673a4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of N wchar_t spaces.  <br /></td></tr>
<tr class="separator:ga23b5d15132fcc706d1edc1364673a4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54b64072b9629a32837d9197dfe51b5" id="r_gab54b64072b9629a32837d9197dfe51b5"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:gab54b64072b9629a32837d9197dfe51b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__pad.html">expr_pad</a>&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab54b64072b9629a32837d9197dfe51b5">simstr::e_c</a> (size_t l, K s)</td></tr>
<tr class="memdesc:gab54b64072b9629a32837d9197dfe51b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string of l characters s of type K.  <br /></td></tr>
<tr class="separator:gab54b64072b9629a32837d9197dfe51b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d17e531ba0aa5e62e0480fa8b1a1497" id="r_ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memTemplParams" colspan="2">template&lt;typename T, typename K = const_lit&lt;T&gt;::symb_type, size_t M = const_lit&lt;T&gt;::Count&gt; <br />
requires (M &gt; 0)</td></tr>
<tr class="memitem:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_repeat_lit&lt; K, M - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9d17e531ba0aa5e62e0480fa8b1a1497">simstr::e_repeat</a> (T &amp;&amp;s, size_t l)</td></tr>
<tr class="memdesc:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string from l string constants s of type K.  <br /></td></tr>
<tr class="separator:ga9d17e531ba0aa5e62e0480fa8b1a1497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110a07b71eab2b667f78afc1068df0a9" id="r_ga110a07b71eab2b667f78afc1068df0a9"><td class="memTemplParams" colspan="2">template&lt;StrExpr A&gt; </td></tr>
<tr class="memitem:ga110a07b71eab2b667f78afc1068df0a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_repeat_expr&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga110a07b71eab2b667f78afc1068df0a9">simstr::e_repeat</a> (const A &amp;s, size_t l)</td></tr>
<tr class="memdesc:ga110a07b71eab2b667f78afc1068df0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string from l string expressions s of type K.  <br /></td></tr>
<tr class="separator:ga110a07b71eab2b667f78afc1068df0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab058a69a654cf3a0fce197e862a7400e" id="r_gab058a69a654cf3a0fce197e862a7400e"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </td></tr>
<tr class="memitem:gab058a69a654cf3a0fce197e862a7400e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice.html">expr_choice</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab058a69a654cf3a0fce197e862a7400e">simstr::e_choice</a> (bool c, const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:gab058a69a654cf3a0fce197e862a7400e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a conditional string expression <a class="el" href="structsimstr_1_1expr__choice.html" title="Conditional selection string expression.">expr_choice</a>.  <br /></td></tr>
<tr class="separator:gab058a69a654cf3a0fce197e862a7400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83da2cba80aa8121f4a43727a2914a35" id="r_ga83da2cba80aa8121f4a43727a2914a35"><td class="memTemplParams" colspan="2"><a id="ga83da2cba80aa8121f4a43727a2914a35" name="ga83da2cba80aa8121f4a43727a2914a35"></a>
template&lt;StrExpr A, typename T, size_t N = const_lit_for&lt;typename A::symb_type, T&gt;::Count&gt; </td></tr>
<tr class="memitem:ga83da2cba80aa8121f4a43727a2914a35"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__one__lit.html">expr_choice_one_lit</a>&lt; typename const_lit&lt; T &gt;::symb_type, A, N - 1, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::e_choice</b> (bool c, const A &amp;a, T &amp;&amp;str)</td></tr>
<tr class="memdesc:ga83da2cba80aa8121f4a43727a2914a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the third argument is a string literal. <br /></td></tr>
<tr class="separator:ga83da2cba80aa8121f4a43727a2914a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad305cec2225b216a16282ce343ef4162" id="r_gad305cec2225b216a16282ce343ef4162"><td class="memTemplParams" colspan="2"><a id="gad305cec2225b216a16282ce343ef4162" name="gad305cec2225b216a16282ce343ef4162"></a>
template&lt;StrExpr A, typename T, size_t N = const_lit_for&lt;typename A::symb_type, T&gt;::Count&gt; </td></tr>
<tr class="memitem:gad305cec2225b216a16282ce343ef4162"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__one__lit.html">expr_choice_one_lit</a>&lt; typename const_lit&lt; T &gt;::symb_type, A, N - 1, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::e_choice</b> (bool c, T &amp;&amp;str, const A &amp;a)</td></tr>
<tr class="memdesc:gad305cec2225b216a16282ce343ef4162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the second argument is a string literal. <br /></td></tr>
<tr class="separator:gad305cec2225b216a16282ce343ef4162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081bd71800edf88c06cbfbbd9aba4107" id="r_ga081bd71800edf88c06cbfbbd9aba4107"><td class="memTemplParams" colspan="2"><a id="ga081bd71800edf88c06cbfbbd9aba4107" name="ga081bd71800edf88c06cbfbbd9aba4107"></a>
template&lt;typename T, typename L, typename K = typename const_lit&lt;T&gt;::symb_type, typename P = typename const_lit&lt;L&gt;::symb_type, size_t N = const_lit&lt;T&gt;::Count, size_t M = const_lit_for&lt;typename const_lit&lt;T&gt;::symb_type, L&gt;::Count&gt; <br />
requires <a class="el" href="#ga4cc5f9a930baa653948843b0d2284b27">is_equal_str_type_v</a>&lt;K, P&gt;</td></tr>
<tr class="memitem:ga081bd71800edf88c06cbfbbd9aba4107"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__choice__two__lit.html">expr_choice_two_lit</a>&lt; K, N -1, P, M - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::e_choice</b> (bool c, T &amp;&amp;str_a, L &amp;&amp;str_b)</td></tr>
<tr class="memdesc:ga081bd71800edf88c06cbfbbd9aba4107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_choice when the second and third arguments are string literals. <br /></td></tr>
<tr class="separator:ga081bd71800edf88c06cbfbbd9aba4107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2bd93f7c79b2c59ddf5adb18246751" id="r_ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memTemplParams" colspan="2">template&lt;StrExpr A&gt; </td></tr>
<tr class="memitem:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1expr__if.html">expr_if</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">simstr::e_if</a> (bool c, const A &amp;a)</td></tr>
<tr class="memdesc:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a conditional string expression <a class="el" href="structsimstr_1_1expr__if.html" title="Conditional selection string expression.">expr_if</a>.  <br /></td></tr>
<tr class="separator:ga1f2bd93f7c79b2c59ddf5adb18246751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaea41c25b6dc26662221fd1c5fb705c" id="r_gacaea41c25b6dc26662221fd1c5fb705c"><td class="memTemplParams" colspan="2"><a id="gacaea41c25b6dc26662221fd1c5fb705c" name="gacaea41c25b6dc26662221fd1c5fb705c"></a>
template&lt;typename T, size_t N = const_lit&lt;T&gt;::Count&gt; </td></tr>
<tr class="memitem:gacaea41c25b6dc26662221fd1c5fb705c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::e_if</b> (bool c, T &amp;&amp;str)</td></tr>
<tr class="memdesc:gacaea41c25b6dc26662221fd1c5fb705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload e_if when the second argument is a string literal. <br /></td></tr>
<tr class="separator:gacaea41c25b6dc26662221fd1c5fb705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c4277f5b85cd9742e02f648af92fb9" id="r_gae2c4277f5b85cd9742e02f648af92fb9"><td class="memTemplParams" colspan="2"><a id="gae2c4277f5b85cd9742e02f648af92fb9" name="gae2c4277f5b85cd9742e02f648af92fb9"></a>
template&lt;StdStrSource T, StrExprForType&lt; typename T::value_type &gt; A&gt; </td></tr>
<tr class="memitem:gae2c4277f5b85cd9742e02f648af92fb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; typename T::value_type, T &gt;, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const A &amp;a, const T &amp;s)</td></tr>
<tr class="memdesc:gae2c4277f5b85cd9742e02f648af92fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator for string expression and standard strings of compatible type. <br /></td></tr>
<tr class="separator:gae2c4277f5b85cd9742e02f648af92fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8a4a6047c5eb6bc13d23064f8778fe" id="r_gacd8a4a6047c5eb6bc13d23064f8778fe"><td class="memTemplParams" colspan="2"><a id="gacd8a4a6047c5eb6bc13d23064f8778fe" name="gacd8a4a6047c5eb6bc13d23064f8778fe"></a>
template&lt;StdStrSource T, StrExprForType&lt; typename T::value_type &gt; A&gt; </td></tr>
<tr class="memitem:gacd8a4a6047c5eb6bc13d23064f8778fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, <a class="el" href="structsimstr_1_1expr__stdstr.html">expr_stdstr</a>&lt; typename T::value_type, T &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simstr::operator+</b> (const T &amp;s, const A &amp;a)</td></tr>
<tr class="memdesc:gacd8a4a6047c5eb6bc13d23064f8778fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addition operator for standard strings and string expressions of compatible type. <br /></td></tr>
<tr class="separator:gacd8a4a6047c5eb6bc13d23064f8778fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0421f6f954a1f0a4575cb282c1e36712" id="r_ga0421f6f954a1f0a4575cb282c1e36712"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, FromIntNumber T&gt; </td></tr>
<tr class="memitem:ga0421f6f954a1f0a4575cb282c1e36712"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_num&lt; typename A::symb_type, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0421f6f954a1f0a4575cb282c1e36712">simstr::operator+</a> (const A &amp;a, T s)</td></tr>
<tr class="memdesc:ga0421f6f954a1f0a4575cb282c1e36712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for string expression and integer.  <br /></td></tr>
<tr class="separator:ga0421f6f954a1f0a4575cb282c1e36712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6edec79f617564db65f91039283f39" id="r_gaff6edec79f617564db65f91039283f39"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, FromIntNumber T&gt; </td></tr>
<tr class="memitem:gaff6edec79f617564db65f91039283f39"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_num&lt; typename A::symb_type, T &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaff6edec79f617564db65f91039283f39">simstr::operator+</a> (T s, const A &amp;a)</td></tr>
<tr class="memdesc:gaff6edec79f617564db65f91039283f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for integer and string expression.  <br /></td></tr>
<tr class="separator:gaff6edec79f617564db65f91039283f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd001ccf59de81ceb1493eff2d2214f" id="r_ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memTemplParams" colspan="2">template&lt;typename K, FromIntNumber T&gt; </td></tr>
<tr class="memitem:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_num&lt; K, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4bd001ccf59de81ceb1493eff2d2214f">simstr::e_num</a> (T t)</td></tr>
<tr class="memdesc:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a string expression.  <br /></td></tr>
<tr class="separator:ga4bd001ccf59de81ceb1493eff2d2214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a42429815e770265b76a4211d55b2c5" id="r_ga1a42429815e770265b76a4211d55b2c5"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename R&gt; <br />
requires (std::is_same_v&lt;R, double&gt; || std::is_same_v&lt;R, float&gt;)</td></tr>
<tr class="memitem:ga1a42429815e770265b76a4211d55b2c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_real&lt; typename A::symb_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1a42429815e770265b76a4211d55b2c5">simstr::operator+</a> (const A &amp;a, R s)</td></tr>
<tr class="memdesc:ga1a42429815e770265b76a4211d55b2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for string expression and real number (<code>float</code>, <code>double</code>).  <br /></td></tr>
<tr class="separator:ga1a42429815e770265b76a4211d55b2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b067a24eabc409c0b323d4560cf063f" id="r_ga8b067a24eabc409c0b323d4560cf063f"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename R&gt; <br />
requires (std::is_same_v&lt;R, double&gt; || std::is_same_v&lt;R, float&gt;)</td></tr>
<tr class="memitem:ga8b067a24eabc409c0b323d4560cf063f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_real&lt; typename A::symb_type &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8b067a24eabc409c0b323d4560cf063f">simstr::operator+</a> (R s, const A &amp;a)</td></tr>
<tr class="memdesc:ga8b067a24eabc409c0b323d4560cf063f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for float (<code>float</code>, <code>double</code>) and string expression.  <br /></td></tr>
<tr class="separator:ga8b067a24eabc409c0b323d4560cf063f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea7fe28fcd6fdb6dcae8035eb3b8744" id="r_gacea7fe28fcd6fdb6dcae8035eb3b8744"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires is_one_of_char_v&lt;K&gt;</td></tr>
<tr class="memitem:gacea7fe28fcd6fdb6dcae8035eb3b8744"><td class="memTemplItemLeft" align="right" valign="top">constexpr expr_real&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacea7fe28fcd6fdb6dcae8035eb3b8744">simstr::e_num</a> (double t)</td></tr>
<tr class="memdesc:gacea7fe28fcd6fdb6dcae8035eb3b8744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <code>double</code> number to a string expression.  <br /></td></tr>
<tr class="separator:gacea7fe28fcd6fdb6dcae8035eb3b8744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae75ae56c754403fbf9f5b610a3326b" id="r_ga6ae75ae56c754403fbf9f5b610a3326b"><td class="memTemplParams" colspan="2">template&lt;unsigned Flags = 0, FromIntNumber T&gt; </td></tr>
<tr class="memitem:ga6ae75ae56c754403fbf9f5b610a3326b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6ae75ae56c754403fbf9f5b610a3326b">simstr::e_hex</a> (T v)</td></tr>
<tr class="memdesc:ga6ae75ae56c754403fbf9f5b610a3326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to concatenate text and a unsigned number in hexadecimal.  <br /></td></tr>
<tr class="separator:ga6ae75ae56c754403fbf9f5b610a3326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166596bf110c32b8c6bdb79917cd2384" id="r_ga166596bf110c32b8c6bdb79917cd2384"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename Val, bool All, bool Ucase, bool Ox&gt; </td></tr>
<tr class="memitem:ga166596bf110c32b8c6bdb79917cd2384"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_hex&lt; typename A::symb_type, Val, All, Ucase, Ox &gt;, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga166596bf110c32b8c6bdb79917cd2384">simstr::operator+</a> (const A &amp;a, const expr_hex_src&lt; Val, All, Ucase, Ox &gt; &amp;b)</td></tr>
<tr class="memdesc:ga166596bf110c32b8c6bdb79917cd2384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for a string expression and a hexadecimal representation of a number from <a class="el" href="#ga6ae75ae56c754403fbf9f5b610a3326b" title="Allows you to concatenate text and a unsigned number in hexadecimal.">e_hex()</a>.  <br /></td></tr>
<tr class="separator:ga166596bf110c32b8c6bdb79917cd2384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356a058d98bfa4eca0a44e49745bde28" id="r_ga356a058d98bfa4eca0a44e49745bde28"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename Val, bool All, bool Ucase, bool Ox&gt; </td></tr>
<tr class="memitem:ga356a058d98bfa4eca0a44e49745bde28"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_hex&lt; typename A::symb_type, Val, All, Ucase, Ox &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga356a058d98bfa4eca0a44e49745bde28">simstr::operator+</a> (const expr_hex_src&lt; Val, All, Ucase, Ox &gt; &amp;b, const A &amp;a)</td></tr>
<tr class="memdesc:ga356a058d98bfa4eca0a44e49745bde28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for the hexadecimal representation of a number from <a class="el" href="#ga6ae75ae56c754403fbf9f5b610a3326b" title="Allows you to concatenate text and a unsigned number in hexadecimal.">e_hex()</a> and a string expression.  <br /></td></tr>
<tr class="separator:ga356a058d98bfa4eca0a44e49745bde28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d03cfa41a4f78e843b88b0ce74be7c8" id="r_ga0d03cfa41a4f78e843b88b0ce74be7c8"><td class="memTemplParams" colspan="2">template&lt;StrExpr A&gt; </td></tr>
<tr class="memitem:ga0d03cfa41a4f78e843b88b0ce74be7c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_hex&lt; typename A::symb_type, uintptr_t, true, true, true &gt;, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0d03cfa41a4f78e843b88b0ce74be7c8">simstr::operator+</a> (const A &amp;a, const void *b)</td></tr>
<tr class="memdesc:ga0d03cfa41a4f78e843b88b0ce74be7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for a string expression and a pointer, representing it as 0xDEADBEEF.  <br /></td></tr>
<tr class="separator:ga0d03cfa41a4f78e843b88b0ce74be7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5befc2f161aca230425db4c66cc90ce5" id="r_ga5befc2f161aca230425db4c66cc90ce5"><td class="memTemplParams" colspan="2">template&lt;StrExpr A&gt; </td></tr>
<tr class="memitem:ga5befc2f161aca230425db4c66cc90ce5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_hex&lt; typename A::symb_type, uintptr_t, true, true, true &gt;, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5befc2f161aca230425db4c66cc90ce5">simstr::operator+</a> (const void *b, const A &amp;a)</td></tr>
<tr class="memdesc:ga5befc2f161aca230425db4c66cc90ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation operator for a pointer and a string expression, representing it as 0xDEADBEEF.  <br /></td></tr>
<tr class="separator:ga5befc2f161aca230425db4c66cc90ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29b819f35d451888d14bae0217478561" id="r_ga29b819f35d451888d14bae0217478561"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename K = typename A::symb_type&gt; </td></tr>
<tr class="memitem:ga29b819f35d451888d14bae0217478561"><td class="memTemplItemLeft" align="right" valign="top">expr_fill&lt; K, A, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga29b819f35d451888d14bae0217478561">simstr::e_fill_left</a> (const A &amp;a, size_t width, K symbol=K(' '))</td></tr>
<tr class="memdesc:ga29b819f35d451888d14bae0217478561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expression that expands the specified string expression to the specified length given character to the left.  <br /></td></tr>
<tr class="separator:ga29b819f35d451888d14bae0217478561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35d4285042cb44083773109576055f7" id="r_gaa35d4285042cb44083773109576055f7"><td class="memTemplParams" colspan="2">template&lt;StrExpr A, typename K = typename A::symb_type&gt; </td></tr>
<tr class="memitem:gaa35d4285042cb44083773109576055f7"><td class="memTemplItemLeft" align="right" valign="top">expr_fill&lt; K, A, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa35d4285042cb44083773109576055f7">simstr::e_fill_right</a> (const A &amp;a, size_t width, K symbol=K(' '))</td></tr>
<tr class="memdesc:gaa35d4285042cb44083773109576055f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expression that expands the specified string expression to the specified length given character to the right.  <br /></td></tr>
<tr class="separator:gaa35d4285042cb44083773109576055f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2e6b8a52bfe20c0b86d25f9f78cb52" id="r_gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memTemplParams" colspan="2">template&lt;bool tail = false, bool skip_empty = false, typename L, typename K = typename const_lit&lt;L&gt;::symb_type, size_t I = const_lit&lt;L&gt;::Count, typename T&gt; </td></tr>
<tr class="memitem:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafd2e6b8a52bfe20c0b86d25f9f78cb52">simstr::e_join</a> (const T &amp;s, L &amp;&amp;d)</td></tr>
<tr class="memdesc:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression concatenating the strings in the container into a single string with the given delimiter.limiter.limiter.  <br /></td></tr>
<tr class="separator:gafd2e6b8a52bfe20c0b86d25f9f78cb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb0987b3c98cd839334c33bc1c94bead" id="r_gafb0987b3c98cd839334c33bc1c94bead"><td class="memTemplParams" colspan="2">template&lt;StrSource A, typename K = src_str_t&lt;A&gt;, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename X, size_t L = const_lit_for&lt;K, X&gt;::Count&gt; <br />
requires (N &gt; 1)</td></tr>
<tr class="memitem:gafb0987b3c98cd839334c33bc1c94bead"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafb0987b3c98cd839334c33bc1c94bead">simstr::e_repl</a> (A &amp;&amp;w, T &amp;&amp;p, X &amp;&amp;r)</td></tr>
<tr class="memdesc:gafb0987b3c98cd839334c33bc1c94bead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that generates a string with all occurrences of a given substring replaced.  <br /></td></tr>
<tr class="separator:gafb0987b3c98cd839334c33bc1c94bead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc0ac8162caa4ae9c808b435397704a" id="r_ga6cc0ac8162caa4ae9c808b435397704a"><td class="memTemplParams" colspan="2">template&lt;StrSource A, typename K = src_str_t&lt;A&gt;, typename T, typename X&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, T&gt; &amp;&amp; std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, X&gt; &amp;&amp; (!is_const_lit_v&lt;T&gt; || !is_const_lit_v&lt;X&gt;))</td></tr>
<tr class="memitem:ga6cc0ac8162caa4ae9c808b435397704a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6cc0ac8162caa4ae9c808b435397704a">simstr::e_repl</a> (A &amp;&amp;w, T &amp;&amp;p, X &amp;&amp;r)</td></tr>
<tr class="memdesc:ga6cc0ac8162caa4ae9c808b435397704a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that generates a string with all occurrences of a given substring replaced.  <br /></td></tr>
<tr class="separator:ga6cc0ac8162caa4ae9c808b435397704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d0c57d07e6546628ca08398c5ebee6" id="r_gad6d0c57d07e6546628ca08398c5ebee6"><td class="memTemplParams" colspan="2">template&lt;StrSource A, typename K = src_str_t&lt;A&gt;, typename T, StrExprForType&lt; K &gt; E&gt; <br />
requires std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, T&gt;</td></tr>
<tr class="memitem:gad6d0c57d07e6546628ca08398c5ebee6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad6d0c57d07e6546628ca08398c5ebee6">simstr::e_repl</a> (A &amp;&amp;w, T &amp;&amp;p, const E &amp;expr)</td></tr>
<tr class="memdesc:gad6d0c57d07e6546628ca08398c5ebee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string expression that generates a string with all occurrences of a given substring replaced.  <br /></td></tr>
<tr class="separator:gad6d0c57d07e6546628ca08398c5ebee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d4ca53513bcc0d1c0730940ec8a8a1" id="r_gac0d4ca53513bcc0d1c0730940ec8a8a1"><td class="memTemplParams" colspan="2">template&lt;bool UseVector = false, StrSource A, typename K = src_str_t&lt;A&gt;, typename ... Repl&gt; <br />
requires (sizeof...(Repl) % 2 == 0)</td></tr>
<tr class="memitem:gac0d4ca53513bcc0d1c0730940ec8a8a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac0d4ca53513bcc0d1c0730940ec8a8a1">simstr::e_repl_const_symbols</a> (A &amp;&amp;src, Repl &amp;&amp;... other)</td></tr>
<tr class="memdesc:gac0d4ca53513bcc0d1c0730940ec8a8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string expression that generates a string containing the given characters replaced with given substrings.  <br /></td></tr>
<tr class="separator:gac0d4ca53513bcc0d1c0730940ec8a8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22ea6d3c42a2de8611842e367c1bc327" id="r_ga22ea6d3c42a2de8611842e367c1bc327"><td class="memTemplParams" colspan="2">template&lt;simstr::StdStrSource T&gt; </td></tr>
<tr class="memitem:ga22ea6d3c42a2de8611842e367c1bc327"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsimstr_1_1expr__stdstr.html">simstr::expr_stdstr</a>&lt; typename T::value_type, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga22ea6d3c42a2de8611842e367c1bc327">std::operator+</a> (const T &amp;str)</td></tr>
<tr class="memdesc:ga22ea6d3c42a2de8611842e367c1bc327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary operator + for converting standard strings to string expressions.  <br /></td></tr>
<tr class="separator:ga22ea6d3c42a2de8611842e367c1bc327"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga4cc5f9a930baa653948843b0d2284b27" id="r_ga4cc5f9a930baa653948843b0d2284b27"><td class="memTemplParams" colspan="2">template&lt;typename K1, typename K2&gt; </td></tr>
<tr class="memitem:ga4cc5f9a930baa653948843b0d2284b27"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4cc5f9a930baa653948843b0d2284b27">simstr::is_equal_str_type_v</a> = is_one_of_char_v&lt;K1&gt; &amp;&amp; is_one_of_char_v&lt;K2&gt; &amp;&amp; sizeof(K1) == sizeof(K2)</td></tr>
<tr class="memdesc:ga4cc5f9a930baa653948843b0d2284b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two types are compatible string types.  <br /></td></tr>
<tr class="separator:ga4cc5f9a930baa653948843b0d2284b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab19693e574a384f42220cf115ec86c75" id="r_gab19693e574a384f42220cf115ec86c75"><td class="memItemLeft" align="right" valign="top"><a id="gab19693e574a384f42220cf115ec86c75" name="gab19693e574a384f42220cf115ec86c75"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eea</b> {}</td></tr>
<tr class="memdesc:gab19693e574a384f42220cf115ec86c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char. <br /></td></tr>
<tr class="separator:gab19693e574a384f42220cf115ec86c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54de64d6d9cf03f0186e944c924350f" id="r_gac54de64d6d9cf03f0186e944c924350f"><td class="memItemLeft" align="right" valign="top"><a id="gac54de64d6d9cf03f0186e944c924350f" name="gac54de64d6d9cf03f0186e944c924350f"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u8s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eeb</b> {}</td></tr>
<tr class="memdesc:gac54de64d6d9cf03f0186e944c924350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char8_t. <br /></td></tr>
<tr class="separator:gac54de64d6d9cf03f0186e944c924350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ebc01b80560370b2f318d897bb6000a" id="r_ga2ebc01b80560370b2f318d897bb6000a"><td class="memItemLeft" align="right" valign="top"><a id="ga2ebc01b80560370b2f318d897bb6000a" name="ga2ebc01b80560370b2f318d897bb6000a"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; uws &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eew</b> {}</td></tr>
<tr class="memdesc:ga2ebc01b80560370b2f318d897bb6000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type wchar_t. <br /></td></tr>
<tr class="separator:ga2ebc01b80560370b2f318d897bb6000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96ac61f552b627d623bf4958337242a" id="r_gab96ac61f552b627d623bf4958337242a"><td class="memItemLeft" align="right" valign="top"><a id="gab96ac61f552b627d623bf4958337242a" name="gab96ac61f552b627d623bf4958337242a"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u16s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eeu</b> {}</td></tr>
<tr class="memdesc:gab96ac61f552b627d623bf4958337242a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char16_t. <br /></td></tr>
<tr class="separator:gab96ac61f552b627d623bf4958337242a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470627498bd16d6b5337607650d1c699" id="r_ga470627498bd16d6b5337607650d1c699"><td class="memItemLeft" align="right" valign="top"><a id="ga470627498bd16d6b5337607650d1c699" name="ga470627498bd16d6b5337607650d1c699"></a>
constexpr <a class="el" href="structsimstr_1_1empty__expr.html">empty_expr</a>&lt; u32s &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simstr::eeuu</b> {}</td></tr>
<tr class="memdesc:ga470627498bd16d6b5337607650d1c699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string expression of type char32_t. <br /></td></tr>
<tr class="separator:ga470627498bd16d6b5337607650d1c699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Description of String Expressions. </p>
<p>All owning string types can be initialized using "string expressions" (essentially a variant of <a href="https://en.wikipedia.org/wiki/Expression_templates">https://en.wikipedia.org/wiki/Expression_templates</a> for strings). A string expression is an object of an arbitrary type that has methods:</p><ul>
<li><code>size_t length() const</code>: returns the length of the string</li>
<li><code>K* place(K*) const</code>: copy the characters of the string to the intended buffer and return a pointer behind the last character</li>
<li><code>typename symb_type</code>: shows what type of symbols it works with.</li>
</ul>
<p>During initialization, a string object asks the string expression for its size, allocates the necessary memory, and passes the memory to a string expression that places the characters in the allocated buffer.</p>
<p>Additionally, for compatibility with <code>std</code>, simstr string expressions can be converted to standard strings (std::basic_string) compatible types. Before C++23, <code>resize</code> and <code>data</code> is used, starting with C++23 the more optimal <code>resize_and_overwrite</code> is used. This allows for fast concatenation where standard strings are required.</p>
<p>All library string objects are themselves string expressions that simply copy the original string. Basically, string expressions are used to concatenate or convert strings.</p>
<p>For all string expressions, <a class="el" href="#op_plus_str_expr">operator +</a> is defined, which creates a new string expression from two operands <a class="el" href="structsimstr_1_1strexprjoin.html" title="Template class for concatenating two string expressions into one using operator +">simstr::strexprjoin</a>, which combines two string expressions, and which in the <code>length</code> method returns the sum of the <code>length</code> original operands, and in the <code>place</code> method - places first the first operand, then the second, into the result buffer. And since this operator itself returns a string expression, you can again apply <code>operator +</code> to it, forming a chain of several string expressions, and eventually materialize the last resulting object, which will first calculate the size of the entire shared memory for the final result, and then will place the nested subexpressions into a single buffer.</p>
<p>Also <code>operator +</code> is defined for string expressions and string literals, string expressions and numbers (numbers are converted to decimal representation), and you can also add the desired types of string expressions yourself. Example: </p><div class="fragment"><div class="line">stringa text = header + <span class="stringliteral">&quot;, count = &quot;</span> + count + <span class="stringliteral">&quot;, done&quot;</span>;</div>
</div><!-- fragment --><p> There are several types of string expressions out of the box to perform various operations on strings</p><ul>
<li><code><a class="el" href="structsimstr_1_1expr__spaces.html" title="A type of string expression that returns N specified characters.">expr_spaces</a>&lt; Character Type, Number of Characters, Symbol&gt;{}</code>: returns a string of length Number of Characters, filled with the specified character. The number of characters and character are compile-time constants. For some cases there is a shorthand notation:<ul>
<li><code>e_spca&lt; Number of Characters&gt;()</code>: char string of spaces</li>
<li><code>e_spcw&lt; Number of Characters&gt;()</code>: w_char string of spaces</li>
</ul>
</li>
<li><code><a class="el" href="structsimstr_1_1expr__pad.html" title="A type of string expression that returns N specified characters.">expr_pad</a>&lt; Character Type&gt;{Number of Characters, Symbol}</code>: produces a string long Number of Characters, filled with the specified character. The number of characters and the symbol can be set at runtime. Shorthand: <code>e_c(Number of Characters, Character)</code></li>
<li><code>e_choice(bool Condition, StrExpr1, StrExpr2)</code>: if Condition == true, the result will be StrExpr1, otherwise StrExpr2</li>
<li><code>e_num&lt; CharacterType&gt;(IntegerNumber)</code>: Converts a number to decimal notation. Rarely used because for string expressions and numbers the "+" operator is redefined, and the number can simply be written as text + number;</li>
<li><code>e_real&lt; CharacterType&gt;(RealNumber)</code>: Converts a number to decimal notation. Rarely used because for string expressions and numbers the "+" operator is overridden, and the number can simply be written as <code>text + number</code>;</li>
<li><code>e_join&lt; bool AfterLast = false, bool SkipEmpty = false&gt;(container, "Separator")</code>: concatenates all strings in a container using a separator. If <code>AfterLast == true</code>, then the separator is added after the last element of the container, otherwise only between elements. If <code>Skip Empty == true</code>, then empty lines do not add a separator, otherwise for each empty line a separator is also inserted</li>
<li><code>e_repl(SourceString, Search, Replace)</code>: replaces the occurrences of Search with Replace in the source string.</li>
<li><code>e_hex(Number)</code>: generates a string with hexadecimal representation of the number.</li>
<li><code>e_fill_left(StrExpr, width, symbol)</code>, <code>e_fill_right(StrExpr, width, symbol)</code>: fills a string expression to the required length with a given character. etc. etc.</li>
</ul>
<p>String expressions for characters of different but compatible types can be combined into one expression. That is, you can combine <code>char</code> and <code>char8_t</code>, and under Linux <code>wchar_t</code> and <code>char32_t</code>, under Windows <code>wchar_t</code> and <code>char16_t</code>. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga680097382d9bc271c361f85828ac741f" name="ga680097382d9bc271c361f85828ac741f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680097382d9bc271c361f85828ac741f">&#9670;&#160;</a></span>HexFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga680097382d9bc271c361f85828ac741f">simstr::HexFlags</a> : unsigned</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for the e_hex function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga680097382d9bc271c361f85828ac741fad4ddbe11a4c8e3daca5795ad268df0c4" name="gga680097382d9bc271c361f85828ac741fad4ddbe11a4c8e3daca5795ad268df0c4"></a>Short&#160;</td><td class="fielddoc"><p>without leading zeroes </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab54b64072b9629a32837d9197dfe51b5" name="gab54b64072b9629a32837d9197dfe51b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab54b64072b9629a32837d9197dfe51b5">&#9670;&#160;</a></span>e_c()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__pad.html">expr_pad</a>&lt; K &gt; simstr::e_c </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string of l characters s of type K. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>is a symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>- number of characters. </td></tr>
    <tr><td class="paramname">s</td><td>- symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression that generates a string of l characters k. </dd></dl>

</div>
</div>
<a id="gab0d62d117c726329b31a3ab6b35e8153" name="gab0d62d117c726329b31a3ab6b35e8153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d62d117c726329b31a3ab6b35e8153">&#9670;&#160;</a></span>e_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_char&lt; K &gt; simstr::e_char </td>
          <td>(</td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string of 1 given character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string expression for a single character string. </dd></dl>

</div>
</div>
<a id="gab058a69a654cf3a0fce197e862a7400e" name="gab058a69a654cf3a0fce197e862a7400e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab058a69a654cf3a0fce197e862a7400e">&#9670;&#160;</a></span>e_choice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__choice.html">expr_choice</a>&lt; A, B &gt; simstr::e_choice </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a conditional string expression <a class="el" href="structsimstr_1_1expr__choice.html" title="Conditional selection string expression.">expr_choice</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- Type expression when the condition is true, inferred from the argument. </td></tr>
    <tr><td class="paramname">B</td><td>- The type of expression when the condition is false, inferred from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>is a Boolean condition. </td></tr>
    <tr><td class="paramname">a</td><td>is a string expression that is executed when <code>c == true</code>. </td></tr>
    <tr><td class="paramname">b</td><td>is a string expression that is executed when <code>c == false</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Serves to allow you to select different options in one expression depending on the condition.</p>
<p>Example: </p><div class="fragment"><div class="line">columns_metadata.emplace_back(<a class="code hl_function" href="#gab058a69a654cf3a0fce197e862a7400e">e_choice</a>(name.is_empty(), <span class="stringliteral">&quot;?column?&quot;</span>, name) + <span class="stringliteral">&quot;::&quot;</span> + metadata_column.type.to_string());</div>
<div class="ttc" id="agroup___str_exprs_html_gab058a69a654cf3a0fce197e862a7400e"><div class="ttname"><a href="#gab058a69a654cf3a0fce197e862a7400e">simstr::e_choice</a></div><div class="ttdeci">constexpr expr_choice&lt; A, B &gt; e_choice(bool c, const A &amp;a, const B &amp;b)</div><div class="ttdoc">Create a conditional string expression expr_choice.</div><div class="ttdef"><b>Definition</b> strexpr.h:1240</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">lstringa&lt;512&gt; <a class="code hl_namespace" href="namespacesimstr_1_1str.html">str</a> = <a class="code hl_function" href="#gab058a69a654cf3a0fce197e862a7400e">e_choice</a>(!ret_type_resolver_, sql_value::type_name(ret_type_), <span class="stringliteral">&quot;any&quot;</span>) + <span class="stringliteral">&quot; &quot;</span> + name_ + <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="ttc" id="anamespacesimstr_1_1str_html"><div class="ttname"><a href="namespacesimstr_1_1str.html">simstr::str</a></div><div class="ttdoc">Small namespace for standard string methods.</div><div class="ttdef"><b>Definition</b> strexpr.h:1393</div></div>
</div><!-- fragment --><p> Otherwise, such operations would have to be split into several string modifications or the use of temporary strings, which is not optimal and will reduce performance. (This is checked in the "Build Full Func Name" benchmark) </p>

</div>
</div>
<a id="ga29b819f35d451888d14bae0217478561" name="ga29b819f35d451888d14bae0217478561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29b819f35d451888d14bae0217478561">&#9670;&#160;</a></span>e_fill_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename K = typename A::symb_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">expr_fill&lt; K, A, true &gt; simstr::e_fill_left </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">K('&#160;')</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an expression that expands the specified string expression to the specified length given character to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>- pad to this width </td></tr>
    <tr><td class="paramname">symbol</td><td>- symbol to fill</td></tr>
  </table>
  </dd>
</dl>
<p>If a string expression produces a string shorter than the given length, prepend it with the specified character, padding to the desired length. Does not truncate the string to the specified length. Be careful, the length is taken in code units, not in code points, and the padding character cannot be a surrogate, that is, occupy more than one code unit. If you have to be precise with Unicode characters - use conversion to char32_t and vice versa. </p>

</div>
</div>
<a id="gaa35d4285042cb44083773109576055f7" name="gaa35d4285042cb44083773109576055f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa35d4285042cb44083773109576055f7">&#9670;&#160;</a></span>e_fill_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename K = typename A::symb_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">expr_fill&lt; K, A, false &gt; simstr::e_fill_right </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">K('&#160;')</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an expression that expands the specified string expression to the specified length given character to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>- pad to this width </td></tr>
    <tr><td class="paramname">symbol</td><td>- symbol to fill</td></tr>
  </table>
  </dd>
</dl>
<p>If a string expression produces a string shorter than the given length, appends it the specified character, padding to the desired length. Does not truncate the string to the specified length. Be careful, the length is taken in code units, not in code points, and the padding character cannot be a surrogate, that is, occupy more than one code unit. If you have to be precise with Unicode characters - use conversion to char32_t and vice versa. </p>

</div>
</div>
<a id="ga6ae75ae56c754403fbf9f5b610a3326b" name="ga6ae75ae56c754403fbf9f5b610a3326b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ae75ae56c754403fbf9f5b610a3326b">&#9670;&#160;</a></span>e_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned Flags = 0, FromIntNumber T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_hex </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows you to concatenate text and a unsigned number in hexadecimal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Flags</td><td>- format flags, bitwise OR of <a class="el" href="#ga680097382d9bc271c361f85828ac741f" title="Flags for the e_hex function.">HexFlags</a>. </td></tr>
    <tr><td class="paramname">T</td><td>- number type, deducted automatically.</td></tr>
  </table>
  </dd>
</dl>
<p>Example </p><div class="fragment"><div class="line">stringa text = +<span class="stringliteral">&quot;val = &quot;</span>sv + <a class="code hl_function" href="#ga6ae75ae56c754403fbf9f5b610a3326b">e_hex</a>(10u);</div>
<div class="line">EXPECT_EQ(text, <span class="stringliteral">&quot;val = 0x0000000A&quot;</span>);</div>
<div class="line"> </div>
<div class="line">stringu textu = +u<span class="stringliteral">&quot;val = 0X&quot;</span>sv + <a class="code hl_function" href="#ga6ae75ae56c754403fbf9f5b610a3326b">e_hex&lt;HexFlags::No0x | HexFlags::Short | HexFlags::Lcase&gt;</a>(0x12Au);</div>
<div class="line">EXPECT_EQ(textu, u<span class="stringliteral">&quot;val = 0X12a&quot;</span>);</div>
<div class="ttc" id="agroup___str_exprs_html_ga6ae75ae56c754403fbf9f5b610a3326b"><div class="ttname"><a href="#ga6ae75ae56c754403fbf9f5b610a3326b">simstr::e_hex</a></div><div class="ttdeci">constexpr auto e_hex(T v)</div><div class="ttdoc">Allows you to concatenate text and a unsigned number in hexadecimal.</div><div class="ttdef"><b>Definition</b> strexpr.h:1704</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga1f2bd93f7c79b2c59ddf5adb18246751" name="ga1f2bd93f7c79b2c59ddf5adb18246751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f2bd93f7c79b2c59ddf5adb18246751">&#9670;&#160;</a></span>e_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__if.html">expr_if</a>&lt; A &gt; simstr::e_if </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating a conditional string expression <a class="el" href="structsimstr_1_1expr__if.html" title="Conditional selection string expression.">expr_if</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- Type expression when the condition is true, inferred from the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- boolean condition </td></tr>
    <tr><td class="paramname">a</td><td>- string expression executed when <code>c == true</code></td></tr>
  </table>
  </dd>
</dl>
<p>Serves to allow one expression to generate, depending on the condition, either the specified option or an empty string.</p>
<p>Example </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> sql_func_info::build_full_name() {</div>
<div class="line">    <span class="comment">//    ,   </span></div>
<div class="line">    <span class="comment">// Temporary buffer for the result, take it with reserve</span></div>
<div class="line">    lstringa&lt;512&gt; <a class="code hl_namespace" href="namespacesimstr_1_1str.html">str</a> = <a class="code hl_function" href="#gab058a69a654cf3a0fce197e862a7400e">e_choice</a>(!ret_type_resolver_, sql_value::type_name(ret_type_), <span class="stringliteral">&quot;any&quot;</span>) + <span class="stringliteral">&quot; &quot;</span> + name_ + <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> add_comma = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; param : params_) {</div>
<div class="line">        <a class="code hl_namespace" href="namespacesimstr_1_1str.html">str</a> += <a class="code hl_function" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a>(add_comma, <span class="stringliteral">&quot;, &quot;</span>) + <a class="code hl_function" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a>(param.optional_, <span class="stringliteral">&quot;[&quot;</span>);</div>
<div class="line">        <span class="comment">//   str   </span></div>
<div class="line">        <span class="comment">// Adds the names of valid types to str</span></div>
<div class="line">        param.allowed_types.to_string(<a class="code hl_namespace" href="namespacesimstr_1_1str.html">str</a>);</div>
<div class="line">        <span class="keywordflow">if</span> (param.optional_) {</div>
<div class="line">            <a class="code hl_namespace" href="namespacesimstr_1_1str.html">str</a> += <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        add_comma = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">//   stringa</span></div>
<div class="line">    <span class="comment">// Save it in stringa</span></div>
<div class="line">    full_name_ = <a class="code hl_namespace" href="namespacesimstr_1_1str.html">str</a> + <a class="code hl_function" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a>(unlim_params_, <a class="code hl_function" href="#ga1f2bd93f7c79b2c59ddf5adb18246751">e_if</a>(add_comma, <span class="stringliteral">&quot;, &quot;</span>) + <span class="stringliteral">&quot;...&quot;</span>) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup___str_exprs_html_ga1f2bd93f7c79b2c59ddf5adb18246751"><div class="ttname"><a href="#ga1f2bd93f7c79b2c59ddf5adb18246751">simstr::e_if</a></div><div class="ttdeci">constexpr expr_if&lt; A &gt; e_if(bool c, const A &amp;a)</div><div class="ttdoc">Creating a conditional string expression expr_if.</div><div class="ttdef"><b>Definition</b> strexpr.h:1318</div></div>
</div><!-- fragment --><p> Otherwise, such operations would have to be split into several string modifications or the use of temporary strings, which is not optimal and will reduce performance. (This example is tested in the "Build Full Func Name" benchmark) </p>

</div>
</div>
<a id="gafd2e6b8a52bfe20c0b86d25f9f78cb52" name="gafd2e6b8a52bfe20c0b86d25f9f78cb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd2e6b8a52bfe20c0b86d25f9f78cb52">&#9670;&#160;</a></span>e_join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool tail = false, bool skip_empty = false, typename L, typename K = typename const_lit&lt;L&gt;::symb_type, size_t I = const_lit&lt;L&gt;::Count, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string expression concatenating the strings in the container into a single string with the given delimiter.limiter.limiter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tail</td><td>- whether to add a separator after the last line. </td></tr>
    <tr><td class="paramname">skip_empty</td><td>- skip empty lines without adding a separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- container with strings, must support <code>range for</code>. </td></tr>
    <tr><td class="paramname">d</td><td>- delimiter, string literal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacea7fe28fcd6fdb6dcae8035eb3b8744" name="gacea7fe28fcd6fdb6dcae8035eb3b8744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacea7fe28fcd6fdb6dcae8035eb3b8744">&#9670;&#160;</a></span>e_num() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires is_one_of_char_v&lt;K&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_real&lt; K &gt; simstr::e_num </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <code>double</code> number to a string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- number.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a string expression that generates the decimal representation of the given number. using <code>sprintf("%.16g")</code>. Can be used when you need to concatenate a number and a string literal. </p>

</div>
</div>
<a id="ga4bd001ccf59de81ceb1493eff2d2214f" name="ga4bd001ccf59de81ceb1493eff2d2214f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bd001ccf59de81ceb1493eff2d2214f">&#9670;&#160;</a></span>e_num() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, FromIntNumber T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_num&lt; K, T &gt; simstr::e_num </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an integer to a string expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- character type. </td></tr>
    <tr><td class="paramname">T</td><td>- number type, inferred from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- number.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a string expression that generates the decimal representation of the given number. Can be used when you need to concatenate a number and a string literal. </p>

</div>
</div>
<a id="ga110a07b71eab2b667f78afc1068df0a9" name="ga110a07b71eab2b667f78afc1068df0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga110a07b71eab2b667f78afc1068df0a9">&#9670;&#160;</a></span>e_repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_repeat_expr&lt; A &gt; simstr::e_repeat </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a string from l string expressions s of type K. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- character type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>- number of repetitions </td></tr>
    <tr><td class="paramname">s</td><td>- string expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression generating a string of l string expressions s </dd></dl>

</div>
</div>
<a id="ga9d17e531ba0aa5e62e0480fa8b1a1497" name="ga9d17e531ba0aa5e62e0480fa8b1a1497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d17e531ba0aa5e62e0480fa8b1a1497">&#9670;&#160;</a></span>e_repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename K = const_lit&lt;T&gt;::symb_type, size_t M = const_lit&lt;T&gt;::Count&gt; <br />
requires (M &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_repeat_lit&lt; K, M - 1 &gt; simstr::e_repeat </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a string from l string constants s of type K. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- character type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>- number of repetitions </td></tr>
    <tr><td class="paramname">s</td><td>- string literal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression generating a string of l strings s </dd></dl>

</div>
</div>
<a id="gad6d0c57d07e6546628ca08398c5ebee6" name="gad6d0c57d07e6546628ca08398c5ebee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6d0c57d07e6546628ca08398c5ebee6">&#9670;&#160;</a></span>e_repl() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrSource A, typename K = src_str_t&lt;A&gt;, typename T, StrExprForType&lt; K &gt; E&gt; <br />
requires std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_repl </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string expression that generates a string with all occurrences of a given substring replaced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- the type of the symbol, inferred from the first argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>- starting string. </td></tr>
    <tr><td class="paramname">p</td><td>- string object, searched substring, maybe runtime. </td></tr>
    <tr><td class="paramname">expr</td><td>- string expression, what to replace with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb0987b3c98cd839334c33bc1c94bead" name="gafb0987b3c98cd839334c33bc1c94bead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb0987b3c98cd839334c33bc1c94bead">&#9670;&#160;</a></span>e_repl() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrSource A, typename K = src_str_t&lt;A&gt;, typename T, size_t N = const_lit_for&lt;K, T&gt;::Count, typename X, size_t L = const_lit_for&lt;K, X&gt;::Count&gt; <br />
requires (N &gt; 1)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_repl </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string expression that generates a string with all occurrences of a given substring replaced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- the type of the symbol, inferred from the first argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>- starting string. </td></tr>
    <tr><td class="paramname">p</td><td>- string literal, searched substring. </td></tr>
    <tr><td class="paramname">r</td><td>- string literal, what to replace with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cc0ac8162caa4ae9c808b435397704a" name="ga6cc0ac8162caa4ae9c808b435397704a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc0ac8162caa4ae9c808b435397704a">&#9670;&#160;</a></span>e_repl() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrSource A, typename K = src_str_t&lt;A&gt;, typename T, typename X&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, T&gt; &amp;&amp; std::is_constructible_v&lt;<a class="el" href="structsimstr_1_1str__src.html">str_src</a>&lt;K&gt;, X&gt; &amp;&amp; (!is_const_lit_v&lt;T&gt; || !is_const_lit_v&lt;X&gt;))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_repl </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string expression that generates a string with all occurrences of a given substring replaced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>- the type of the symbol, inferred from the first argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>- starting string. </td></tr>
    <tr><td class="paramname">p</td><td>- string object, searched substring, maybe runtime. </td></tr>
    <tr><td class="paramname">r</td><td>- string object, replace substring, maybe runtime. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac0d4ca53513bcc0d1c0730940ec8a8a1" name="gac0d4ca53513bcc0d1c0730940ec8a8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d4ca53513bcc0d1c0730940ec8a8a1">&#9670;&#160;</a></span>e_repl_const_symbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseVector = false, StrSource A, typename K = src_str_t&lt;A&gt;, typename ... Repl&gt; <br />
requires (sizeof...(Repl) % 2 == 0)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto simstr::e_repl_const_symbols </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Repl &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string expression that generates a string containing the given characters replaced with given substrings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseVector</td><td>- use a vector to save symbol search results. Described in more detail in <code><a class="el" href="structsimstr_1_1expr__replace__symbols.html" title="A type for a string expression that generates a string in which the given characters are replaced by ...">expr_replace_symbols</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- source string. </td></tr>
    <tr><td class="paramname">symbol</td><td>- constant symbol that needs to be replaced. </td></tr>
    <tr><td class="paramname">repl</td><td>- string literal to replace the character with. </td></tr>
    <tr><td class="paramname">...</td><td>symbol, repl - other symbols and strings.</td></tr>
  </table>
  </dd>
</dl>
<p>Used to generate character replacements for strings if all of them are known at compile time. Example:</p>
<div class="fragment"><div class="line">out += <span class="stringliteral">&quot;&lt;div&gt;&quot;</span> + <a class="code hl_function" href="#gac0d4ca53513bcc0d1c0730940ec8a8a1">e_repl_const_symbols</a>(text, <span class="charliteral">&#39;\&quot;&#39;</span>, <span class="stringliteral">&quot;&amp;quot;&quot;</span>, <span class="charliteral">&#39;&lt;&#39;</span>, <span class="stringliteral">&quot;&amp;lt;&quot;</span>, <span class="charliteral">&#39;\&#39;&#39;</span>, <span class="stringliteral">&quot;&amp;#39;&quot;</span>, <span class="charliteral">&#39;&amp;&#39;</span>, <span class="stringliteral">&quot;&amp;amp;&quot;</span>) + <span class="stringliteral">&quot;&lt;/div&gt;&quot;</span>;</div>
<div class="ttc" id="agroup___str_exprs_html_gac0d4ca53513bcc0d1c0730940ec8a8a1"><div class="ttname"><a href="#gac0d4ca53513bcc0d1c0730940ec8a8a1">simstr::e_repl_const_symbols</a></div><div class="ttdeci">auto e_repl_const_symbols(A &amp;&amp;src, Repl &amp;&amp;... other)</div><div class="ttdoc">Returns a string expression that generates a string containing the given characters replaced with giv...</div><div class="ttdef"><b>Definition</b> strexpr.h:4968</div></div>
</div><!-- fragment --><p> In principle, <code>e_repl_const_symbols</code> is quite safe to return from a function if the source string external to function.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> repl_html_symbols(ssa text) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="#gac0d4ca53513bcc0d1c0730940ec8a8a1">e_repl_const_symbols</a>(text, <span class="charliteral">&#39;\&quot;&#39;</span>, <span class="stringliteral">&quot;&amp;quot;&quot;</span>, <span class="charliteral">&#39;&lt;&#39;</span>, <span class="stringliteral">&quot;&amp;lt;&quot;</span>, <span class="charliteral">&#39;\&#39;&#39;</span>, <span class="stringliteral">&quot;&amp;#39;&quot;</span>, <span class="charliteral">&#39;&amp;&#39;</span>, <span class="stringliteral">&quot;&amp;amp;&quot;</span>);</div>
<div class="line">}</div>
<div class="line">....</div>
<div class="line">out += <span class="stringliteral">&quot;&lt;div&gt;&quot;</span> + repl_html_symbols(content) + <span class="stringliteral">&quot;&lt;/div&gt;&quot;</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga33e02268e25a635b4b7e14d0744b46c1" name="ga33e02268e25a635b4b7e14d0744b46c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33e02268e25a635b4b7e14d0744b46c1">&#9670;&#160;</a></span>e_spca()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; u8s, N &gt; simstr::e_spca </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string of N char spaces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>- Number of spaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string expression for N char spaces.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">stringa text = <a class="code hl_function" href="#ga33e02268e25a635b4b7e14d0744b46c1">e_spca&lt;10&gt;</a>() + text + <a class="code hl_function" href="#ga33e02268e25a635b4b7e14d0744b46c1">e_spca&lt;10&gt;</a>();</div>
<div class="ttc" id="agroup___str_exprs_html_ga33e02268e25a635b4b7e14d0744b46c1"><div class="ttname"><a href="#ga33e02268e25a635b4b7e14d0744b46c1">simstr::e_spca</a></div><div class="ttdeci">constexpr expr_spaces&lt; u8s, N &gt; e_spca()</div><div class="ttdoc">Generates a string of N char spaces.</div><div class="ttdef"><b>Definition</b> strexpr.h:860</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga23b5d15132fcc706d1edc1364673a4ab" name="ga23b5d15132fcc706d1edc1364673a4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b5d15132fcc706d1edc1364673a4ab">&#9670;&#160;</a></span>e_spcw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__spaces.html">expr_spaces</a>&lt; uws, N &gt; simstr::e_spcw </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string of N wchar_t spaces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>- Number of spaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string expression for N wchar_t spaces.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">stringw text = <a class="code hl_function" href="#ga23b5d15132fcc706d1edc1364673a4ab">e_spcw&lt;10&gt;</a>() + text + <a class="code hl_function" href="#ga23b5d15132fcc706d1edc1364673a4ab">e_spcw&lt;10&gt;</a>();</div>
<div class="ttc" id="agroup___str_exprs_html_ga23b5d15132fcc706d1edc1364673a4ab"><div class="ttname"><a href="#ga23b5d15132fcc706d1edc1364673a4ab">simstr::e_spcw</a></div><div class="ttdeci">constexpr expr_spaces&lt; uws, N &gt; e_spcw()</div><div class="ttdoc">Generates a string of N wchar_t spaces.</div><div class="ttdef"><b>Definition</b> strexpr.h:878</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9e9c377a32a2cc243efce977c4adffe3" name="ga9e9c377a32a2cc243efce977c4adffe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e9c377a32a2cc243efce977c4adffe3">&#9670;&#160;</a></span>e_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N = const_lit&lt;T&gt;::Count&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_literal&lt; typename const_lit&lt; T &gt;::symb_type, static_cast&lt; size_t &gt;(N - 1)&gt; simstr::e_t </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string literal to a string expression. </p>
<p>String literals are not themselves string expressions. This usually does not cause problems in concatenation operations, since the second operand is already a string expression, and addition with a literal works for it. But there are situations when the second operand is not either string expression. For example: </p><div class="fragment"><div class="line"> <span class="keywordtype">int</span> intVar = calculate();</div>
<div class="line"> ...</div>
<div class="line">res = <span class="stringliteral">&quot;text&quot;</span> + intVar;</div>
<div class="line"> ...</div>
<div class="line">res = intVar + <span class="stringliteral">&quot;text&quot;</span>;</div>
</div><!-- fragment --><p> In this case, you can convert the literal to a string expression in two ways:</p><ul>
<li>add _ss: <code>"text"_ss</code>, which converts the literal to <a class="el" href="structsimstr_1_1simple__str__nt.html" title="A class that claims to refer to a null-terminated string.">simple_str_nt</a>: <code>res = "text"_ss + intVar</code></li>
<li>apply e_t: <code>e_t("text")</code>, which converts the literal to expr_literal: <code>res = e_t("text") + intVar</code></li>
</ul>
<p>In the second method, the compiler can more aggressively apply optimizations related to what is known at compilation literal size.</p>
<p>Although strictly speaking, in these situations you can use other methods:</p><ul>
<li>Add an operand - an empty string expression: <code>result = eea + "text" + intVar</code>, <code>result = "text" + eea + intVar</code></li>
<li>Convert another operand to a string expression: <code>result = "text" + e_num&lt;u8s&gt;(intVar)</code>.</li>
</ul>
<p>All these methods work and give the same result. Which one to use is a matter of taste. </p>

</div>
</div>
<a id="ga9742e8cdcccc67c0746578f3579127e2" name="ga9742e8cdcccc67c0746578f3579127e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9742e8cdcccc67c0746578f3579127e2">&#9670;&#160;</a></span>operator+() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, StrExprForType&lt; typename A::symb_type &gt; B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin.html">strexprjoin</a>&lt; A, B &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An addition operator for two arbitrary string expressions of the same character type. </p>
<p><a class="anchor" id="op_plus_str_expr"></a></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- first string expression </td></tr>
    <tr><td class="paramname">b</td><td>- second string expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsimstr_1_1strexprjoin.html" title="Template class for concatenating two string expressions into one using operator +">strexprjoin&lt;A, B&gt;</a>, a string expression that generates a join of the given expressions.</dd></dl>
<p>When two objects are added - string expressions, one of type <code>A</code>, the other of type <code>B</code>, we return an object of type <a class="el" href="structsimstr_1_1strexprjoin.html" title="Template class for concatenating two string expressions into one using operator +">strexprjoin&lt;A, B&gt;</a>, which contains references to these two operands. And the <a class="el" href="structsimstr_1_1strexprjoin.html" title="Template class for concatenating two string expressions into one using operator +">strexprjoin&lt;A, B&gt;</a> object itself, in turn, is also a string expression, and can participate in the following addition operations. In this way, a tree is formed from the original strings expressions, which are then materialized into the final result in one call. </p>

</div>
</div>
<a id="ga166596bf110c32b8c6bdb79917cd2384" name="ga166596bf110c32b8c6bdb79917cd2384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166596bf110c32b8c6bdb79917cd2384">&#9670;&#160;</a></span>operator+() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename Val, bool All, bool Ucase, bool Ox&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_hex&lt; typename A::symb_type, Val, All, Ucase, Ox &gt;, true &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const expr_hex_src&lt; Val, All, Ucase, Ox &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for a string expression and a hexadecimal representation of a number from <a class="el" href="#ga6ae75ae56c754403fbf9f5b610a3326b" title="Allows you to concatenate text and a unsigned number in hexadecimal.">e_hex()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a string expression. </td></tr>
    <tr><td class="paramname">b</td><td>is e_hex(number). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d03cfa41a4f78e843b88b0ce74be7c8" name="ga0d03cfa41a4f78e843b88b0ce74be7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d03cfa41a4f78e843b88b0ce74be7c8">&#9670;&#160;</a></span>operator+() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_hex&lt; typename A::symb_type, uintptr_t, true, true, true &gt;, true &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for a string expression and a pointer, representing it as 0xDEADBEEF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a string expression. </td></tr>
    <tr><td class="paramname">b</td><td>is a pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d8bc7652fac165ad43ae054fb083616" name="ga9d8bc7652fac165ad43ae054fb083616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d8bc7652fac165ad43ae054fb083616">&#9670;&#160;</a></span>operator+() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, StrExprForType&lt; K &gt; A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_char&lt; K &gt; &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator of a string expression and one character. </p>
<dl class="section return"><dt>Returns</dt><dd>a string expression that combines the passed expression and a character.</dd></dl>
<p>Example:</p>
<div class="fragment"><div class="line">reply = prompt + <span class="charliteral">&#39;&gt;&#39;</span> + result;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga1a42429815e770265b76a4211d55b2c5" name="ga1a42429815e770265b76a4211d55b2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a42429815e770265b76a4211d55b2c5">&#9670;&#160;</a></span>operator+() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename R&gt; <br />
requires (std::is_same_v&lt;R, double&gt; || std::is_same_v&lt;R, float&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_real&lt; typename A::symb_type &gt; &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for string expression and real number (<code>float</code>, <code>double</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a string expression. </td></tr>
    <tr><td class="paramname">s</td><td>- number.</td></tr>
  </table>
  </dd>
</dl>
<p>The number is converted to a string representation via sprintf("%.16g"). </p>

</div>
</div>
<a id="ga426dd6edd38c382f64fb4cc547896c80" name="ga426dd6edd38c382f64fb4cc547896c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga426dd6edd38c382f64fb4cc547896c80">&#9670;&#160;</a></span>operator+() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename T, typename P = typename const_lit&lt;T&gt;::symb_type, size_t N = const_lit&lt;T&gt;::Count&gt; <br />
requires <a class="el" href="#ga4cc5f9a930baa653948843b0d2284b27">is_equal_str_type_v</a>&lt;typename A::symb_type, P&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_literal_join&lt; false, P,(N - 1), A &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The addition operator for a string expression and a string literal of the same character type. </p>
<dl class="section return"><dt>Returns</dt><dd>A string expression concatenating the operands. </dd></dl>

</div>
</div>
<a id="ga0421f6f954a1f0a4575cb282c1e36712" name="ga0421f6f954a1f0a4575cb282c1e36712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0421f6f954a1f0a4575cb282c1e36712">&#9670;&#160;</a></span>operator+() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, FromIntNumber T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_num&lt; typename A::symb_type, T &gt; &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for string expression and integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a string expression. </td></tr>
    <tr><td class="paramname">s</td><td>- number.</td></tr>
  </table>
  </dd>
</dl>
<p>The number is converted to a decimal string representation. </p>

</div>
</div>
<a id="ga356a058d98bfa4eca0a44e49745bde28" name="ga356a058d98bfa4eca0a44e49745bde28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga356a058d98bfa4eca0a44e49745bde28">&#9670;&#160;</a></span>operator+() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename Val, bool All, bool Ucase, bool Ox&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_hex&lt; typename A::symb_type, Val, All, Ucase, Ox &gt;, false &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const expr_hex_src&lt; Val, All, Ucase, Ox &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for the hexadecimal representation of a number from <a class="el" href="#ga6ae75ae56c754403fbf9f5b610a3326b" title="Allows you to concatenate text and a unsigned number in hexadecimal.">e_hex()</a> and a string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- e_hex(number). </td></tr>
    <tr><td class="paramname">b</td><td>is a string expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5befc2f161aca230425db4c66cc90ce5" name="ga5befc2f161aca230425db4c66cc90ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5befc2f161aca230425db4c66cc90ce5">&#9670;&#160;</a></span>operator+() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_hex&lt; typename A::symb_type, uintptr_t, true, true, true &gt;, false &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for a pointer and a string expression, representing it as 0xDEADBEEF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- pointer. </td></tr>
    <tr><td class="paramname">b</td><td>is a string expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b067a24eabc409c0b323d4560cf063f" name="ga8b067a24eabc409c0b323d4560cf063f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b067a24eabc409c0b323d4560cf063f">&#9670;&#160;</a></span>operator+() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename R&gt; <br />
requires (std::is_same_v&lt;R, double&gt; || std::is_same_v&lt;R, float&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_real&lt; typename A::symb_type &gt;, false &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">R</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for float (<code>float</code>, <code>double</code>) and string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- number. </td></tr>
    <tr><td class="paramname">a</td><td>is a string expression.</td></tr>
  </table>
  </dd>
</dl>
<p>The number is converted to a string representation via <code>sprintf("%.16g")</code>. </p>

</div>
</div>
<a id="ga07c35bc9eecc1509118d73ef5e27d303" name="ga07c35bc9eecc1509118d73ef5e27d303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07c35bc9eecc1509118d73ef5e27d303">&#9670;&#160;</a></span>operator+() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, typename T, typename P = typename const_lit&lt;T&gt;::symb_type, size_t N = const_lit&lt;T&gt;::Count&gt; <br />
requires <a class="el" href="#ga4cc5f9a930baa653948843b0d2284b27">is_equal_str_type_v</a>&lt;typename A::symb_type, P&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">expr_literal_join&lt; true, P,(N - 1), A &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The addition operator for a string literal of the same character type and string expression. </p>
<dl class="section return"><dt>Returns</dt><dd>A string expression concatenating the operands. </dd></dl>

</div>
</div>
<a id="gaff6edec79f617564db65f91039283f39" name="gaff6edec79f617564db65f91039283f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff6edec79f617564db65f91039283f39">&#9670;&#160;</a></span>operator+() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StrExpr A, FromIntNumber T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1strexprjoin__c.html">strexprjoin_c</a>&lt; A, expr_num&lt; typename A::symb_type, T &gt;, false &gt; simstr::operator+ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenation operator for integer and string expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- number. </td></tr>
    <tr><td class="paramname">a</td><td>is a string expression.</td></tr>
  </table>
  </dd>
</dl>
<p>The number is converted to a decimal string representation. </p>

</div>
</div>
<a id="ga22ea6d3c42a2de8611842e367c1bc327" name="ga22ea6d3c42a2de8611842e367c1bc327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22ea6d3c42a2de8611842e367c1bc327">&#9670;&#160;</a></span>operator+() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;simstr::StdStrSource T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimstr_1_1expr__stdstr.html">simstr::expr_stdstr</a>&lt; typename T::value_type, T &gt; std::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary operator + for converting standard strings to string expressions. </p>
<p>Standard strings can only participate directly in string expressions when the other operand is also a string expression. If the other operand is not a string expression, use this operator to turn <code>std::basic_string</code> or <code>std::basic_string_view</code> into string expression. Example </p><div class="fragment"><div class="line">std::string make_text(<span class="keyword">const</span> std::string&amp; text, <span class="keywordtype">int</span> count, std::string_view what, std::string_view what_p = <span class="stringliteral">&quot;&quot;</span>sv) {</div>
<div class="line">    <span class="keywordflow">return</span> +text + <span class="stringliteral">&quot; &quot;</span> + count + <span class="stringliteral">&quot; &quot;</span> + e_choice(what_p.empty(), what + e_if(count &gt; 1, <span class="stringliteral">&quot;s&quot;</span>), e_choice(count &gt; 1, +what_p, +what));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga4cc5f9a930baa653948843b0d2284b27" name="ga4cc5f9a930baa653948843b0d2284b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc5f9a930baa653948843b0d2284b27">&#9670;&#160;</a></span>is_equal_str_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K1, typename K2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool simstr::is_equal_str_type_v = is_one_of_char_v&lt;K1&gt; &amp;&amp; is_one_of_char_v&lt;K2&gt; &amp;&amp; sizeof(K1) == sizeof(K2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether two types are compatible string types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K1</td><td>is the first type to check. </td></tr>
    <tr><td class="paramname">K2</td><td>is the second type to check.</td></tr>
  </table>
  </dd>
</dl>
<p>Both types must be string types and the same size. That is, char and char8_t are always compatible, wchar_t is identical to char32_t on Linux, and char16_t on Windows. This is for the ability to mix string expressions of compatible types. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
